  <chapter id="gnome-canvas">

    <docinfo>
      <title>The <type>GnomeCanvas</type> widget</title>

      <authorgroup>
	<author>
	  <firstname>Federico</firstname>
	  <surname>Mena Quintero</surname>
	  <authorblurb>
	    <simpara><email>federico@nuclecu.unam.mx</email></simpara>
	  </authorblurb>
	</author>
      </authorgroup>

      <copyright>
	<year>1998</year>
	<holder>The GNOME Project</holder>
      </copyright>
    </docinfo>

    <title>The <type>GnomeCanvas</type> widget</title>

    <sect1 id="gnome-canvas-introduction">

      <title>Introduction</title>

      <para>
	The <type>GnomeCanvas</type> widget is a high-level engine for
	creating structured graphics.  A canvas displays a collection of
	items, which can be lines, rectangles, ellipses, and text.
	Items have attributes associated to them that you can change,
	like fill color, position, and size.  Items may be moved and
	re-stacked in the canvas, and organized in hierarchical groups.
	You can receive mouse and keyboard events from the items and
	perform actions on them based on these events.
      </para>

      <para>
	The canvas is useful for when you want to create interactive
	graphics displays which would be hard or cumbersome to implement
	with raw calls to Gdk, or when writing a custom widget for Gtk
	is inconvenient.
      </para>

      <para>
	The canvas is also useful to create displays of graphs,
	diagrams, and many other types of structured drawings.  It can
	even be used as a general display engine &mdash; for example,
	the Gnumeric spreadsheet and the Achtung presentations program
	both use the GnomeCanvas widget as their display engine.
      </para>

      <para>
	If the predefined canvas item types do not suit your needs, you
	can easily write new item types.  These can be primitive items,
	which paint their own displays, or composite items, which are
	built on top of canvas item groups.
      </para>

    </sect1>

    <sect1 id="gnome-canvas-organization-of-items">

      <title>Organization of items</title>

      <para>
	Items in the canvas are organized in a tree hierarchy.  Items
	can be groups (nodes in the tree), or terminal items (leaves in
	the tree).  Groups can contain any number of children, which can
	be terminal items or other groups.  Thus, items can be nested to
	an arbitrary depth inside a canvas.
      </para>

      <para>
	A canvas has a single root group.  For simple drawings, it is
	likely that you will want to put all your items directly inside
	this group.  For more complex drawings, it may be convenient to
	use a hierarchical structure of nested canvas groups.
      </para>

      <para>
	For example, consider a circuit editor.  You could define groups
	that contain the items that are necessary to draw a logic gate.
	Then you could define groups for different components.  A group
	representing an adder would contain several logic gates and some
	wires.  You would then group some adders with other components
	to form a more complex circuit.
      </para>

      <sect2 id="gnome-canvas-stacking-order">

	<title>Stacking order</title>

	<para>
	  The items you put inside groups are stacked on top of each
	  other, and items nearer the top of the stack obscure the items
	  below them.  When an item is created, it is put on top of all
	  the items in its parent group.
	</para>

	<para>
	  The canvas provides several functions to let you change the
	  stacking order of items inside groups.  You can move items
	  to the top or bottom of their parent group, and raise or
	  lower them by an arbitrary number of positions.
	</para>

      </sect2>

      <sect2 id="gnome-canvas-behavior-and-events">

	<title>Behavior and events</title>

	<para>
	  The canvas does <emphasis>not</emphasis> have any predefined
	  behavior for items.  You can define the behavior of items by
	  explicitly operating on them (change the color if item Foo
	  when the user selects a menu item), or by defining actions
	  that should take place when items receive events (let the
	  user drag items with the mouse).
	</para>

	<para>
	  The rationale behind this is that the canvas should be as
	  general-purpose as possible.  If it had predefined behavior
	  for items, it may not be suitable to all kinds of
	  applications &mdash; a program for drawing schematic
	  diagrams may benefit from having dragging functionality
	  predefined in the canvas, but this would not be very useful
	  (or even desirable) for a calendar display program.
	</para>

      </sect2>

    </sect1>

    <sect1 id="gnome-canvas-coordinates">

      <title>Coordinates</title>

      <para>
	The canvas uses a world coordinate system with coordinates
	specified as floating point numbers.  World coordinates mean
	that units can represent whatever is most convenient to you:
	meters, pixels, parsecs, etc.
      </para>

      <para>
	Coordinates are calculated from the origin of the canvas,
	which has coordinates (0.0, 0.0).  Positive X coordinates go
	to the right of the origin, and positive Y coordinates go
	down, like in the rest of the X Window System.
      </para>

      <para>
	Coordinates of items are calculated with respect to their
	parent group.  When a group is moved, its children's logical
	coordinates do not change, although their physical position
	does.  A group stores a single pair of coordinates which
	define its origin relative to its parent group.  The canvas's
	root group starts with its origin in world position (0.0,
	0.0).
      </para>

      <para>
	For example, let's say you have a toplevel group at (5.0,
	3.0).  If you insert an item in it with coordinates (2.0,
	1.0), the item will appear to be at coordinates (7.0, 4.0).
	Coordinates of items are always relative to their parent
	group.
      </para>

      <para>
	You will normally only need use this floating point, world
	coordinate system.  The canvas also has a different coordinate
	system which works in terms of pixel offsets.  This coordinate
	system is used internally to control scrolling of the canvas.
	You won't need to know about it unless you want to do
	scrolling by hand (as opposed to letting scrollbars handle
	this for you), or when you create your own canvas item types.
	We will discuss this pixel coordinate system later.
      </para>

      <sect2 id="gnome-canvas-zooming-and-scale">

	<title>Zooming and scale</title>

	<para>
	  You can change the zoom factor of the canvas so that all the
	  objects in it will appear larger or smaller.  To control the
	  zoom factor, you specify the number of <emphasis>pixels per
	  unit</emphasis> that the canvas will use when converting
	  world coordinates to display coordinates.  The default is to
	  use 1.0 pixels per unit, so an object that is 10 units wide
	  will be displayed as 10 pixels wide.  If you set the canvas
	  to use 5 pixels per unit, then that object will be displayed
	  as 50 pixels wide.
	</para>

	<para>
	  Sometimes you may want some features of your drawing to have
	  the same displayed size regardless of the zoom factor of the
	  canvas.  For example, in a display of a graph composed of
	  vertices and edges, you may want the edges to keep the same
	  displayed width even if you zoom in closer to the graph, as
	  well as having arrowheads keep the same size regardless of
	  the zoom factor of the canvas.
	</para>

	<para>
	  Canvas items like lines and rectangles which support an
	  outline width parameter let you select whether the outline
	  width is specified in absolute pixels (which will keep the
	  same displayed size regardless of the zoom factor of the
	  canvas), or normal units (which will get scaled when the
	  zoom factor is changed).
	</para>

      </sect2>

    </sect1>

    <sect1 id="gnome-canvas-object-arguments">

      <title>Attributes and object arguments</title>

      <para>
	The canvas makes extensive use of the Gtk object argument
	system &mdash; all the items' attributes are configured and
	queried through it.  You only need to have only a minimal
	knowledge of how the argument system works, so do not worry if
	you do not want to learn all the details.  Here we will
	explain everything you need to know.
      </para>

      <para>
	The purpose of this is twofold; by using the Gtk argument
	system to set and query all of the canvas items' attributes,
	we avoid having many API entry points which could potentially
	bloat the library, and we also make it easy for language
	bindings to be written and integrated with the canvas.
      </para>

    </sect1>

    <sect1 id="gnome-canvas-getting-started">

      <title>Getting started with the canvas</title>

      <para>
	This section presents a simple example of using the canvas to
	display some objects and manipulate them.  We will create a
	blank canvas and provide a button that the user can click to
	insert random objects in it.  If the user double-clicks on an
	object with mouse button 1, the color of that item will be
	changed.  The user can also move objects around by pressing
	mouse button 1 and dragging.  In addition, objects may be
	deleted by pressing mouse button 3 over them.  Objects will
	get a wide outline when the mouse passes over them, and will
	return to a thin outline when the mouse leaves them.
      </para>

      <para>
	We will present the program in small sections and explain each
	of them separately.
      </para>

      <example>

	<title>Creating the main window and the canvas</title>

	<para>
	  Here we create a window for the canvas example and put a
	  canvas widget into it.  we also create buttons that let the
	  user insert a new object in the canvas and exit the program.
	  We also define the auxiliary handlers for the clicked signal
	  of the Exit button and the delete_event signal of the main
	  window.
	</para>

	<programlisting role="C">
#include &lt;gnome.h&gt;


/* This defines the size of the canvas, in pixels */

#define CANVAS_SIZE 300


/* Prototypes for the functions we will define later */

static void add_object_clicked (GtkWidget *button, gpointer data);
static void exit_clicked (GtkWidget *widget, gpointer data);
static gint delete_event (GtkWidget *widget, GdkEvent *event, gpointer data);


int
main (int argc, char **argv)
{
	GtkWidget *window;
	GtkWidget *vbox;
	GtkWidget *frame;
	GtkWidget *canvas;
	GtkWidget *hbox;
	GtkWidget *button;

	gnome_init ("canvas-example", NULL, argc, argv, 0, NULL);

	/* Create the main window and the main vbox */

	window = gtk_window_new (GTK_WINDOW_TOPLEVEL);

	vbox = gtk_vbox_new (FALSE, 0);
	gtk_container_add (GTK_CONTAINER (window), vbox);
	gtk_widget_show (vbox);

	/* Create a frame for the canvas and the canvas itself */

	frame = gtk_frame_new (NULL);
	gtk_frame_set_shadow_type (GTK_FRAME (frame), GTK_SHADOW_IN);
	gtk_box_pack_start (GTK_BOX (vbox), frame, TRUE, TRUE, 0);
	gtk_widget_show (frame);

	canvas = gnome_canvas_new ();
	gnome_canvas_set_size (GNOME_CANVAS (canvas), CANVAS_SIZE, CANVAS_SIZE);
	gnome_canvas_set_scroll_region (GNOME_CANVAS (canvas), 0.0, 0.0, CANVAS_SIZE, CANVAS_SIZE);

	gtk_container_add (GTK_CONTAINER (frame), canvas);
	gtk_widget_show (canvas);

	/* Create the hbox for the buttons */

	hbox = gtk_hbox_new (TRUE, 0);
	gtk_box_pack_start (GTK_BOX (vbox), hbox, FALSE, FALSE, 0);
	gtk_widget_show (hbox);

	/* Create the button used to add objects -- we pass the canvas to the callback
	 * in the user data.
	 */

	button = gtk_button_new_with_label ("Add an object");
	gtk_signal_connect (GTK_OBJECT (button), "clicked",
			    (GtkSignalFunc) add_object_clicked,
			    canvas);
	gtk_box_pack_start (GTK_BOX (hbox), button, TRUE, TRUE, 0);
	gtk_widget_show (button);

	/* Create the button used to exit the program -- we pass the main window to the callback in
	 * the user data.
	 */

	button = gtk_button_new_with_label ("Exit");
	gtk_signal_connect (GTK_OBJECT (button), "clicked",
			    (GtkSignalFunc) exit_clicked,
			    window);
	gtk_box_pack_start (GTK_BOX (hbox), button, TRUE, TRUE, 0);
	gtk_widget_show (button);

	/* Connect to the delete_event signal and Run the application */

	gtk_signal_connect (GTK_OBJECT (window), "delete_event",
			    (GtkSignalFunc) delete_event,
			    NULL);

	gtk_widget_show (window);
	gtk_main ();
	return 0;
}

/* Callback for the clicked signal of the Exit button */
static void
exit_clicked (GtkWidget *widget, gpointer data)
{
	gtk_widget_destroy (GTK_WIDGET (data)); /* the user data points to the main window */
	gtk_main_quit ();
}

/* Callback for the delete_event signal of the main application window */
static gint
delete_event (GtkWidget *widget, GdkEvent *event, gpointer data)
{
	gtk_widget_destroy (widget); /* destroy the main window */
	gtk_main_quit ();
	return TRUE;
}
	</programlisting>

      </example>

    </sect1>

  </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:2
sgml-indent-data:t
sgml-parent-document:("gnome-dev-info.sgml" "book" "sect1" "")
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
