From owner-gnome-hackers@athena.nuclecu.unam.mx  Thu Jul  2 02:44:23 1998
Return-Path: <owner-gnome-hackers>
X-Authentication-Warning: lifesaver.mtg.co.at: andreas owned process doing -bs
Date: Thu, 2 Jul 1998 09:38:11 +0200 (CEST)
From: Andreas Kostyrka <andreas@ag.or.at>
X-Sender: andreas@lifesaver
To: gnome-hackers@nuclecu.unam.mx
Subject: language bindings & Gnome
MIME-Version: 1.0
Content-Type: TEXT/PLAIN; charset=US-ASCII
Sender: owner-gnome-hackers@nuclecu.unam.mx
Precedence: bulk

Hi!

Considering that the language bindings are probably important to Gnome
(else it's a bit a C-language KDE :( ), and that most gnome hackers are
not involved in writing language bindings, I've considered to do a README
style design guide about ``bad things to do''(tm), as many problems in
Gnome are probable not by design, but by not knowing what is problematic:

Evil things in C.
1.) va_args (also recognized by the ...), are problematic.
    (example: GnomeDialog_new) This kind of functions cannot be called
    from ANSI C with deliberate arguments.
    Better solution: char **args, and perhaps a wrapper function for ...
                     that calls this argument passing one.
2.) memory control. In C you have 100% full control how and which memory
    is used. Not so in many language that are often garbage controlled.
    So if at all possible, a pointer passed in should be deep copied.
    Example: TOM bindings for GnomeUIInfo arrays. These bindings force the
    TOM programmer to retain the object somewhere where it will not be
    collected because collecting the TOM object frees also the C structure
    assembled, which could have BAD influence on Gnome.
    Basically, for most languages assume, that it is garbage collected,
    and that pointers in GtkObjects don't protect the host language
    objects.
3.) GtkObjects are good. GdkStructs are rather bad. GtkObjects are good,
    because they can be dealt OO style once with. GdkStructs are more
    problematic, because their intended usage is not clear as such. If you
    need to use a struct, than stick with one usage, like fro example
    GdkColors, that are always used by value, meaning that all passed in
    pointers are just dereferenced and copied.
    A changing usage policy (here it is copied, here the pointer is just
    stored) makes for more difficult bindings.
4.) Callbacks. Callbacks must always carry one freely setable pointer
    argument. Callbacks should also have a DestroyNotify.
    Rationale: In most language generating new C functions is either
               impossible or too difficult. This means, that usually
               language map all callbacks (at least of one kind) to a
               given function, and this function uses the pointer argument
               to know which binding in the host language is meant.
               As this data areas for method binding are probably
               dynamically allocated, a DestroyNotify is a "good
               thing"(tm) to prevent memory leaks.
    Bad example: GnomeMDIChild set_menu_template that uses
                 gnomeapp_create_menus_with_data. This is basically
                 nonwrappable.
5.) Subclassing. At the moment I believe there is no language wrapping
                 for subclassing a GtkObject class. This is by design
                 difficult, as it involves structs that point to callbacks
                 without the needed extra parameter and other niceties :(
                 So don't force the user of your widget to subclass some
                 object to use your code. You can make it easier by
                 subclassing but always leave a possibility to do it
                 without full blown subclassing. To explain what is
                 probably managable from all languages:
                 C: GnomeMDIChild            TOM: GnomeMDIChild
                                                  \- MyChild
                 So on the C side MyChild objects are represented by
                 GnomeMDIChilds. Callbacks are handled in such an setup
                 not by overwriting function pointers in the class struct
                 (as in gnome-hello-7-mdi MyChild class), but by
                 connecting signals to these slots.

As I'm the tomgtk guy, I wrote it with TOM in mind. But these points
probably also apply to most other languages, and other languages are
perhaps even less flexible as TOM. So comments please, and should this be
perhaps added somewhere in the CVS?

Andreas


