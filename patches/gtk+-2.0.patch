? gtk-config-2.0
? conftest.S
? gdk/makefile.mingw
? gdk/win32/makefile.mingw
? gdk-pixbuf/makefile.mingw
? gdk-pixbuf/pixops/makefile.mingw
? gtk/makefile.mingw
? po/gtk20.pot
Index: ChangeLog
===================================================================
RCS file: /cvs/gnome/gtk+/ChangeLog,v
retrieving revision 1.1383
diff -u -u -r1.1383 ChangeLog
--- ChangeLog	2000/08/30 00:33:34	1.1383
+++ ChangeLog	2000/08/30 19:45:23
@@ -1,3 +1,13 @@
+2000-08-02  Martin Baulig  <baulig@suse.de>
+
+	* gtk/gtkbindings.c (binding_entry_destroy): Don't call
+	the deprecated g_hash_table_freeze/thaw().
+	(binding_entry_new): Likewise.
+
+	* gtk/gtkrc.c (gtk_rc_parse_file): Use g_path_get_dirname() and
+	not the deprecated g_get_dirname().
+	(gtk_rc_parse_any): Don't call g_scanner_freeze/thaw_symbol_table().
+
 2000-08-29 Elliot Lee <sopwith@redhat.com>
 	* */*.h: Use G_GNUC_CONST.
 
Index: gdk/x11/gdkimage-x11.c
===================================================================
RCS file: /cvs/gnome/gtk+/gdk/x11/gdkimage-x11.c,v
retrieving revision 1.24
diff -u -u -r1.24 gdkimage-x11.c
--- gdk/x11/gdkimage-x11.c	2000/07/26 11:32:30	1.24
+++ gdk/x11/gdkimage-x11.c	2000/08/30 19:45:24
@@ -355,7 +355,6 @@
 	  break;
 
 	case GDK_IMAGE_FASTEST:
-	case GDK_IMAGE_SHARED_PIXMAP:
 	  g_assert_not_reached ();
 	}
 
@@ -492,7 +491,6 @@
       break;
 
     case GDK_IMAGE_FASTEST:
-    case GDK_IMAGE_SHARED_PIXMAP:
       g_assert_not_reached ();
     }
 
Index: gtk/gtkbindings.c
===================================================================
RCS file: /cvs/gnome/gtk+/gtk/gtkbindings.c,v
retrieving revision 1.20
diff -u -u -r1.20 gtkbindings.c
--- gtk/gtkbindings.c	2000/07/26 11:32:42	1.20
+++ gtk/gtkbindings.c	2000/08/30 19:45:25
@@ -122,11 +122,9 @@
   binding_set->entries = entry;
 
   entry->hash_next = g_hash_table_lookup (binding_entry_hash_table, entry);
-  g_hash_table_freeze (binding_entry_hash_table);
   if (entry->hash_next)
     g_hash_table_remove (binding_entry_hash_table, entry->hash_next);
   g_hash_table_insert (binding_entry_hash_table, entry, entry);
-  g_hash_table_thaw (binding_entry_hash_table);
   
   return entry;
 }
@@ -205,10 +203,8 @@
     g_hash_table_remove (binding_entry_hash_table, entry);
   else if (begin != o_entry)
     {
-      g_hash_table_freeze (binding_entry_hash_table);
       g_hash_table_remove (binding_entry_hash_table, entry);
       g_hash_table_insert (binding_entry_hash_table, begin, begin);
-      g_hash_table_thaw (binding_entry_hash_table);
     }
 
   entry->destroyed = TRUE;
Index: gtk/gtkrc.c
===================================================================
RCS file: /cvs/gnome/gtk+/gtk/gtkrc.c,v
retrieving revision 1.63
diff -u -u -r1.63 gtkrc.c
--- gtk/gtkrc.c	2000/08/22 03:05:13	1.63
+++ gtk/gtkrc.c	2000/08/30 19:45:27
@@ -680,7 +680,7 @@
        * a stack of directory names while parsing it
        */
       rc_dir_stack = g_slist_prepend (rc_dir_stack,
- 				      g_dirname (rc_file->canonical_name));
+ 				      g_path_get_dirname (rc_file->canonical_name));
       gtk_rc_parse_any (filename, fd, NULL);
  
       tmp_list = rc_dir_stack;
@@ -1234,10 +1234,8 @@
     }
   scanner->input_name = input_name;
 
-  g_scanner_freeze_symbol_table (scanner);
   for (i = 0; i < n_symbols; i++)
     g_scanner_add_symbol (scanner, symbols[i].name, GINT_TO_POINTER (symbols[i].token));
-  g_scanner_thaw_symbol_table (scanner);
   
   done = FALSE;
   while (!done)
Index: gdk-pixbuf//gdk-pixbuf-loader.c
===================================================================
RCS file: gdk-pixbuf-loader.c
diff -N gdk-pixbuf-loader.c
--- /dev/null	Tue May  5 16:32:27 1998
+++ gdk-pixbuf-loader.c	Tue Sep  5 20:46:01 2000
@@ -0,0 +1,443 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/* GdkPixbuf library - Main header file
+ *
+ * Copyright (C) 1999 The Free Software Foundation
+ *
+ * Authors: Mark Crichton <crichton@gimp.org>
+ *          Miguel de Icaza <miguel@gnu.org>
+ *          Federico Mena-Quintero <federico@gimp.org>
+ *          Jonathan Blandford <jrb@redhat.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include <config.h>
+#include <string.h>
+
+#include "gdk-pixbuf-private.h"
+#include "gdk-pixbuf-loader.h"
+#include "gdk-pixbuf-io.h"
+
+
+
+static void gdk_pixbuf_loader_class_init    (GdkPixbufLoaderClass   *klass,
+                                             gpointer                class_data);
+static void gdk_pixbuf_loader_init          (GdkPixbufLoader        *loader,
+                                             GdkPixbufLoaderClass   *klass);
+static void gdk_pixbuf_loader_finalize      (GObject                *loader);
+
+
+
+static gpointer parent_class;
+
+
+
+/* Internal data */
+
+#define LOADER_HEADER_SIZE 128
+
+typedef struct {
+	GdkPixbuf *pixbuf;
+	GdkPixbufAnimation *animation;
+	gboolean closed;
+	guchar header_buf[LOADER_HEADER_SIZE];
+	gint header_buf_offset;
+	GdkPixbufModule *image_module;
+	gpointer context;
+} GdkPixbufLoaderPrivate;
+
+
+
+/**
+ * gdk_pixbuf_loader_get_type:
+ * @void:
+ *
+ * Registers the #GdkPixubfLoader class if necessary, and returns the type ID
+ * associated to it.
+ *
+ * Return value: The type ID of the #GdkPixbufLoader class.
+ **/
+GType
+gdk_pixbuf_loader_get_type (void)
+{
+	static GType loader_type = 0;
+
+	if (!loader_type) {
+		static const GTypeInfo loader_info = {
+			sizeof (GdkPixbufLoaderClass),
+			(GBaseInitFunc) NULL,
+			(GBaseFinalizeFunc) NULL,
+			(GClassInitFunc) gdk_pixbuf_loader_class_init,
+			(GClassFinalizeFunc) NULL,
+			(gpointer) NULL, /* class_data */
+			sizeof (GdkPixbufLoader),
+			0,
+			(GInstanceInitFunc) gdk_pixbuf_loader_init,
+			NULL /* value_table */
+		};
+
+		loader_type = g_type_register_static (G_TYPE_OBJECT,
+						      "GdkPixbufLoader",
+						      &loader_info);
+	}
+
+	return loader_type;
+}
+
+static void
+gdk_pixbuf_loader_class_init (GdkPixbufLoaderClass *klass,
+			      gpointer class_data)
+{
+        GObjectClass *object_class = G_OBJECT_CLASS (klass);
+        
+        parent_class = g_type_class_peek_parent (klass);
+        
+        object_class->finalize = gdk_pixbuf_loader_finalize;
+}
+
+static void
+gdk_pixbuf_loader_init (GdkPixbufLoader *loader,
+			GdkPixbufLoaderClass *klass)
+{
+	GdkPixbufLoaderPrivate *priv;
+
+	priv = g_new0 (GdkPixbufLoaderPrivate, 1);
+	loader->private = priv;
+}
+
+static void
+gdk_pixbuf_loader_finalize (GObject *object)
+{
+	GdkPixbufLoader *loader;
+	GdkPixbufLoaderPrivate *priv = NULL;
+
+	loader = GDK_PIXBUF_LOADER (object);
+	priv = loader->private;
+
+	if (priv) {
+		if (!priv->closed)
+			gdk_pixbuf_loader_close (loader);
+
+		if (priv->animation)
+			gdk_pixbuf_animation_unref (priv->animation);
+		if (priv->pixbuf)
+			gdk_pixbuf_unref (priv->pixbuf);
+
+		g_free (priv);
+	}
+
+        G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static void
+gdk_pixbuf_loader_prepare (GdkPixbuf *pixbuf, gpointer loader)
+{
+	GdkPixbufLoaderPrivate *priv = NULL;
+
+	priv = GDK_PIXBUF_LOADER (loader)->private;
+	gdk_pixbuf_ref (pixbuf);
+	g_assert (priv->pixbuf == NULL);
+
+	priv->pixbuf = pixbuf;
+}
+
+static void
+gdk_pixbuf_loader_update (GdkPixbuf *pixbuf, guint x, guint y, guint width, guint height, gpointer loader)
+{
+	GdkPixbufLoaderPrivate *priv = NULL;
+
+	priv = GDK_PIXBUF_LOADER (loader)->private;
+}
+
+static void
+gdk_pixbuf_loader_frame_done (GdkPixbufFrame *frame, gpointer loader)
+{
+	GdkPixbufLoaderPrivate *priv = NULL;
+
+	priv = GDK_PIXBUF_LOADER (loader)->private;
+
+	priv->pixbuf = NULL;
+
+	if (priv->animation == NULL) {
+		priv->animation = g_object_new (GDK_TYPE_PIXBUF_ANIMATION, NULL);
+		priv->animation->n_frames = 0;
+		priv->animation->width  = gdk_pixbuf_get_width  (frame->pixbuf) + frame->x_offset;
+		priv->animation->height = gdk_pixbuf_get_height (frame->pixbuf) + frame->y_offset;
+	} else {
+		int w, h;
+
+		/* update bbox size */
+		w = gdk_pixbuf_get_width (frame->pixbuf) + frame->x_offset;
+		h = gdk_pixbuf_get_height (frame->pixbuf) + frame->y_offset;
+
+		if (w > priv->animation->width) {
+			priv->animation->width = w;
+		}
+		if (h > priv->animation->height) {
+			priv->animation->height = h;
+		}
+	}
+
+	priv->animation->frames = g_list_append (priv->animation->frames, frame);
+	priv->animation->n_frames ++;
+}
+
+static void
+gdk_pixbuf_loader_animation_done (GdkPixbuf *pixbuf, gpointer loader)
+{
+	GdkPixbufLoaderPrivate *priv = NULL;
+	GdkPixbufFrame    *frame;
+	GList *current = NULL;
+	gint h, w;
+
+	priv = GDK_PIXBUF_LOADER (loader)->private;
+	priv->pixbuf = NULL;
+
+	current = gdk_pixbuf_animation_get_frames (priv->animation);
+
+	while (current) {
+		frame = (GdkPixbufFrame *) current->data;
+
+		/* update bbox size */
+		w = gdk_pixbuf_get_width (frame->pixbuf) + frame->x_offset;
+		h = gdk_pixbuf_get_height (frame->pixbuf) + frame->y_offset;
+
+		if (w > priv->animation->width) {
+			priv->animation->width = w;
+		}
+		if (h > priv->animation->height) {
+			priv->animation->height = h;
+		}
+		current = current->next;
+	}
+}
+
+
+
+/**
+ * gdk_pixbuf_loader_new:
+ *
+ * Creates a new pixbuf loader object.
+ *
+ * Return value: A newly-created pixbuf loader.
+ **/
+GdkPixbufLoader *
+gdk_pixbuf_loader_new (void)
+{
+	return g_object_new (GDK_TYPE_PIXBUF_LOADER, NULL);
+}
+
+static int
+gdk_pixbuf_loader_load_module(GdkPixbufLoader *loader)
+{
+	GdkPixbufLoaderPrivate *priv = loader->private;
+
+	priv->image_module = gdk_pixbuf_get_module (priv->header_buf, priv->header_buf_offset);
+
+	if (priv->image_module == NULL)
+		return 0;
+
+	if (priv->image_module->module == NULL)
+		gdk_pixbuf_load_module (priv->image_module);
+
+	if (priv->image_module->module == NULL)
+		return 0;
+
+	if ((priv->image_module->begin_load == NULL) ||
+	    (priv->image_module->stop_load == NULL) ||
+	    (priv->image_module->load_increment == NULL)) {
+		g_warning ("module %s does not support incremental loading.\n",
+			   priv->image_module->module_name);
+		return 0;
+	}
+
+	priv->context = (*priv->image_module->begin_load) (gdk_pixbuf_loader_prepare,
+							   gdk_pixbuf_loader_update,
+							   gdk_pixbuf_loader_frame_done,
+							   gdk_pixbuf_loader_animation_done,
+							   loader);
+
+	if (priv->context == NULL) {
+		g_warning("Failed to begin progressive load");
+		return 0;
+	}
+
+	if( (* priv->image_module->load_increment) (priv->context, priv->header_buf, priv->header_buf_offset) )
+		return priv->header_buf_offset;
+
+	return 0;
+}
+
+static int
+gdk_pixbuf_loader_eat_header_write (GdkPixbufLoader *loader, const guchar *buf, size_t count)
+{
+	int nbytes;
+	GdkPixbufLoaderPrivate *priv = loader->private;
+
+	nbytes = MIN(LOADER_HEADER_SIZE - priv->header_buf_offset, count);
+	memcpy (priv->header_buf + priv->header_buf_offset, buf, nbytes);
+
+	priv->header_buf_offset += nbytes;
+
+	if(priv->header_buf_offset >= LOADER_HEADER_SIZE) {
+		if (gdk_pixbuf_loader_load_module(loader) == 0)
+			return 0;
+	}
+	return nbytes;
+}
+
+/**
+ * gdk_pixbuf_loader_write:
+ * @loader: A pixbuf loader.
+ * @buf: Pointer to image data.
+ * @count: Length of the @buf buffer in bytes.
+ *
+ * This will cause a pixbuf loader to parse the next @count bytes of an image.
+ * It will return TRUE if the data was loaded successfully, and FALSE if an
+ * error occurred.  In the latter case, the loader will be closed, and will not
+ * accept further writes.
+ *
+ * Return value: #TRUE if the write was successful, or #FALSE if the loader
+ * cannot parse the buffer.
+ **/
+gboolean
+gdk_pixbuf_loader_write (GdkPixbufLoader *loader, const guchar *buf, size_t count)
+{
+	GdkPixbufLoaderPrivate *priv;
+
+	g_return_val_if_fail (loader != NULL, FALSE);
+	g_return_val_if_fail (GDK_IS_PIXBUF_LOADER (loader), FALSE);
+
+	g_return_val_if_fail (buf != NULL, FALSE);
+	g_return_val_if_fail (count >= 0, FALSE);
+
+	priv = loader->private;
+
+	/* we expect it's not to be closed */
+	g_return_val_if_fail (priv->closed == FALSE, FALSE);
+
+	if (priv->image_module == NULL) {
+		int eaten;
+
+		eaten = gdk_pixbuf_loader_eat_header_write(loader, buf, count);
+		if (eaten <= 0)
+			return FALSE;
+
+		count -= eaten;
+		buf += eaten;
+	}
+
+	if (count > 0 && priv->image_module->load_increment)
+		return (* priv->image_module->load_increment) (priv->context, buf, count);
+
+	return TRUE;
+}
+
+/**
+ * gdk_pixbuf_loader_get_pixbuf:
+ * @loader: A pixbuf loader.
+ *
+ * Queries the GdkPixbuf that a pixbuf loader is currently creating.  In general
+ * it only makes sense to call this function afer the "area_prepared" signal has
+ * been emitted by the loader; this means that enough data has been read to know
+ * the size of the image that will be allocated.  If the loader has not received
+ * enough data via gdk_pixbuf_loader_write(), then this function returns NULL.
+ * The returned pixbuf will be the same in all future calls to the loader, so
+ * simply calling gdk_pixbuf_ref() should be sufficient to continue using it.  Additionally,
+ * if the loader is an animation, it will return the first frame of the animation.
+ *
+ * Return value: The GdkPixbuf that the loader is creating, or NULL if not
+ * enough data has been read to determine how to create the image buffer.
+ **/
+GdkPixbuf *
+gdk_pixbuf_loader_get_pixbuf (GdkPixbufLoader *loader)
+{
+	GdkPixbufLoaderPrivate *priv;
+
+	g_return_val_if_fail (loader != NULL, NULL);
+	g_return_val_if_fail (GDK_IS_PIXBUF_LOADER (loader), NULL);
+
+	priv = loader->private;
+
+	if (priv->animation) {
+		GList *list;
+		
+		list = gdk_pixbuf_animation_get_frames (priv->animation);
+		if (list != NULL) {
+			GdkPixbufFrame *frame = list->data;
+
+			return gdk_pixbuf_frame_get_pixbuf (frame);
+		}
+	}
+	return priv->pixbuf;
+}
+
+/**
+ * gdk_pixbuf_loader_get_animation:
+ * @loader: A pixbuf loader
+ *
+ * Queries the GdkPixbufAnimation that a pixbuf loader is currently creating.
+ * In general it only makes sense to call this function afer the "area_prepared"
+ * signal has been emitted by the loader.  If the image is not an animation,
+ * then it will return NULL.
+ *
+ * Return value: The GdkPixbufAnimation that the loader is loading, or NULL if
+ not enough data has been read to determine the information.
+ **/
+GdkPixbufAnimation *
+gdk_pixbuf_loader_get_animation (GdkPixbufLoader *loader)
+{
+	GdkPixbufLoaderPrivate *priv;
+
+	g_return_val_if_fail (loader != NULL, NULL);
+	g_return_val_if_fail (GDK_IS_PIXBUF_LOADER (loader), NULL);
+
+	priv = loader->private;
+
+	return priv->animation;
+}
+
+/**
+ * gdk_pixbuf_loader_close:
+ * @loader: A pixbuf loader.
+ *
+ * Informs a pixbuf loader that no further writes with gdk_pixbuf_load_write()
+ * will occur, so that it can free its internal loading structures.
+ **/
+void
+gdk_pixbuf_loader_close (GdkPixbufLoader *loader)
+{
+	GdkPixbufLoaderPrivate *priv;
+
+	g_return_if_fail (loader != NULL);
+	g_return_if_fail (GDK_IS_PIXBUF_LOADER (loader));
+
+	priv = loader->private;
+
+	/* we expect it's not closed */
+	g_return_if_fail (priv->closed == FALSE);
+
+	/* We have less the 128 bytes in the image.  Flush it, and keep going. */
+	if (priv->image_module == NULL)
+		gdk_pixbuf_loader_load_module (loader);
+
+	if (priv->image_module && priv->image_module->stop_load)
+		(* priv->image_module->stop_load) (priv->context);
+
+	priv->closed = TRUE;
+}
+
Index: gdk-pixbuf//gdk-pixbuf-loader.h
===================================================================
RCS file: gdk-pixbuf-loader.h
diff -N gdk-pixbuf-loader.h
--- /dev/null	Tue May  5 16:32:27 1998
+++ gdk-pixbuf-loader.h	Tue Sep  5 20:46:01 2000
@@ -0,0 +1,76 @@
+/* GdkPixbuf library - Main header file
+ *
+ * Copyright (C) 1999 The Free Software Foundation
+ *
+ * Authors: Mark Crichton <crichton@gimp.org>
+ *          Miguel de Icaza <miguel@gnu.org>
+ *          Federico Mena-Quintero <federico@gimp.org>
+ *          Jonathan Blandford <jrb@redhat.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef GDK_PIXBUF_LOADER_H
+#define GDK_PIXBUF_LOADER_H
+
+#include <unistd.h>
+#include <gdk-pixbuf/gdk-pixbuf.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+
+#define GDK_TYPE_PIXBUF_LOADER		   (gdk_pixbuf_loader_get_type ())
+#define GDK_PIXBUF_LOADER(obj)		   (G_TYPE_CHECK_INSTANCE_CAST ((obj), GDK_TYPE_PIXBUF_LOADER, GdkPixbufLoader))
+#define GDK_PIXBUF_LOADER_CLASS(klass)	   (G_TYPE_CHECK_CLASS_CAST ((klass), GDK_TYPE_PIXBUF_LOADER, GdkPixbufLoaderClass))
+#define GDK_IS_PIXBUF_LOADER(obj)	   (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GDK_TYPE_PIXBUF_LOADER))
+#define GDK_IS_PIXBUF_LOADER_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), GDK_TYPE_PIXBUF_LOADER))
+
+
+typedef struct _GdkPixbufLoader GdkPixbufLoader;
+struct _GdkPixbufLoader
+{
+	GObject object;
+
+	/* < Private > */
+	gpointer private;
+};
+
+typedef struct _GdkPixbufLoaderClass GdkPixbufLoaderClass;
+struct _GdkPixbufLoaderClass {
+	GObjectClass parent_class;
+};
+
+
+
+GType               gdk_pixbuf_loader_get_type      (void);
+GdkPixbufLoader    *gdk_pixbuf_loader_new           (void);
+gboolean            gdk_pixbuf_loader_write         (GdkPixbufLoader *loader,
+						     const guchar    *buf,
+						     size_t           count);
+GdkPixbuf          *gdk_pixbuf_loader_get_pixbuf    (GdkPixbufLoader *loader);
+GdkPixbufAnimation *gdk_pixbuf_loader_get_animation (GdkPixbufLoader *loader);
+void                gdk_pixbuf_loader_close         (GdkPixbufLoader *loader);
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
