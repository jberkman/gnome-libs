Index: .cvsignore
===================================================================
RCS file: /cvs/gnome/gconf/.cvsignore,v
retrieving revision 1.6
diff -u -u -p -r1.6 .cvsignore
--- .cvsignore	2000/08/29 21:16:59	1.6
+++ .cvsignore	2001/03/18 18:19:20
@@ -18,5 +18,6 @@ ABOUT-NLS
 intl
 config.h.in
 gconf-config
+gconf-2.0.pc
 gconf.spec
 gconf.m4
Index: ChangeLog
===================================================================
RCS file: /cvs/gnome/gconf/ChangeLog,v
retrieving revision 1.241
diff -u -u -p -r1.241 ChangeLog
--- ChangeLog	2001/03/13 11:02:02	1.241
+++ ChangeLog	2001/03/18 18:19:26
@@ -1,3 +1,38 @@
+2001-03-18  Martin Baulig  <baulig@suse.de>
+
+	* gconf/gthreadpool.[ch]: Removed.
+	* gconf/gconf-glib-private.h: Removed.
+	* gconf/gconf-glib-public.h: Removed.
+
+	* gconf/gconf-client.[ch]: Moved here from wrappers/gtk/
+	and migrated to use GObject.
+
+	* gconf/testgconfclient.c: Moved here from wrappers/gtk/.
+
+	* gconf/gconfmarshal.list: New file.
+
+	* gconf/gconftool.c: Use libxml 2.
+
+	* backends/xml-backend.c, backends/xml-cache.h,
+	backends/xml-dir.c, backends/xml-dir.h,
+	backends/xml-entry.c, backends/xml-entry.h: Use libxml 2.
+
+	* wrappers/gtk/*: Moved to gconf/.
+
+2001-03-18  Martin Baulig  <baulig@suse.de>
+
+	Use build setup for the GNOME 2.0 platform.
+
+	* autogen.sh: Use gnome-common and the GNOME 2.0 setup.
+
+	* configure.in: Set MAJOR_VERSION to 2, use pkg-config to
+	check for stuff; GTK+ is now optional and only used for
+	the examples.
+
+	* Makefile.am: Install gconf-2.0.pc.
+
+	* gconf-2.0.pc.in: New file.
+
 2001-03-13  Kjartan Maraas  <kmaraas@gnome.org>
 
 	* backends/xml-entry.c: Merge from branch. Use xmlFree().
Index: Makefile.am
===================================================================
RCS file: /cvs/gnome/gconf/Makefile.am,v
retrieving revision 1.20
diff -u -u -p -r1.20 Makefile.am
--- Makefile.am	2001/03/12 01:08:18	1.20
+++ Makefile.am	2001/03/18 18:19:26
@@ -2,7 +2,8 @@
 SUBDIRS = gconf backends wrappers po doc examples standard-schemas
 DIST_SUBDIRS=tests $(SUBDIRS)
 
-EXTRA_DIST=gconf-config.in gconf.m4.in gconf.spec.in gconf.spec TODO
+EXTRA_DIST=gconf-config.in gconf.m4.in gconf.spec.in gconf.spec TODO \
+	   gconf-2.0.pc.in
 
 WARNING_MESSAGE="If this is your first install of GConf, you may need to move $(prefix)/etc/gconf/$(MAJOR_VERSION)/path.example to $(prefix)/etc/gconf/$(MAJOR_VERSION)/path, so that the default configuration is sane. If you are already using GConf, you may need to move your old configuration into place if $(MAJOR_VERSION) is not the same as your old version."
 
@@ -24,6 +25,9 @@ install-data-local:
 	@echo "**** NOTE ****"
 	@echo $(WARNING_MESSAGE)
 	@echo "**************"
+
+pkgconfigdir = $(libdir)/pkgconfig
+pkgconfig_DATA = gconf-2.0.pc
 
 install-schemas:
 	(cd standard-schemas && $(MAKE) $(AM_MAKEFLAGS) install-schemas)
Index: autogen.sh
===================================================================
RCS file: /cvs/gnome/gconf/autogen.sh,v
retrieving revision 1.5
diff -u -u -p -r1.5 autogen.sh
--- autogen.sh	1999/11/19 17:38:12	1.5
+++ autogen.sh	2001/03/18 18:19:27
@@ -4,132 +4,11 @@
 srcdir=`dirname $0`
 test -z "$srcdir" && srcdir=.
 
-ORIGDIR=`pwd`
-cd $srcdir
 PROJECT=GConf
-TEST_TYPE=-f
-FILE=gconf/gconf.h
 
-DIE=0
-
-(autoconf --version) < /dev/null > /dev/null 2>&1 || {
-	echo
-	echo "You must have autoconf installed to compile $PROJECT."
-	echo "Download the appropriate package for your distribution,"
-	echo "or get the source tarball at ftp://ftp.gnu.org/pub/gnu/"
-	DIE=1
-}
-
-(automake --version) < /dev/null > /dev/null 2>&1 || {
-	echo
-	echo "You must have automake installed to compile $PROJECT."
-	echo "Get ftp://sourceware.cygnus.com/pub/automake/automake-1.4.tar.gz"
-	echo "(or a newer version if it is available)"
-	DIE=1
-}
-
-(grep "^AM_PROG_LIBTOOL" configure.in >/dev/null) && {
-  (libtool --version) < /dev/null > /dev/null 2>&1 || {
-    echo
-    echo "**Error**: You must have \`libtool' installed to compile $PROJECT."
-    echo "Get ftp://ftp.gnu.org/pub/gnu/libtool-1.2d.tar.gz"
-    echo "(or a newer version if it is available)"
-    DIE=1
-  }
-}
-
-grep "^AM_GNU_GETTEXT" configure.in >/dev/null && {
-  grep "sed.*POTFILES" $srcdir/configure.in >/dev/null || \
-  (gettext --version) < /dev/null > /dev/null 2>&1 || {
-    echo
-    echo "**Error**: You must have \`gettext' installed to compile $PROJECT."
-    echo "Get ftp://alpha.gnu.org/gnu/gettext-0.10.35.tar.gz"
-    echo "(or a newer version if it is available)"
-    DIE=1
-  }
-}
-
-if test "$DIE" -eq 1; then
-	exit 1
-fi
-
-test $TEST_TYPE $FILE || {
+(test -f gconf/gconf.h) || {
 	echo "You must run this script in the top-level $PROJECT directory"
 	exit 1
 }
-
-if test -z "$*"; then
-	echo "I am going to run ./configure with no arguments - if you wish "
-        echo "to pass any to it, please specify them on the $0 command line."
-fi
-
-case $CC in
-*xlc | *xlc\ * | *lcc | *lcc\ *) am_opt=--include-deps;;
-esac
-
-for coin in `find . -name configure.in -print`
-do 
-  dr=`dirname $coin`
-  if test -f $dr/NO-AUTO-GEN; then
-    echo skipping $dr -- flagged as no auto-gen
-  else
-    echo processing $dr
-    macrodirs=`sed -n -e 's,AM_ACLOCAL_INCLUDE(\(.*\)),\1,gp' < $coin`
-    ( cd $dr
-      aclocalinclude="$ACLOCAL_FLAGS"
-      for k in $macrodirs; do
-  	if test -d $k; then
-          aclocalinclude="$aclocalinclude -I $k"
-  	##else 
-	##  echo "**Warning**: No such directory \`$k'.  Ignored."
-        fi
-      done
-      if grep "^AM_GNU_GETTEXT" configure.in >/dev/null; then
-	if grep "sed.*POTFILES" configure.in >/dev/null; then
-	  : do nothing -- we still have an old unmodified configure.in
-	else
-	  echo "Creating $dr/aclocal.m4 ..."
-	  test -r $dr/aclocal.m4 || touch $dr/aclocal.m4
-	  echo "Running gettextize...  Ignore non-fatal messages."
-	  echo "no" | gettextize --force --copy
-	  echo "Making $dr/aclocal.m4 writable ..."
-	  test -r $dr/aclocal.m4 && chmod u+w $dr/aclocal.m4
-        fi
-      fi
-      if grep "^AM_GNOME_GETTEXT" configure.in >/dev/null; then
-	echo "Creating $dr/aclocal.m4 ..."
-	test -r $dr/aclocal.m4 || touch $dr/aclocal.m4
-	echo "Running gettextize...  Ignore non-fatal messages."
-	echo "no" | gettextize --force --copy
-	echo "Making $dr/aclocal.m4 writable ..."
-	test -r $dr/aclocal.m4 && chmod u+w $dr/aclocal.m4
-      fi
-      if grep "^AM_PROG_LIBTOOL" configure.in >/dev/null; then
-	echo "Running libtoolize..."
-	libtoolize --force --copy
-      fi
-      echo "Running aclocal $aclocalinclude ..."
-      aclocal $aclocalinclude
-      if grep "^AM_CONFIG_HEADER" configure.in >/dev/null; then
-	echo "Running autoheader..."
-	autoheader
-      fi
-      echo "Running automake --gnu $am_opt ..."
-      automake --add-missing --gnu $am_opt
-      echo "Running autoconf ..."
-      autoconf
-    )
-  fi
-done
-
-conf_flags="--enable-maintainer-mode --enable-compile-warnings" #--enable-iso-c
-
-cd "$ORIGDIR"
 
-if test x$NOCONFIGURE = x; then
-  echo Running $srcdir/configure $conf_flags "$@" ...
-  $srcdir/configure $conf_flags "$@" \
-  && echo Now type \`make\' to compile $PROJECT  || exit 1
-else
-  echo Skipping configure process.
-fi
+USE_GNOME2_MACROS=1 . gnome-autogen.sh
Index: configure.in
===================================================================
RCS file: /cvs/gnome/gconf/configure.in,v
retrieving revision 1.70
diff -u -u -p -r1.70 configure.in
--- configure.in	2001/03/15 11:01:05	1.70
+++ configure.in	2001/03/18 18:19:27
@@ -39,7 +39,7 @@ changequote([,])dnl
 
 dnl used to rename everything and support simultaneous installs.
 dnl not incremented for bugfix or unstable releases.
-MAJOR_VERSION=1
+MAJOR_VERSION=2
 AC_SUBST(MAJOR_VERSION)
 
 GETTEXT_PACKAGE=gconf$MAJOR_VERSION
@@ -56,16 +56,6 @@ AC_SUBST(SCMGCONF_CURRENT)
 AC_SUBST(SCMGCONF_REVISION)
 AC_SUBST(SCMGCONF_AGE)
 
-dnl libtool versioning for GConfClient wrapper
-
-GCONFGTK_CURRENT=1
-GCONFGTK_REVISION=0
-GCONFGTK_AGE=0
-
-AC_SUBST(GCONFGTK_CURRENT)
-AC_SUBST(GCONFGTK_REVISION)
-AC_SUBST(GCONFGTK_AGE)
-
 dnl libtool versioning for libgconf
 
 dnl increment if the interface has additions, changes, removals.
@@ -137,24 +127,27 @@ if test "x$docs_only" = "xyes"; then
         AC_FYI("Only building documentation")
 else
 
-AM_PATH_GLIB(1.2.0,,AC_MSG_ERROR(glib not found or too old),gmodule)
-AM_PATH_OAF(0.2.0,,AC_MSG_ERROR([OAF not found or too old]))
-AM_PATH_GTK(1.2.0,,HAVE_GTK=no)
+GNOME_COMMON_INIT
+GNOME_PLATFORM_GNOME_2(yes, force)
 
-AM_CONDITIONAL(GTK, test x$HAVE_GTK != xno)
-
-AC_PATH_PROG(XML_CONFIG,xml-config,no)
-if test x$XML_CONFIG = xno; then
-  AC_MSG_ERROR(Couldn't find xml-config need to install libxml)
-fi
-XML_LIBS=`$XML_CONFIG --libs`
-XML_CFLAGS=`$XML_CONFIG --cflags`
-if test "x$XML_LIBS" = x; then
-  AC_MSG_ERROR(Failed to get link flags for libxml)
-fi
+GNOME_PKGCONFIG_CHECK_MODULES(GLIB, gmodule-2.0:1.3.1 gobject-2.0:1.3.1)
+GNOME_PKGCONFIG_CHECK_OPTIONAL_MODULES(GTK, gtk+-2.0:1.3.1)
+GNOME_PKGCONFIG_CHECK_MODULES(OAF, oaf-2.0)
+GNOME_PKGCONFIG_CHECK_MODULES(XML, libxml-2.0:2.2.8)
+AC_PATH_PROG(OAF_CONFIG, oaf-config)
+AC_SUBST(OAF_CONFIG)
+AC_SUBST(GLIB_LIBS)
+AC_SUBST(GLIB_CFLAGS)
+AC_SUBST(OAF_LIBS)
+AC_SUBST(OAF_CFLAGS)
+AC_SUBST(GTK_LIBS)
+AC_SUBST(GTK_CFLAGS)
 AC_SUBST(XML_LIBS)
 AC_SUBST(XML_CFLAGS)
 
+AM_CONDITIONAL(GTK, test x$HAVE_GTK != xno)
+
+
 BDB_LIBS=
 BDB_CFLAGS=
 
@@ -212,7 +205,7 @@ fi # docs_only
 
 ALL_LINGUAS="az ca cs da de el es fi fr ga hu it ja ko nl no pt_BR ru sk sl sv tr uk"
 
-AM_GCONF_GNU_GETTEXT
+AM_GNOME2_GETTEXT
 
 # AM_GNU_GETTEXT above substs $DATADIRNAME
 # this is the directory where the *.{mo,gmo} files are installed
@@ -227,6 +220,34 @@ AC_SUBST(LDFLAGS)
 absolute_top_srcdir=`pwd`
 AC_SUBST(absolute_top_srcdir)
 
+# define a MAINT-like variable REBUILD which is set if Perl
+# and awk are found, so autogenerated sources can be rebuilt
+
+AC_PROG_AWK
+AC_CHECK_PROGS(PERL, perl5 perl)
+
+# We would like indent, but don't require it.
+AC_CHECK_PROG(INDENT, indent, indent)
+
+_found_perl=0
+if test -n "$PERL" && $PERL -v | grep 'version 5.' > /dev/null ; then
+  _found_perl=1
+else
+  # The version string for perl changed for 'version 5' to 'v5' in
+  # perl 5.6 or therabouts
+  if test -n "$PERL" && $PERL -v | grep 'v5.' > /dev/null ; then
+    _found_perl=1
+  fi
+fi
+
+REBUILD=\#
+if test $_found_perl -eq 1; then
+  if test -n "$AWK" ; then 
+    REBUILD=
+  fi
+fi
+AC_SUBST(REBUILD)
+
 AC_OUTPUT([
 Makefile
 gconf-config
@@ -237,14 +258,12 @@ gconf/default.path
 gconf/gconfd.oafinfo
 backends/Makefile
 wrappers/Makefile
-wrappers/gtk/Makefile
 po/Makefile.in
 doc/Makefile
 doc/gconf/Makefile
 examples/Makefile
 tests/Makefile
 standard-schemas/Makefile
+gconf-2.0.pc
 ],
 chmod +x gconf-config)
-
-
Index: gconf-2.0.pc.in
===================================================================
RCS file: gconf-2.0.pc.in
diff -N gconf-2.0.pc.in
--- /dev/null	Tue May  5 16:32:27 1998
+++ gconf-2.0.pc.in	Sun Mar 18 13:19:27 2001
@@ -0,0 +1,12 @@
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+libdir=@libdir@
+includedir=@includedir@
+
+
+Name: gconf
+Description: GNOME Config System.
+Version: @VERSION@
+Requires: oaf-2.0
+Libs: -L${libdir} -lgconf-@MAJOR_VERSION@
+Cflags: -I${includedir}/gconf/@MAJOR_VERSION@
Index: backends/gthreadpool.c
===================================================================
RCS file: gthreadpool.c
diff -N gthreadpool.c
--- /tmp/cvsUGTmqv	Sun Mar 18 13:19:37 2001
+++ /dev/null	Tue May  5 16:32:27 1998
@@ -1,435 +0,0 @@
-/* GConf
- * Copyright (C) 1999, 2000 Red Hat Inc.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-
-#include "gthreadpool.h"
-#include <pthread.h>
-
-typedef struct _Task Task;
-
-struct _Task {
-  GWorkerFunc work_func;
-  GWorkFinishedNotifyFunc notify_func;
-  gpointer data;
-  gpointer result;
-}
-
-typedef struct _GThreadPoolPrivate GThreadPoolPrivate;
-
-typedef struct _WorkerThread WorkerThread;
-
-struct _WorkerThread {
-  Task* task;
-  pthread_t thread;
-  GThreadPoolPrivate* pool;
-  gboolean destroyed;
-};
-
-struct _GThreadPoolPrivate {
-  guint max_threads;
-  guint thread_count;
-  GSList* threads;
-
-  pthread_mutex_t worker_mutex;
-  pthread_cond_t worker_cond;
-  pthread_cond_t empty_incoming_cond;
-  guint incoming_task_count;
-  GSList* incoming_tasks;
-  guint busy_task_count;
-  GSList* busy_tasks;
-  guint finished_task_count;
-  GSList* finished_tasks;
-
-  guint notify_pipe_io_watcher_id;
-  int notify_pipe[2];
-  GIOChannel* notify_channel;
-}
-
-static void*
-do_worker_thread(void* _wt)
-{
-  WorkerThread* wt = (WorkerThread*)_wt;
-
-  while (TRUE)
-    {
-      /* Wait until there are incoming tasks or we should
-         exit */
-      pthread_mutex_lock(&(wt->pool->worker_mutex));
-
-      while (wt->pool->incoming_task_count == 0 &&
-             (!wt->destroyed))
-        {
-          pthread_cond_wait(&(wt->pool->worker_cond),
-                            &(wt->pool->worker_mutex));
-        }
-
-      /* Exit if requested */
-      if (wt->destroyed)
-        {
-          pthread_mutex_unlock(&(wt->pool->worker_mutex));
-          pthread_exit(NULL);
-          return NULL; /* not reached */
-        }
-
-      /* Otherwise, take the first incoming task */
-      
-      g_assert(wt->pool->incoming_task_count > 0);
-
-      wt->pool->incoming_task_count -= 1;
-      wt->task = wt->pool->incoming_tasks->data;
-      wt->pool->incoming_tasks = g_slist_remove(wt->pool->incoming_tasks,
-                                                wt->task);
-
-      g_assert(wt->task != NULL);
-
-      wt->pool->busy_task_count += 1;
-      wt->pool->busy_tasks = g_slist_prepend(wt->pool->busy_tasks,
-                                             wt->task);
-
-      pthread_mutex_unlock(&(wt->pool->worker_mutex));
-
-      /* Perform the task; we release the lock,
-       * so other threads can get started or stopped, and also
-       * so conceivably the task can add more tasks to the pool
-       * (however that sounds like it could be a bad idea...)
-       */
-      
-      wt->task->result = (*wt->task->work_func)(wt->task->data);
-
-      /* Move the task onto the finished list */
-      
-      pthread_mutex_lock(&(wt->pool->worker_mutex));
-
-      g_assert(wt->pool->busy_task_count > 0);
-      
-      wt->pool->busy_task_count -= 1;
-      wt->pool->busy_tasks = g_slist_remove(wt->pool->busy_tasks,
-                                            wt->task);
-
-      wt->pool->finished_task_count += 1;
-      wt->pool->finished_tasks = g_slist_prepend(wt->pool->finished_tasks,
-                                                 wt->task);
-
-      /* Forget about our task */
-      wt->task = NULL;
-
-      /* Notify the glib main loop (via an input handler on this pipe)
-       * that there are finished tasks
-       */
-
-    try_again:
-      if (write(wt->pool->notify_pipe[1], "g", 1) < 0)
-        {
-          if (errno == EINTR)
-            goto try_again;
-          else
-            g_warning("Write failure with pipe notification: %s", strerror(errno)); /* shouldn't happen */
-        }
-      
-      /* Notify main thread (g_thread_pool_destroy()) if
-       * we emptied the queue
-       */
-
-      if (wt->pool->incoming_task_count == 0)
-        pthread_cond_signal(&(wt->pool->empty_incoming_cond));
-      
-      pthread_mutex_unlock(&(wt->pool->worker_mutex));
-
-      /* Continue forever */
-    }
-}
-
-/* These should be called from the main thread */
-
-static WorkerThread*
-worker_thread_new(void)
-{
-  int rtn;
-  WorkerThread* wt;
-
-  wt = g_new0(WorkerThread, 1);
-
-  wt->task = NULL;
-  wt->destroyed = FALSE;
-  
-  rtn = pthread_create(&wt->thread, NULL, do_worker_thread, wt);
-
-  if (rtn != 0)
-    {
-      fprintf(stderr, "Failed to create thread: %s\n", strerror(rtn));
-      g_free(wt);
-      return NULL;
-    }
-
-  return wt;
-}
-
-static void
-worker_thread_destroy(WorkerThread* wt)
-{
-  pthread_join(wt->thread, NULL);
-  g_free(wt);
-}
-
-/* note that this function doesn't do locking */
-static void
-g_thread_pool_notify(GThreadPool* pool)
-{
-  GThreadPoolPrivate* priv = (GThreadPoolPrivate*)pool;
-  GSList* tmp;
-  
-  tmp = priv->finished_tasks;
-  while (tmp != NULL)
-    {
-      Task* task = tmp->data;
-
-      (*task->notify_func)(task->result);
-
-      g_free(task);
-      
-      tmp = g_slist_next(tmp);
-    }
-
-  g_slist_free(priv->finished_tasks);
-  priv->finished_task_count = 0;
-  priv->finished_tasks = NULL;
-}
-
-gboolean
-notify_callback (GIOChannel *source,
-                 GIOCondition condition,
-                 gpointer data)
-{
-  GThreadPoolPrivate* priv = data;
-  guint count;
-  gchar* buf;
-  
-  pthread_mutex_lock(&(wt->pool->worker_mutex));
-
-  count = priv->finished_task_count;
-
-  if (count == 0)
-    {
-      g_warning("Strange, we got a notify callback with no finished tasks");
-      pthread_mutex_unlock(&(wt->pool->worker_mutex));
-      return;
-    }
-  
-  g_thread_pool_notify((GThreadPool*)priv);
-
-  g_assert(priv->finished_task_count == 0 &&
-           priv->finished_tasks == NULL);
-
-  /* read notify bytes from the pipe */
-
-  buf = g_malloc(count);
- again:
-  if (read(priv->notify_pipe[0], buf, count) < 0)
-    {
-      if (errno == EINTR)
-        goto again;
-      else
-        {
-          /* shouldn't happen */
-          g_warning("Read failed from notify pipe: %s", strerror(errno));
-        }
-    }
-  /* discard the bytes */
-  g_free(buf);
-  
-  pthread_mutex_unlock(&(wt->pool->worker_mutex));
-}
-
-GThreadPool*
-g_thread_pool_new      (guint max_threads)
-{
-  GThreadPoolPrivate* priv;
-  int ret;
-
-  g_return_val_if_fail(max_threads > 0, NULL);
-  
-  priv = g_new0(GThreadPoolPrivate, 1);
-
-  priv->max_threads = max_threads;
-
-  if (pipe(priv->notify_pipe) < 0)
-    {
-      g_free(priv);
-      return NULL;
-    }
-  
-  ret = pthread_cond_init(&(priv->worker_cond));
-  if (ret != 0)
-    {
-      fprintf(stderr, "Failed to init pthread_cond: %s",
-              strerror(ret));
-      exit(1);
-    }
-
-  ret = pthread_cond_init(&(priv->empty_incoming_cond));
-  if (ret != 0)
-    {
-      fprintf(stderr, "Failed to init pthread_cond: %s",
-              strerror(ret));
-      exit(1);
-    }
-  
-  ret = pthread_mutex_init(&(priv->worker_mutex));
-  if (ret != 0)
-    {
-      fprintf(stderr, "Failed to init pthread_mutex: %s",
-              strerror(ret));
-      exit(1);
-    }
-
-  priv->notify_channel = g_io_channel_unix_new(priv->notify_pipe[0]);
-  
-  priv->notify_pipe_io_watcher_id = g_io_add_watch(priv->notify_channel,
-                                                   G_IO_IN,
-                                                   notify_callback,
-                                                   priv);
-  
-  return (GThreadPool*)priv;
-}
-
-void
-g_thread_pool_destroy  (GThreadPool* pool)
-{
-  GThreadPoolPrivate* priv = (GThreadPoolPrivate*)pool;
-  GSList* tmp;
-  
-  pthread_mutex_lock(&(priv->worker_mutex));
-
-  /* Remove the notify event source */
-  g_source_remove(priv->work_notify_source_id);
-
-  /* close the pipe */
-  close(priv->notify_pipe[0]);
-  close(priv->notify_pipe[1]);
-  
-  /* Clear the queue */
-  while (priv->incoming_task_count != 0)
-    {
-      g_assert(priv->thread_count > 0);
-
-      pthread_cond_wait(&(priv->empty_incoming_cond),
-                        &(priv->worker_mutex));
-    }
-
-  g_assert(priv->incoming_task_count == 0);
-
-  /* Now do notification if any tasks were just finished */
-
-  g_thread_pool_notify(pool);
-  
-  /* Mark all worker threads destroyed */
-
-  tmp = priv->threads;
-  while (tmp != NULL)
-    {
-      WorkerThread* wt = tmp->data;
-
-      g_assert(wt->task == NULL);
-      
-      wt->destroyed = TRUE;
-
-      tmp = g_slist_next(tmp);
-    }
-
-  /* Wake up all threads so they notice they are destroyed and exit */
-  pthread_cond_broadcast(&(priv->worker_cond));
-  pthread_mutex_unlock(&(priv->worker_mutex));
-  
-  /* Now delete all the threads */
-  tmp = priv->threads;
-  while (tmp != NULL)
-    {
-      WorkerThread* wt = tmp->data;
-
-      worker_thread_destroy(wt);
-      
-      tmp = g_slist_next(tmp);
-    }
-
-  g_slist_free(priv->threads);
-  priv->threads = NULL;
-  priv->thread_count = 0;
-
-  g_free(priv);
-}
-
-void
-g_thread_pool_finish_all   (GThreadPool* pool)
-{
-  GThreadPoolPrivate* priv = (GThreadPoolPrivate*)pool;
-  
-  pthread_mutex_lock(&(priv->worker_mutex));
-  
-  /* Clear the queue */
-  while (priv->incoming_task_count != 0)
-    {
-      g_assert(priv->thread_count > 0);
-
-      pthread_cond_wait(&(priv->empty_incoming_cond),
-                        &(priv->worker_mutex));
-    }
-
-  g_assert(priv->incoming_task_count == 0);
-
-  pthread_mutex_unlock(&(priv->worker_mutex));
-}
-
-void
-g_thread_pool_do_work  (GThreadPool* pool,
-                        GWorkerFunc work_func,
-                        gpointer data)
-{
-  GThreadPoolPrivate* priv = (GThreadPoolPrivate*)pool;
-  Task* task;
-
-  task = g_new0(Task, 1);
-
-  task->work_func = work_func;
-  task->notify_func = notify_func;
-  task->data = data;
-
-  pthread_mutex_lock(&(priv->worker_mutex));
-
-  priv->incoming_task_count += 1;
-  priv->incoming_tasks = g_slist_prepend(priv->incoming_tasks,
-                                         task);
-
-  if ((priv->thread_count < priv->max_threads) && 
-      ((priv->busy_task_count + priv->incoming_task_count) > priv->thread_count))
-    {
-      /* Add another worker thread */
-      WorkerThread* wt = worker_thread_new();
-
-      priv->threads = g_slist_prepend(priv->threads, wt);
-      priv->thread_count += 1;
-    }
-
-  /* Wake up one of the waiting threads */
-  pthread_cond_signal(&(priv->worker_cond));
-  
-  pthread_mutex_unlock(&(priv->worker_mutex));
-}
-
-
-
Index: backends/gthreadpool.h
===================================================================
RCS file: gthreadpool.h
diff -N gthreadpool.h
--- /tmp/cvsO9VByy	Sun Mar 18 13:19:37 2001
+++ /dev/null	Tue May  5 16:32:27 1998
@@ -1,66 +0,0 @@
-/* GConf
- * Copyright (C) 1999, 2000 Red Hat Inc.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#ifndef GCONF_GTHREADPOOL_H
-#define GCONF_GTHREADPOOL_H
-
-#include <glib.h>
-/*
-  #ifdef __cplusplus
-  extern "C" {
-  #endif
-*/
-
-typedef struct _GThreadPool GThreadPool;
-
-struct _GThreadPool {
-  gpointer dummy;
-}
-
-/* this can return NULL on failure and sets errno */
-GThreadPool* g_thread_pool_new          (guint max_threads);
-/* block until all tasks are finished, then return. */
-void         g_thread_pool_finish_all   (GThreadPool* pool);
-void         g_thread_pool_destroy      (GThreadPool* pool);
-
-typedef gpointer (*GWorkerFunc)             (gpointer data);
-typedef void     (*GWorkFinishedNotifyFunc) (gpointer result);
-
-/* Your work func should obviously be thread safe :-) */
-/* The return value of the worker func invocation is passed to the
- * GWorkFinishedNotifyFunc to tell you there are results.
- * GWorkFinishedNotifyFunc is a called from a glib main loop source,
- * so you need to be using the glib main loop to use GThreadPool
- */
-   
-void         g_thread_pool_do_work  (GThreadPool* pool,
-                                     GWorkerFunc work_func,
-                                     GWorkFinishedNotifyFunc notify_func,
-                                     gpointer data);
-
-/*
-  #ifdef __cplusplus
-  }
-  #endif
-*/
-
-#endif
-
-
-
Index: backends/xml-backend.c
===================================================================
RCS file: /cvs/gnome/gconf/backends/xml-backend.c,v
retrieving revision 1.73
diff -u -u -p -r1.73 xml-backend.c
--- backends/xml-backend.c	2000/09/25 03:10:15	1.73
+++ backends/xml-backend.c	2001/03/18 18:19:27
@@ -26,8 +26,8 @@
 #include "xml-cache.h"
 
 
-#include <gnome-xml/tree.h>
-#include <gnome-xml/parser.h>
+#include <libxml/tree.h>
+#include <libxml/parser.h>
 
 #include <stdio.h>
 #include <time.h>
@@ -678,6 +678,9 @@ G_MODULE_EXPORT const gchar*
 g_module_check_init (GModule *module)
 {
   gconf_log(GCL_INFO, _("Initializing XML backend module"));
+
+  LIBXML_TEST_VERSION;
+  xmlKeepBlanksDefault(1);
 
   return NULL;
 }
Index: backends/xml-cache.h
===================================================================
RCS file: /cvs/gnome/gconf/backends/xml-cache.h,v
retrieving revision 1.5
diff -u -u -p -r1.5 xml-cache.h
--- backends/xml-cache.h	2000/08/31 21:25:04	1.5
+++ backends/xml-cache.h	2001/03/18 18:19:27
@@ -21,7 +21,7 @@
 #define GCONF_XML_CACHE_H
 
 #include <gconf/gconf.h>
-#include <gnome-xml/tree.h>
+#include <libxml/tree.h>
 #include "xml-dir.h"
 
 typedef struct _Cache Cache;
Index: backends/xml-dir.c
===================================================================
RCS file: /cvs/gnome/gconf/backends/xml-dir.c,v
retrieving revision 1.18
diff -u -u -p -r1.18 xml-dir.c
--- backends/xml-dir.c	2001/02/05 21:17:52	1.18
+++ backends/xml-dir.c	2001/03/18 18:19:28
@@ -20,7 +20,7 @@
 #include "xml-dir.h"
 #include "xml-entry.h"
 
-#include <gnome-xml/parser.h>
+#include <libxml/parser.h>
 
 #include <stdio.h>
 #include <time.h>
@@ -838,16 +838,16 @@ dir_load_doc(Dir* d, GError** err)
       d->doc = xmlNewDoc("1.0");
     }
   
-  if (d->doc->root == NULL)
+  if (d->doc->xmlRootNode == NULL)
     {
       /* fill it in */
-      d->doc->root = xmlNewDocNode(d->doc, NULL, "gconf", NULL);
+      d->doc->xmlRootNode = xmlNewDocNode(d->doc, NULL, "gconf", NULL);
     }
-  else if (strcmp(d->doc->root->name, "gconf") != 0)
+  else if (strcmp(d->doc->xmlRootNode->name, "gconf") != 0)
     {
       xmlFreeDoc(d->doc);
       d->doc = xmlNewDoc("1.0");
-      d->doc->root = xmlNewDocNode(d->doc, NULL, "gconf", NULL);
+      d->doc->xmlRootNode = xmlNewDocNode(d->doc, NULL, "gconf", NULL);
       need_backup = TRUE; /* save broken stuff */
     }
   else
@@ -880,7 +880,7 @@ dir_load_doc(Dir* d, GError** err)
     }
   
   g_assert(d->doc != NULL);
-  g_assert(d->doc->root != NULL);
+  g_assert(d->doc->xmlRootNode != NULL);
 }
 
 static Entry*
@@ -889,11 +889,11 @@ dir_make_new_entry(Dir* d, const gchar* 
   Entry* e;
 
   g_return_val_if_fail(d->doc != NULL, NULL);
-  g_return_val_if_fail(d->doc->root != NULL, NULL);
+  g_return_val_if_fail(d->doc->xmlRootNode != NULL, NULL);
   
   e = entry_new(relative_key);
 
-  entry_set_node(e, xmlNewChild(d->doc->root, NULL, "entry", NULL));
+  entry_set_node(e, xmlNewChild(d->doc->xmlRootNode, NULL, "entry", NULL));
   
   safe_g_hash_table_insert(d->entry_cache, (gchar*)entry_get_name(e), e);
   
@@ -926,14 +926,14 @@ dir_fill_cache_from_doc(Dir* d)
   xmlNodePtr node;
   
   if (d->doc == NULL ||
-      d->doc->root == NULL ||
-      d->doc->root->childs == NULL)
+      d->doc->xmlRootNode == NULL ||
+      d->doc->xmlRootNode->xmlChildrenNode == NULL)
     {
       /* Empty document - just return. */
       return;
     }
 
-  node = d->doc->root->childs;
+  node = d->doc->xmlRootNode->xmlChildrenNode;
 
   while (node != NULL)
     {
Index: backends/xml-dir.h
===================================================================
RCS file: /cvs/gnome/gconf/backends/xml-dir.h,v
retrieving revision 1.6
diff -u -u -p -r1.6 xml-dir.h
--- backends/xml-dir.h	2000/08/31 21:25:04	1.6
+++ backends/xml-dir.h	2001/03/18 18:19:28
@@ -21,7 +21,7 @@
 #define GCONF_XML_DIR_H
 
 #include <gconf/gconf.h>
-#include <gnome-xml/tree.h>
+#include <libxml/tree.h>
 
 /* Dir stores the information about a given directory */
 
Index: backends/xml-entry.c
===================================================================
RCS file: /cvs/gnome/gconf/backends/xml-entry.c,v
retrieving revision 1.21
diff -u -u -p -r1.21 xml-entry.c
--- backends/xml-entry.c	2001/03/13 11:02:03	1.21
+++ backends/xml-entry.c	2001/03/18 18:19:29
@@ -20,8 +20,8 @@
 #include "xml-entry.h"
 #include <gconf/gconf-internals.h>
 #include <stdlib.h>
-#include <gnome-xml/entities.h>
-#include <gnome-xml/xmlmemory.h>
+#include <libxml/entities.h>
+#include <libxml/xmlmemory.h>
 
 static void
 entry_sync_if_needed(Entry* e, GConfValue* val);
@@ -384,9 +384,9 @@ free_childs(xmlNodePtr node)
 {
   g_return_if_fail(node != NULL);
   
-  if (node->childs)
-    xmlFreeNodeList(node->childs);
-  node->childs = NULL;
+  if (node->xmlChildrenNode)
+    xmlFreeNodeList(node->xmlChildrenNode);
+  node->xmlChildrenNode = NULL;
   node->last = NULL;
 }
 
@@ -605,7 +605,7 @@ find_schema_subnode_by_locale(xmlNodePtr
   xmlNodePtr iter;
   xmlNodePtr found = NULL;
     
-  iter = node->childs;
+  iter = node->xmlChildrenNode;
       
   while (iter != NULL)
     {
@@ -701,12 +701,12 @@ schema_subnode_extract_data(xmlNodePtr n
       gconf_log(GCL_DEBUG, "found <local_schema> with no locale setting");
     }
   
-  if (node->childs != NULL)
+  if (node->xmlChildrenNode != NULL)
     {
       GConfValue* default_value = NULL;
       gchar* ld_str = NULL;
       GSList* bad_nodes = NULL;
-      xmlNodePtr iter = node->childs;
+      xmlNodePtr iter = node->xmlChildrenNode;
 
       while (iter != NULL)
         {
@@ -844,7 +844,7 @@ schema_node_extract_value(xmlNodePtr nod
       localized_nodes = g_new0(xmlNodePtr, i+2);
       
       /* Find the node for each possible locale */
-      iter = node->childs;
+      iter = node->xmlChildrenNode;
       
       while (iter != NULL)
         {
@@ -900,7 +900,7 @@ schema_node_extract_value(xmlNodePtr nod
     best = find_schema_subnode_by_locale (node, NULL);
 
   if (best == NULL)
-    best = node->childs;
+    best = node->xmlChildrenNode;
   
   /* Extract info from the best locale node */
   if (best != NULL)
@@ -984,7 +984,7 @@ node_extract_value(xmlNodePtr node, cons
       {
         xmlNodePtr iter;
         
-        iter = node->childs;
+        iter = node->xmlChildrenNode;
 
         while (iter != NULL)
           {
@@ -1053,7 +1053,7 @@ node_extract_value(xmlNodePtr node, cons
             break;
           }
         
-        iter = node->childs;
+        iter = node->xmlChildrenNode;
 
         while (iter != NULL)
           {
@@ -1115,7 +1115,7 @@ node_extract_value(xmlNodePtr node, cons
         GConfValue* cdr = NULL;
         xmlNodePtr iter;
         
-        iter = node->childs;
+        iter = node->xmlChildrenNode;
 
         while (iter != NULL)
           {
Index: backends/xml-entry.h
===================================================================
RCS file: /cvs/gnome/gconf/backends/xml-entry.h,v
retrieving revision 1.5
diff -u -u -p -r1.5 xml-entry.h
--- backends/xml-entry.h	2000/08/31 21:25:04	1.5
+++ backends/xml-entry.h	2001/03/18 18:19:29
@@ -21,7 +21,7 @@
 #define GCONF_XML_ENTRY_H
 
 #include <gconf/gconf.h>
-#include <gnome-xml/tree.h>
+#include <libxml/tree.h>
 
 /* Entry stores all the information about a given key */
 
Index: examples/Makefile.am
===================================================================
RCS file: /cvs/gnome/gconf/examples/Makefile.am,v
retrieving revision 1.6
diff -u -u -p -r1.6 Makefile.am
--- examples/Makefile.am	2000/09/11 21:58:47	1.6
+++ examples/Makefile.am	2001/03/18 18:19:29
@@ -13,7 +13,7 @@ endif
 
 noinst_PROGRAMS=$(GTK_EXAMPLES)
 
-GTK_EXAMPLES_LINK= $(EFENCE) $(INTLLIBS) $(ORBIT_LIBS) $(GTK_LIBS) $(top_builddir)/gconf/libgconf-$(MAJOR_VERSION).la $(top_builddir)/wrappers/gtk/libgconf-gtk-$(MAJOR_VERSION).la $(EFENCE)
+GTK_EXAMPLES_LINK= $(EFENCE) $(INTLLIBS) $(ORBIT_LIBS) $(GTK_LIBS) $(top_builddir)/gconf/libgconf-$(MAJOR_VERSION).la $(EFENCE)
 
 basic_gconf_app_SOURCES = basic-gconf-app.c
 
Index: examples/basic-gconf-app.c
===================================================================
RCS file: /cvs/gnome/gconf/examples/basic-gconf-app.c,v
retrieving revision 1.13
diff -u -u -p -r1.13 basic-gconf-app.c
--- examples/basic-gconf-app.c	2000/09/17 01:57:42	1.13
+++ examples/basic-gconf-app.c	2001/03/18 18:19:30
@@ -85,7 +85,7 @@ main(int argc, char** argv)
   /* This ensures we cleanly detach from the GConf server (assuming
    * we hold the last reference)
    */
-  gtk_object_unref(GTK_OBJECT(client));
+  g_object_unref(G_OBJECT(client));
   
   return 0;
 }
@@ -176,7 +176,7 @@ create_configurable_widget(GConfClient* 
   gtk_object_set_data(GTK_OBJECT(label), "client", client);
 
   gtk_signal_connect(GTK_OBJECT(label), "destroy",
-                     configurable_widget_destroy_callback,
+                     GTK_SIGNAL_FUNC(configurable_widget_destroy_callback),
                      NULL);
   
   return frame;
@@ -502,11 +502,11 @@ create_config_entry(GtkWidget* prefs_dia
   gtk_object_set_data(GTK_OBJECT(entry), "key", g_strdup(config_key));
 
   gtk_signal_connect(GTK_OBJECT(entry), "destroy",
-                     config_entry_destroy_callback,
+                     GTK_SIGNAL_FUNC(config_entry_destroy_callback),
                      NULL);
 
   gtk_signal_connect(GTK_OBJECT(entry), "changed",
-                     config_entry_changed_callback,
+                     GTK_SIGNAL_FUNC(config_entry_changed_callback),
                      prefs_dialog);
 
   /* A dubious hack; set the entry as object data using its
@@ -571,7 +571,7 @@ prefs_dialog_destroy_callback(GtkWidget*
   if (revert_cs)
     gconf_change_set_unref(revert_cs);
 
-  gtk_object_unref(GTK_OBJECT(client));
+  g_object_unref(G_OBJECT(client));
 }
 
 static GtkWidget*
@@ -588,7 +588,7 @@ create_prefs_dialog(GtkWidget* parent, G
   GtkWidget* vbox_inner;
   GtkWidget* entry;
   
-  dialog = gtk_window_new(GTK_WINDOW_DIALOG);
+  dialog = gtk_window_new(GTK_WINDOW_TOPLEVEL);
 
   apply = gtk_button_new_with_label("Apply");
   revert = gtk_button_new_with_label("Revert");
@@ -623,7 +623,7 @@ create_prefs_dialog(GtkWidget* parent, G
   gtk_object_set_data(GTK_OBJECT(dialog), "client", client);
 
   /* Grab a reference */
-  gtk_object_ref(GTK_OBJECT(client));
+  g_object_ref(G_OBJECT(client));
   
   gtk_signal_connect(GTK_OBJECT(dialog), "destroy",
                      GTK_SIGNAL_FUNC(prefs_dialog_destroy_callback),
Index: gconf/.cvsignore
===================================================================
RCS file: /cvs/gnome/gconf/gconf/.cvsignore,v
retrieving revision 1.4
diff -u -u -p -r1.4 .cvsignore
--- gconf/.cvsignore	2000/08/29 21:17:00	1.4
+++ gconf/.cvsignore	2001/03/18 18:19:30
@@ -12,5 +12,8 @@ gconftool
 gconfd
 default.path
 gconfd.oafinfo
-gconfd-1
-gconftool-1
+gconfd-2
+gconftool-2
+gconfmarshal.h
+gconfmarshal.c
+stamp-gconfmarshal.h
Index: gconf/Makefile.am
===================================================================
RCS file: /cvs/gnome/gconf/gconf/Makefile.am,v
retrieving revision 1.54
diff -u -u -p -r1.54 Makefile.am
--- gconf/Makefile.am	2001/02/27 18:27:36	1.54
+++ gconf/Makefile.am	2001/03/18 18:19:30
@@ -7,6 +7,7 @@ INCLUDES=\
 	$(ORBIT_CFLAGS) \
 	$(XML_CFLAGS) \
 	$(OAF_CFLAGS) \
+	$(GTK_CFLAGS) \
 	-DG_LOG_DOMAIN=\"GConf\"                   \
 	-DGCONF_LOCALE_DIR=\""$(gconflocaledir)"\"  \
         -DGCONF_SRCDIR=\""$(absolute_top_srcdir)"\" \
@@ -20,58 +21,67 @@ INCLUDES=\
 
 EFENCE=
 
-lib_LTLIBRARIES = libgconf-1.la
+lib_LTLIBRARIES = libgconf-2.la
 
-bin_PROGRAMS = gconfd-1 gconftool-1
+bin_PROGRAMS = gconfd-2 gconftool-2
 
+if GTK
+GTK_PROGS = testgconfclient
+else
+GTK_PROGS =
+endif
+
+noinst_PROGRAMS = $(GTK_PROGS)
+
 CORBA_SOURCES = GConf-common.c GConf-skels.c GConf-stubs.c GConf.h
 
-BUILT_SOURCES = $(CORBA_SOURCES)
+BUILT_SOURCES = \
+	$(CORBA_SOURCES)	\
+	gconfmarshal.h		\
+	gconfmarshal.c
 
 gconfincludedir = $(includedir)/gconf/$(MAJOR_VERSION)/gconf
-gconfinclude_HEADERS =     \
-	gconf.h            \
+gconfinclude_HEADERS = \
+	gconf.h			\
 	gconf-changeset.h	\
-	gconf-glib-public.h	\
-	gconf-listeners.h  \
-	gconf-schema.h 	   \
-	gconf-value.h	   \
-	gconf-error.h	   \
-	gconf-engine.h
+	gconf-listeners.h	\
+	gconf-schema.h		\
+	gconf-value.h		\
+	gconf-error.h		\
+	gconf-engine.h		\
+	gconf-client.h
 
 ## This is broken I know, I'm going to break the server/client up and have a library later
 
-gconfd_1_SOURCES = \
+gconfd_2_SOURCES = \
 	gconf-database.h	\
 	gconf-database.c	\
 	gconf-sources.h		\
 	gconfd.h		\
 	gconfd.c
 
-gconfd_1_LDADD = $(EFENCE) $(INTLLIBS) $(OAF_LIBS) $(GLIB_LIBS) libgconf-$(MAJOR_VERSION).la
+gconfd_2_LDADD = $(EFENCE) $(INTLLIBS) $(OAF_LIBS) $(GLIB_LIBS) libgconf-$(MAJOR_VERSION).la
 
 # gconf_testclient_SOURCES = \
 # 	testclient.c
 
 # gconf_testclient_LDADD = $(GLIB_LIBS) $(ORBIT_LIBS) libgconf-client.la
 
-gconftool_1_SOURCES = \
+gconftool_2_SOURCES = \
 	gconftool.c
 
-gconftool_1_LDADD = $(EFENCE) $(INTLLIBS) $(OAF_LIBS) $(GLIB_LIBS) $(ORBIT_LIBS) $(POPT_LIBS) $(XML_LIBS) libgconf-$(MAJOR_VERSION).la
+gconftool_2_LDADD = $(EFENCE) $(INTLLIBS) $(OAF_LIBS) $(GLIB_LIBS) $(ORBIT_LIBS) $(POPT_LIBS) $(XML_LIBS) libgconf-$(MAJOR_VERSION).la
 
 $(CORBA_SOURCES): $(srcdir)/GConf.idl
 	orbit-idl $(srcdir)/GConf.idl
 
-libgconf_1_la_SOURCES = \
+libgconf_2_la_SOURCES = \
 	gconf-internals.c	\
 	gconf-internals.h	\
 	gconf-backend.h		\
 	gconf-backend.c		\
 	gconf-changeset.c	\
 	gconf-error.c		\
-	gconf-glib.c		\
-	gconf-glib-private.h	\
 	gconf-listeners.c	\
 	gconf-locale.h  	\
 	gconf-locale.c  	\
@@ -79,13 +89,14 @@ libgconf_1_la_SOURCES = \
 	gconf-sources.c		\
 	gconf-value.c		\
 	gconf.c			\
+	gconf-client.c		\
 	$(CORBA_SOURCES)
 
-libgconf_1_la_LDFLAGS = -version-info $(GCONF_CURRENT):$(GCONF_REVISION):$(GCONF_AGE)
+libgconf_2_la_LDFLAGS = -version-info $(GCONF_CURRENT):$(GCONF_REVISION):$(GCONF_AGE)
 
-libgconf_1_la_LIBADD = $(INTLLIBS) $(OAF_LIBS) $(GLIB_LIBS)
+libgconf_2_la_LIBADD = $(INTLLIBS) $(OAF_LIBS) $(GLIB_LIBS)
 
-EXTRA_DIST=GConf.idl gconfd.oafinfo.in default.path.in
+EXTRA_DIST=GConf.idl gconfd.oafinfo.in default.path.in gconfmarshal.list
 
 install-exec-local:
 	(cd $(DESTDIR)$(bindir) && $(RM) gconftool && $(LN_S) -f gconftool-$(MAJOR_VERSION) gconftool)
@@ -96,3 +107,21 @@ install-data-local:
 	-mkdir -p $(DESTDIR)$(datadir)/oaf
 	$(INSTALL_DATA) gconfd.oafinfo $(DESTDIR)$(datadir)/oaf/gconfd-$(MAJOR_VERSION).oafinfo
 
+stamp-gconfmarshal.h: @REBUILD@ gconfmarshal.list
+	cd $(srcdir) \
+	&& glib-genmarshal --prefix=gconf_marshal gconfmarshal.list --header >> xgen-gmh \
+	&& (cmp -s xgen-gmh gconfmarshal.h || cp xgen-gmh gconfmarshal.h) \
+	&& rm -f xgen-gmh xgen-gmh~ \
+	&& echo timestamp > $(@F)
+
+gconfmarshal.h gconfmarshal.c: @REBUILD@ stamp-gconfmarshal.h
+	cd $(srcdir) \
+	&& glib-genmarshal --prefix=gconf_marshal gconfmarshal.list --body >> xgen-gmc \
+	&& cp xgen-gmc gconfmarshal.c \
+	&& rm -f xgen-gmc xgen-gmc~
+
+testgconfclient_SOURCES = \
+	testgconfclient.c
+
+testgconfclient_LDADD = \
+	libgconf-2.la $(GTK_LIBS)
Index: gconf/gconf-client.c
===================================================================
RCS file: gconf-client.c
diff -N gconf-client.c
--- /dev/null	Tue May  5 16:32:27 1998
+++ gconf-client.c	Sun Mar 18 13:19:31 2001
@@ -0,0 +1,2148 @@
+/* -*- tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* GConf
+ * Copyright (C) 1999, 2000, 2000 Red Hat Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include <stdio.h>
+#include "gconf-client.h"
+#include <gobject/gobject.h>
+#include <gobject/gsignal.h>
+#include <gobject/gvaluetypes.h>
+#include <gconf/gconf-internals.h>
+
+#include "gconfmarshal.h"
+#include "gconfmarshal.c"
+
+/*
+ * Error handler override
+ */
+
+static GConfClientErrorHandlerFunc global_error_handler = NULL;
+
+void
+gconf_client_set_global_default_error_handler(GConfClientErrorHandlerFunc func)
+{
+  global_error_handler = func;
+}
+
+/*
+ * CacheEntry
+ */ 
+
+typedef struct _CacheEntry CacheEntry;
+
+struct _CacheEntry {
+  GConfValue* value;
+  /* Whether "value" was a default from a schema; i.e.
+     if this is TRUE, then value wasn't set, we just used
+     a default. */
+  guint is_default : 1;
+  guint is_writable : 1;
+};
+
+static CacheEntry* cache_entry_new(GConfValue* val,
+                                   gboolean is_default,
+                                   gboolean is_writable);
+static void        cache_entry_destroy(CacheEntry* ce);
+
+/*
+ * Dir object (for list of directories we're watching)
+ */
+
+typedef struct _Dir Dir;
+
+struct _Dir {
+  gchar* name;
+  guint notify_id;
+  /* number of times this dir has been added */
+  guint add_count;
+};
+
+static Dir* dir_new(const gchar* name, guint notify_id);
+static void dir_destroy(Dir* d);
+
+/*
+ * Listener object
+ */
+
+typedef struct _Listener Listener;
+
+struct _Listener {
+  GConfClientNotifyFunc func;
+  gpointer data;
+  GFreeFunc destroy_notify;
+};
+
+static Listener* listener_new(GConfClientNotifyFunc func,
+                              GFreeFunc destroy_notify,
+                              gpointer data);
+
+static void listener_destroy(Listener* l);
+
+/*
+ * GConfClient proper
+ */
+
+
+enum {
+  VALUE_CHANGED,
+  UNRETURNED_ERROR,
+  ERROR,
+  LAST_SIGNAL
+};
+
+static void         register_client   (GConfClient *client);
+static GConfClient *lookup_client     (GConfEngine *engine);
+static void         unregister_client (GConfClient *client);
+
+static void gconf_client_class_init (GConfClientClass *klass);
+static void gconf_client_init       (GConfClient      *client);
+static void gconf_client_real_unreturned_error (GConfClient* client, GError* error);
+static void gconf_client_real_error            (GConfClient* client, GError* error);
+static void gconf_client_finalize              (GObject* object); 
+
+static void gconf_client_cache                 (GConfClient* client,
+                                                const gchar* key,
+                                                gboolean is_default,
+                                                gboolean is_writable,
+                                                GConfValue* value); /* takes ownership of value */
+
+static gboolean gconf_client_lookup         (GConfClient* client,
+                                             const gchar* key,
+                                             gboolean use_default,
+                                             gboolean* is_default,
+                                             gboolean* is_writable,
+                                             GConfValue** valp);
+
+static void gconf_client_real_remove_dir    (GConfClient* client,
+                                             Dir* d,
+					     GError** err);
+
+static GConfValue* get (GConfClient  *client,
+                        const gchar  *key,
+                        gboolean      use_default,
+                        gboolean     *is_default_retloc,
+                        gboolean     *is_writable_retloc,
+                        GError      **error);
+
+
+static gpointer parent_class = NULL;
+static guint client_signals[LAST_SIGNAL] = { 0 };
+
+GType
+gconf_client_get_type (void)
+{
+  static GType client_type = 0;
+
+  if (!client_type)
+    {
+      static const GTypeInfo client_info =
+      {
+        sizeof (GConfClientClass),
+        (GBaseInitFunc) NULL,
+        (GBaseFinalizeFunc) NULL,
+        (GClassInitFunc) gconf_client_class_init,
+        NULL,           /* class_finalize */
+        NULL,           /* class_data */
+        sizeof (GConfClient),
+        0,              /* n_preallocs */
+        (GInstanceInitFunc) gconf_client_init
+      };
+
+      client_type = g_type_register_static (G_TYPE_OBJECT,
+                                            "GConfClient",
+                                            &client_info,
+                                            0);
+    }
+
+  return client_type;
+}
+
+static void
+gconf_client_class_init (GConfClientClass *class)
+{
+  GObjectClass *object_class;
+
+  object_class = (GObjectClass*) class;
+
+  parent_class = g_type_class_peek_parent (class);
+
+  client_signals[VALUE_CHANGED] =
+    g_signal_newc ("value_changed",
+                   G_TYPE_FROM_CLASS (object_class),
+                   G_SIGNAL_RUN_LAST,
+                   G_STRUCT_OFFSET (GConfClientClass, value_changed),
+                   NULL, NULL,
+                   gconf_marshal_VOID__STRING_POINTER,
+                   G_TYPE_NONE, 2, G_TYPE_STRING, G_TYPE_POINTER);
+
+  client_signals[UNRETURNED_ERROR] =
+    g_signal_newc ("unreturned_error",
+                   G_TYPE_FROM_CLASS (object_class),
+                   G_SIGNAL_RUN_LAST,
+                   G_STRUCT_OFFSET (GConfClientClass, unreturned_error),
+                   NULL, NULL,
+                   gconf_marshal_VOID__POINTER,
+                   G_TYPE_NONE, 1, G_TYPE_POINTER);
+
+  client_signals[ERROR] =
+    g_signal_newc ("error",
+                   G_TYPE_FROM_CLASS (object_class),
+                   G_SIGNAL_RUN_LAST,
+                   G_STRUCT_OFFSET (GConfClientClass, error),
+                   NULL, NULL,
+                   gconf_marshal_VOID__POINTER,
+                   G_TYPE_NONE, 1, G_TYPE_POINTER);
+  
+  class->value_changed    = NULL;
+  class->unreturned_error = gconf_client_real_unreturned_error;
+  class->error            = gconf_client_real_error;
+
+  object_class->finalize  = gconf_client_finalize;
+}
+
+static void
+gconf_client_init (GConfClient *client)
+{
+  client->engine = NULL;
+  client->error_mode = GCONF_CLIENT_HANDLE_UNRETURNED;
+  client->dir_hash = g_hash_table_new(g_str_hash, g_str_equal);
+  client->cache_hash = g_hash_table_new(g_str_hash, g_str_equal);
+  /* We create the listeners only if they're actually used */
+  client->listeners = NULL;
+}
+
+static gboolean
+destroy_dir_foreach_remove(gpointer key, gpointer value, gpointer user_data)
+{
+  GConfClient *client = user_data;
+  Dir* d = value;
+  
+  /* remove notify for this dir */
+  
+  if(d->notify_id != 0)
+	  gconf_engine_notify_remove(client->engine, d->notify_id);
+  d->notify_id = 0;
+
+  dir_destroy(value);
+
+  return TRUE;
+}
+
+static void
+gconf_client_finalize (GObject* object)
+{
+  GConfClient* client = GCONF_CLIENT(object);
+  
+  g_hash_table_foreach_remove(client->dir_hash,
+                              destroy_dir_foreach_remove, client);
+  
+  gconf_client_clear_cache(client);
+
+  if (client->listeners != NULL)
+    {
+      gconf_listeners_free(client->listeners);
+      client->listeners = NULL;
+    }
+
+  g_hash_table_destroy(client->dir_hash);
+  client->dir_hash = NULL;
+  
+  g_hash_table_destroy(client->cache_hash);
+  client->cache_hash = NULL;
+
+  unregister_client (client);
+  
+  if (client->engine != NULL)
+    {
+      gconf_engine_unref(client->engine);
+      client->engine = NULL;
+    }
+
+  if (G_OBJECT_CLASS (parent_class)->finalize)
+    (* G_OBJECT_CLASS (parent_class)->finalize) (object);
+}
+
+/*
+ * Default error handlers
+ */
+
+static void
+gconf_client_real_unreturned_error (GConfClient* client, GError* error)
+{
+  if (client->error_mode == GCONF_CLIENT_HANDLE_UNRETURNED)
+    {
+      if (global_error_handler != NULL)
+        {
+          (*global_error_handler) (client, error);
+        }
+      else
+        {
+          fprintf (stderr, _("GConf Error: %s\n"),
+                   error->message);
+        }
+    }
+}
+
+static void
+gconf_client_real_error            (GConfClient* client, GError* error)
+{
+  if (client->error_mode == GCONF_CLIENT_HANDLE_ALL)
+    {
+      if (global_error_handler != NULL)
+        {
+          (*global_error_handler) (client, error);
+        }
+      else
+        {
+          fprintf (stderr, _("GConf Error: %s\n"),
+                   error->message);
+        }
+    }
+}
+
+/* Emit the proper signals for the error, and fill in err */
+static gboolean
+handle_error(GConfClient* client, GError* error, GError** err)
+{
+  if (error != NULL)
+    {
+      gconf_client_error(client, error);
+      
+      if (err == NULL)
+        {
+          gconf_client_unreturned_error(client, error);
+
+          g_error_free(error);
+        }
+      else
+        *err = error;
+
+      return TRUE;
+    }
+  else
+    return FALSE;
+}
+
+struct client_and_val {
+  GConfClient* client;
+  GConfEntry* entry;
+};
+
+static void
+notify_listeners_callback(GConfListeners* listeners,
+                          const gchar* key,
+                          guint cnxn_id,
+                          gpointer listener_data,
+                          gpointer user_data)
+{
+  struct client_and_val* cav = user_data;
+  Listener* l = listener_data;
+  
+  g_return_if_fail(cav != NULL);
+  g_return_if_fail(cav->client != NULL);
+  g_return_if_fail(GCONF_IS_CLIENT(cav->client));
+  g_return_if_fail(l != NULL);
+  g_return_if_fail(l->func != NULL);
+
+  (*l->func)(cav->client, cnxn_id, cav->entry, l->data);
+}
+
+static void
+notify_from_server_callback(GConfEngine* conf, guint cnxn_id,
+                            GConfEntry *entry,
+                            gpointer user_data)
+{
+  GConfClient* client = user_data;
+
+  g_return_if_fail(client != NULL);
+  g_return_if_fail(GCONF_IS_CLIENT(client));
+  g_return_if_fail(client->engine == conf);
+
+  /* First do the caching, so that state is sane for the
+   * listeners or functions connected to value_changed.
+   * We know this key is under a directory in our dir list.
+   */
+  gconf_client_cache(client,
+                     entry->key,
+                     entry->is_default,
+                     entry->is_writable,
+                     entry->value ? gconf_value_copy(entry->value) : NULL);
+
+  /* Emit the value_changed signal before notifying specific listeners;
+   * I'm not sure there's a reason this matters though
+   */
+  gconf_client_value_changed(client,
+                             entry->key,
+                             entry->value);
+
+  /* Now notify our listeners, if any */
+  if (client->listeners != NULL)
+    {
+      struct client_and_val cav;
+
+      cav.client = client;
+      cav.entry = entry;
+      
+      gconf_listeners_notify(client->listeners,
+                             entry->key,
+                             notify_listeners_callback,
+                             &cav);
+    }
+}
+
+/*
+ * Public API
+ */
+
+GConfClient*
+gconf_client_get_default (void)
+{
+  GConfClient *client;
+  GConfEngine *engine;
+  
+  g_return_val_if_fail(gconf_is_initialized(), NULL);
+
+  engine = gconf_engine_get_default ();
+  
+  client = lookup_client (engine);
+  if (client)
+    {
+      g_assert (client->engine == engine);
+      g_object_ref (G_OBJECT (client));
+      gconf_engine_unref (engine);
+      return client;
+    }
+  else
+    {
+      client = g_object_new (gconf_client_get_type (), NULL);
+
+      client->engine = engine;
+      register_client (client);
+    }
+  
+  return client;
+}
+
+GConfClient*
+gconf_client_get_for_engine (GConfEngine* engine)
+{
+  GConfClient *client;
+
+  g_return_val_if_fail(gconf_is_initialized(), NULL);
+
+  client = lookup_client (engine);
+  if (client)
+    {
+      g_assert (client->engine == engine);
+      g_object_ref (G_OBJECT (client));
+      return client;
+    }
+  else
+    {
+      client = g_object_new (gconf_client_get_type (), NULL);
+
+      client->engine = engine;
+
+      gconf_engine_ref(client->engine);
+
+      register_client (client);
+    }
+  
+  return client;
+}
+
+typedef struct {
+  GConfClient *client;
+  Dir *lower_dir;
+  const char *dirname;
+} OverlapData;
+
+static void
+foreach_setup_overlap(gpointer key, gpointer value, gpointer user_data)
+{
+  GConfClient *client;
+  Dir *dir = value;
+  OverlapData * od = user_data;
+
+  client = od->client;
+
+  /* if we have found the first (well there is only one anyway) directory
+   * that includes us that has a notify handler
+   */
+#ifdef GCONF_ENABLE_DEBUG
+  if (dir->notify_id != 0 &&
+      gconf_key_is_below(dir->name, od->dirname))
+    {
+      g_assert(od->lower_dir == NULL);
+      od->lower_dir = dir;
+    }
+#else
+  if (od->lower_dir == NULL &&
+      dir->notify_id != 0 &&
+      gconf_key_is_below(dir->name, od->dirname))
+      od->lower_dir = dir;
+#endif
+  /* if we have found a directory that we include and it has
+   * a notify_id, remove the notify handler now
+   * FIXME: this is a race, from now on we can miss notifies, it is
+   * not an incredible amount of time so this is not a showstopper */
+  else if (dir->notify_id != 0 &&
+           gconf_key_is_below (od->dirname, dir->name))
+    {
+      gconf_engine_notify_remove (client->engine, dir->notify_id);
+      dir->notify_id = 0;
+    }
+}
+
+static Dir *
+setup_overlaps(GConfClient* client, const gchar* dirname)
+{
+  OverlapData od;
+
+  od.client = client;
+  od.lower_dir = NULL;
+  od.dirname = dirname;
+
+  g_hash_table_foreach(client->dir_hash, foreach_setup_overlap, &od);
+
+  return od.lower_dir;
+}
+
+void
+gconf_client_add_dir     (GConfClient* client,
+                          const gchar* dirname,
+                          GConfClientPreloadType preload,
+                          GError** err)
+{
+  Dir* d;
+  guint notify_id = 0;
+  GError* error = NULL;
+
+  g_return_if_fail(gconf_valid_key(dirname, NULL));
+  
+  d = g_hash_table_lookup (client->dir_hash, dirname);
+
+  if (d == NULL)
+    {
+      Dir *overlap_dir;
+
+      overlap_dir = setup_overlaps (client, dirname);
+
+      /* only if there is no directory that includes us
+       * already add a notify
+       */
+      if (overlap_dir == NULL)
+        {
+
+          notify_id = gconf_engine_notify_add (client->engine,
+                                               dirname,
+                                               notify_from_server_callback,
+                                               client,
+                                               &error);
+      
+          /* We got a notify ID or we got an error, not both */
+          g_return_if_fail( (notify_id != 0 && error == NULL) ||
+                            (notify_id == 0 && error != NULL) );
+      
+      
+          if (handle_error(client, error, err))
+            return;
+
+          g_assert(error == NULL);
+        }
+      else
+        {
+          notify_id = 0;
+        }
+      
+      d = dir_new(dirname, notify_id);
+
+      g_hash_table_insert(client->dir_hash, d->name, d);
+
+      gconf_client_preload(client, dirname, preload, &error);
+
+      handle_error(client, error, err);
+    }
+
+  g_assert(d != NULL);
+
+  d->add_count += 1;
+}
+
+typedef struct {
+  GConfClient *client;
+  GError *error;
+} AddNotifiesData;
+
+static void
+foreach_add_notifies(gpointer key, gpointer value, gpointer user_data)
+{
+  AddNotifiesData *ad = user_data;
+  GConfClient *client;
+  Dir *dir = value;
+
+  client = ad->client;
+
+  if (ad->error != NULL)
+    return;
+
+  if (dir->notify_id == 0)
+    {
+      Dir *overlap_dir;
+      overlap_dir = setup_overlaps(client, dir->name);
+
+      /* only if there is no directory that includes us
+       * already add a notify */
+      if (overlap_dir == NULL)
+        {
+          dir->notify_id = gconf_engine_notify_add(client->engine,
+					    dir->name,
+					    notify_from_server_callback,
+					    client,
+					    &ad->error);
+
+          /* We got a notify ID or we got an error, not both */
+          g_return_if_fail( (dir->notify_id != 0 && ad->error == NULL) ||
+		            (dir->notify_id == 0 && ad->error != NULL) );
+
+          /* if error is returned, then we'll just ignore
+           * things until the end */
+        }
+    }
+}
+
+static void
+gconf_client_real_remove_dir    (GConfClient* client,
+                                 Dir* d,
+                                 GError** err)
+{
+  AddNotifiesData ad;
+
+  g_return_if_fail(d != NULL);
+  g_return_if_fail(d->add_count == 0);
+  
+  g_hash_table_remove(client->dir_hash, d->name);
+  
+  /* remove notify for this dir */
+  
+  if (d->notify_id != 0)
+    gconf_engine_notify_remove(client->engine, d->notify_id);
+  d->notify_id = 0;
+  
+  dir_destroy(d);
+
+  ad.client = client;
+  ad.error = NULL;
+
+  g_hash_table_foreach(client->dir_hash, foreach_add_notifies, &ad);
+
+  handle_error(client, ad.error, err);
+}
+
+void
+gconf_client_remove_dir  (GConfClient* client,
+                          const gchar* dirname,
+                          GError** err)
+{
+  Dir* found = NULL;
+
+  found = g_hash_table_lookup(client->dir_hash,
+                              dirname);
+  
+  if (found != NULL)
+    {
+      g_return_if_fail(found->add_count > 0);
+
+      found->add_count -= 1;
+
+      if (found->add_count == 0) 
+        gconf_client_real_remove_dir(client, found, err);
+    }
+#ifndef G_DISABLE_CHECKS
+  else
+    g_warning("Directory `%s' was not being monitored by GConfClient %p",
+              dirname, client);
+#endif
+}
+
+
+guint
+gconf_client_notify_add(GConfClient* client,
+                        const gchar* namespace_section,
+                        GConfClientNotifyFunc func,
+                        gpointer user_data,
+                        GFreeFunc destroy_notify,
+                        GError** err)
+{
+  guint cnxn_id = 0;
+  
+  g_return_val_if_fail(client != NULL, 0);
+  g_return_val_if_fail(GCONF_IS_CLIENT(client), 0);
+
+  if (client->listeners == NULL)
+    client->listeners = gconf_listeners_new();
+  
+  cnxn_id = gconf_listeners_add (client->listeners,
+                                 namespace_section,
+                                 listener_new (func, destroy_notify, user_data),
+                                 (GFreeFunc)listener_destroy);
+
+  return cnxn_id;
+}
+
+void
+gconf_client_notify_remove  (GConfClient* client,
+                             guint cnxn)
+{
+  g_return_if_fail(client != NULL);
+  g_return_if_fail(GCONF_IS_CLIENT(client));
+  g_return_if_fail(client->listeners != NULL);
+  
+  gconf_listeners_remove(client->listeners, cnxn);
+  
+  if (gconf_listeners_count(client->listeners) == 0)
+    {
+      gconf_listeners_free(client->listeners);
+      client->listeners = NULL;
+    }
+}
+
+void
+gconf_client_set_error_handling(GConfClient* client,
+                                GConfClientErrorHandlingMode mode)
+{
+  g_return_if_fail(client != NULL);
+  g_return_if_fail(GCONF_IS_CLIENT(client));
+
+  client->error_mode = mode;
+}
+
+static gboolean
+clear_cache_foreach(gchar* key, CacheEntry* ce, GConfClient* client)
+{
+  g_free(key);
+  cache_entry_destroy(ce);
+
+  return TRUE;
+}
+
+void
+gconf_client_clear_cache(GConfClient* client)
+{
+  g_return_if_fail(client != NULL);
+  g_return_if_fail(GCONF_IS_CLIENT(client));
+  
+  g_hash_table_foreach_remove(client->cache_hash, (GHRFunc)clear_cache_foreach,
+                              client);
+
+  g_assert(g_hash_table_size(client->cache_hash) == 0);
+}
+
+static void
+cache_pairs_in_dir(GConfClient* client, const gchar* path);
+
+static void 
+recurse_subdir_list(GConfClient* client, GSList* subdirs, const gchar* parent)
+{
+  GSList* tmp;
+
+  tmp = subdirs;
+  
+  while (tmp != NULL)
+    {
+      gchar* s = tmp->data;
+      gchar* full = gconf_concat_dir_and_key(parent, s);
+      
+      cache_pairs_in_dir(client, full);
+
+      recurse_subdir_list(client, gconf_engine_all_dirs(client->engine, full, NULL), full);
+
+      g_free(s);
+      g_free(full);
+      
+      tmp = g_slist_next(tmp);
+    }
+  
+  g_slist_free(subdirs);
+}
+
+static void 
+cache_pairs_in_dir(GConfClient* client, const gchar* dir)
+{
+  GSList* pairs;
+  GSList* tmp;
+  GError* error = NULL;
+
+  pairs = gconf_engine_all_entries(client->engine, dir, &error);
+          
+  if (error != NULL)
+    {
+      fprintf(stderr, _("GConf warning: failure listing pairs in `%s': %s"),
+              dir, error->message);
+      g_error_free(error);
+      error = NULL;
+    }
+
+  if (pairs != NULL)
+    {
+      tmp = pairs;
+
+      while (tmp != NULL)
+        {
+          GConfEntry* pair = tmp->data;
+          
+          gconf_client_cache(client,
+                             gconf_entry_get_key (pair),
+                             gconf_entry_get_is_default(pair),
+                             gconf_entry_get_is_writable(pair),
+                             gconf_entry_steal_value(pair));
+
+          gconf_entry_free(pair);
+
+          tmp = g_slist_next(tmp);
+        }
+
+      g_slist_free(pairs);
+    }
+}
+
+void
+gconf_client_preload    (GConfClient* client,
+                         const gchar* dirname,
+                         GConfClientPreloadType type,
+                         GError** err)
+{
+
+  g_return_if_fail(client != NULL);
+  g_return_if_fail(GCONF_IS_CLIENT(client));
+  g_return_if_fail(dirname != NULL);
+
+#ifdef GCONF_ENABLE_DEBUG
+  if (g_hash_table_lookup(client->dir_hash, dirname) == NULL)
+    {
+      g_warning("Can only preload directories you've added with gconf_client_add_dir()");
+      return;
+    }
+#endif
+  
+  switch (type)
+    {
+    case GCONF_CLIENT_PRELOAD_NONE:
+      /* nothing */
+      break;
+
+    case GCONF_CLIENT_PRELOAD_ONELEVEL:
+      {
+        GSList* subdirs;
+        
+        subdirs = gconf_engine_all_dirs(client->engine, dirname, NULL);
+        
+        cache_pairs_in_dir(client, dirname);
+      }
+      break;
+
+    case GCONF_CLIENT_PRELOAD_RECURSIVE:
+      {
+        GSList* subdirs;
+        
+        subdirs = gconf_engine_all_dirs(client->engine, dirname, NULL);
+        
+        cache_pairs_in_dir(client, dirname);
+          
+        recurse_subdir_list(client, subdirs, dirname);
+      }
+      break;
+
+    default:
+      g_assert_not_reached();
+      break;
+    }
+}
+
+/*
+ * Basic key-manipulation facilities
+ */
+
+void
+gconf_client_set             (GConfClient* client,
+                              const gchar* key,
+                              GConfValue* val,
+                              GError** err)
+{
+  GError* error = NULL;
+  
+  gconf_engine_set (client->engine, key, val, &error);
+
+  handle_error(client, error, err);
+}
+
+gboolean
+gconf_client_unset          (GConfClient* client,
+                             const gchar* key, GError** err)
+{
+  GError* error = NULL;
+  
+  gconf_engine_unset(client->engine, key, &error);
+
+  handle_error(client, error, err);
+
+  if (error != NULL)
+    return FALSE;
+  else
+    return TRUE;
+}
+
+GSList*
+gconf_client_all_entries    (GConfClient* client,
+                             const gchar* dir, GError** err)
+{
+  GError* error = NULL;
+  GSList* retval;
+  
+  retval = gconf_engine_all_entries(client->engine, dir, &error);
+
+  handle_error(client, error, err);
+
+  return retval;
+}
+
+GSList*
+gconf_client_all_dirs       (GConfClient* client,
+                             const gchar* dir, GError** err)
+{
+  GError* error = NULL;
+  GSList* retval;
+  
+  retval = gconf_engine_all_dirs(client->engine, dir, &error);
+
+  handle_error(client, error, err);
+
+  return retval;
+}
+
+void
+gconf_client_suggest_sync   (GConfClient* client,
+                             GError** err)
+{
+  GError* error = NULL;
+  
+  gconf_engine_suggest_sync(client->engine, &error);
+
+  handle_error(client, error, err);
+}
+
+gboolean
+gconf_client_dir_exists     (GConfClient* client,
+                             const gchar* dir, GError** err)
+{
+  GError* error = NULL;
+  gboolean retval;
+  
+  retval = gconf_engine_dir_exists(client->engine, dir, &error);
+
+  handle_error(client, error, err);
+
+  return retval;
+}
+
+gboolean
+gconf_client_key_is_writable(GConfClient* client,
+                             const gchar* key,
+                             GError**     err)
+{
+  GError* error = NULL;
+  GConfValue* val = NULL;
+  gboolean is_writable = TRUE;
+  
+  g_return_val_if_fail(err == NULL || *err == NULL, FALSE);
+  
+  val = get (client, key, TRUE,
+             NULL, &is_writable, &error);
+
+  if (val == NULL && error != NULL)
+    handle_error(client, error, err);
+  else
+    g_assert(error == NULL);
+
+  /* FIXME we could avoid creating this value at all if
+   * we were somewhat less lame.
+   */
+  if (val)
+    gconf_value_free (val);
+  
+  return is_writable;
+}
+
+static gboolean
+check_type(const gchar* key, GConfValue* val, GConfValueType t, GError** err)
+{
+  if (val->type != t)
+    {
+      gconf_set_error(err, GCONF_ERROR_TYPE_MISMATCH,
+                      _("Expected `%s' got `%s' for key %s"),
+                      gconf_value_type_to_string(t),
+                      gconf_value_type_to_string(val->type),
+                      key);
+      return FALSE;
+    }
+  else
+    return TRUE;
+}
+
+static GConfValue*
+get (GConfClient *client,
+     const gchar *key,
+     gboolean     use_default,
+     gboolean    *is_default_retloc,
+     gboolean    *is_writable_retloc,
+     GError     **error)
+{
+  GConfValue* val = NULL;
+  gboolean is_default = FALSE;
+  gboolean is_writable = TRUE;
+  
+  g_return_val_if_fail(client != NULL, NULL);
+  g_return_val_if_fail(GCONF_IS_CLIENT(client), NULL);
+  g_return_val_if_fail(error != NULL, NULL);
+  g_return_val_if_fail(*error == NULL, NULL);
+  
+  /* Check our client-side cache */
+  if (gconf_client_lookup(client, key, use_default,
+                          &is_default,
+                          &is_writable,
+                          &val))
+    {
+      if (is_default_retloc)
+        *is_default_retloc = is_default;
+
+      if (is_writable_retloc)
+        *is_writable_retloc = is_writable;
+      
+      /* may be NULL of course */
+      return val ? gconf_value_copy (val) : NULL;
+    }
+      
+  g_assert(val == NULL); /* if it was in the cache we should have returned */
+
+  /* Check the GConfEngine */
+  val = gconf_engine_get_full(client->engine, key,
+                              gconf_current_locale(),
+                              use_default, &is_default, &is_writable,
+                              error);
+
+  if (is_default_retloc)
+    *is_default_retloc = is_default;
+
+  if (is_writable_retloc)
+    *is_writable_retloc = is_writable;
+  
+  if (*error != NULL)
+    {
+      g_return_val_if_fail(val == NULL, NULL);
+      return NULL;
+    }
+  else
+    {
+      /* Cache this value, if it's in our directory list. FIXME could
+       * speed this up.
+       */
+      gchar* parent = g_strdup(key);
+      gchar* end;
+
+      end = strrchr(parent, '/');
+
+      while (end && parent != end)
+        {
+          *end = '\0';
+          
+          if (g_hash_table_lookup(client->dir_hash, parent) != NULL)
+            {
+              /* cache a copy of val */
+              gconf_client_cache (client, key, is_default, is_writable,
+                                  val ? gconf_value_copy (val) : NULL);
+              break;
+            }
+          
+          end = strrchr(parent, '/');
+        }
+
+      g_free(parent);
+
+      /* We don't own val, we're returning this copy belonging
+       * to the caller
+       */
+      return val;
+    }
+}
+     
+static GConfValue*
+gconf_client_get_full        (GConfClient* client,
+                              const gchar* key, const gchar* locale,
+                              gboolean use_schema_default,
+                              gboolean* value_is_default,
+                              gboolean* value_is_writable,
+                              GError** err)
+{
+  GError* error = NULL;
+  GConfValue* val = NULL;
+  gboolean is_default = FALSE;
+  gboolean is_writable = TRUE;
+  
+  g_return_val_if_fail(err == NULL || *err == NULL, NULL);
+
+  if (locale != NULL)
+    g_warning("haven't implemented getting a specific locale in GConfClient");
+  
+  val = get(client, key, use_schema_default,
+            &is_default, &is_writable, &error);
+
+  if (val == NULL && error != NULL)
+    handle_error(client, error, err);
+  else
+    g_assert(error == NULL);
+
+
+  if (value_is_default)
+    *value_is_default = is_default;
+
+  if (value_is_writable)
+    *value_is_writable = is_writable;
+
+  return val;
+}
+
+GConfEntry*
+gconf_client_get_entry (GConfClient* client,
+                        const gchar* key,
+                        const gchar* locale,
+                        gboolean use_schema_default,
+                        GError** err)
+{
+  GError* error = NULL;
+  GConfValue* val = NULL;
+  gboolean is_default = FALSE;
+  gboolean is_writable = TRUE;
+  GConfEntry *entry;
+  
+  g_return_val_if_fail(err == NULL || *err == NULL, NULL);
+
+  if (locale != NULL)
+    g_warning("haven't implemented getting a specific locale in GConfClient");
+  
+  val = get(client, key, use_schema_default,
+            &is_default, &is_writable, &error);
+
+  if (val == NULL && error != NULL)
+    handle_error(client, error, err);
+  else
+    g_assert(error == NULL);
+
+  entry = gconf_entry_new_nocopy (g_strdup (key), val);
+  entry->is_default = is_default;
+  entry->is_writable = is_writable;
+  
+  return entry;
+}
+
+GConfValue*
+gconf_client_get             (GConfClient* client,
+                              const gchar* key,
+                              GError** err)
+{
+  return gconf_client_get_full(client, key, NULL, TRUE, NULL, NULL, err);
+}
+
+GConfValue*
+gconf_client_get_without_default  (GConfClient* client,
+                                   const gchar* key,
+                                   GError** err)
+{
+  return gconf_client_get_full(client, key, NULL, FALSE, NULL, NULL, err);
+}
+
+GConfValue*
+gconf_client_get_default_from_schema (GConfClient* client,
+                                      const gchar* key,
+                                      GError** err)
+{
+  GError* error = NULL;
+  GConfValue* val = NULL;
+  gboolean is_default = FALSE;
+  
+  g_return_val_if_fail(err == NULL || *err == NULL, NULL);  
+  g_return_val_if_fail(client != NULL, NULL);
+  g_return_val_if_fail(GCONF_IS_CLIENT(client), NULL);
+  
+  /* Check our client-side cache to see if the default is the same as
+   the regular value (FIXME put a default_value field in the
+   CacheEntry and store both, lose the is_default flag in CacheEntry) */
+  if (gconf_client_lookup(client, key, TRUE,
+                          &is_default,
+                          NULL,
+                          &val))
+    {        
+      if (is_default)
+        return val ? gconf_value_copy(val) : NULL;
+    }
+
+  /* Check the GConfEngine */
+  val = gconf_engine_get_default_from_schema(client->engine, key,
+                                             &error);
+  
+  if (error != NULL)
+    {
+      g_assert(val == NULL);
+      handle_error(client, error, err);
+      return NULL;
+    }
+  else
+    {
+      /* FIXME eventually we'll cache the value
+         by adding a field to CacheEntry */
+      return val;
+    }
+}
+
+gdouble
+gconf_client_get_float (GConfClient* client, const gchar* key,
+                        GError** err)
+{
+  static const gdouble def = 0.0;
+  GError* error = NULL;
+  GConfValue* val;
+
+  g_return_val_if_fail(err == NULL || *err == NULL, 0.0);
+  
+  val = get(client, key, TRUE, NULL, NULL, &error);
+
+  if (val != NULL)
+    {
+      gdouble retval = def;
+
+      g_assert(error == NULL);
+      
+      if (check_type(key, val, GCONF_VALUE_FLOAT, &error))
+        retval = gconf_value_get_float(val);
+      else
+        handle_error(client, error, err);
+
+      gconf_value_free(val);
+
+      return retval;
+    }
+  else
+    {
+      if (error != NULL)
+        handle_error(client, error, err);
+      return def;
+    }
+}
+
+gint
+gconf_client_get_int   (GConfClient* client, const gchar* key,
+                        GError** err)
+{
+  static const gint def = 0;
+  GError* error = NULL;
+  GConfValue* val;
+
+  g_return_val_if_fail(err == NULL || *err == NULL, 0);
+
+  val = get(client, key, TRUE, NULL, NULL, &error);
+
+  if (val != NULL)
+    {
+      gint retval = def;
+
+      g_assert(error == NULL);
+      
+      if (check_type(key, val, GCONF_VALUE_INT, &error))
+        retval = gconf_value_get_int(val);
+      else
+        handle_error(client, error, err);
+
+      gconf_value_free(val);
+
+      return retval;
+    }
+  else
+    {
+      if (error != NULL)
+        handle_error(client, error, err);
+      return def;
+    }
+}
+
+gchar*
+gconf_client_get_string(GConfClient* client, const gchar* key,
+                        GError** err)
+{
+  static const gchar* def = NULL;
+  GError* error = NULL;
+  GConfValue* val;
+
+  g_return_val_if_fail(err == NULL || *err == NULL, NULL);
+  
+  val = get(client, key, TRUE, NULL, NULL, &error);
+
+  if (val != NULL)
+    {
+      gchar* retval = NULL;
+
+      g_assert(error == NULL);
+      
+      if (check_type(key, val, GCONF_VALUE_STRING, &error))
+	/* we cheat here (look below) so we have to cast this */
+        retval = (gchar *)gconf_value_get_string(val);
+      else
+        handle_error(client, error, err);
+
+      /* This is a cheat; don't copy */
+      if (retval != NULL)
+        val->d.string_data = NULL; /* don't delete the string we are returning */
+      else
+        retval = def ? g_strdup(def) : NULL;
+      
+      gconf_value_free(val);
+
+      return retval;
+    }
+  else
+    {
+      if (error != NULL)
+        handle_error(client, error, err);
+      return def ? g_strdup(def) : NULL;
+    }
+}
+
+
+gboolean
+gconf_client_get_bool  (GConfClient* client, const gchar* key,
+                        GError** err)
+{
+  static const gboolean def = FALSE;
+  GError* error = NULL;
+  GConfValue* val;
+
+  g_return_val_if_fail(err == NULL || *err == NULL, FALSE);
+
+  val = get(client, key, TRUE, NULL, NULL, &error);  
+
+  if (val != NULL)
+    {
+      gboolean retval = def;
+
+      g_assert(error == NULL);
+      
+      if (check_type(key, val, GCONF_VALUE_BOOL, &error))
+        retval = gconf_value_get_bool(val);
+      else
+        handle_error(client, error, err);
+
+      gconf_value_free(val);
+
+      return retval;
+    }
+  else
+    {
+      if (error != NULL)
+        handle_error(client, error, err);
+      return def;
+    }
+}
+
+GConfSchema*
+gconf_client_get_schema  (GConfClient* client,
+                          const gchar* key, GError** err)
+{
+  GError* error = NULL;
+  GConfValue* val;
+
+  g_return_val_if_fail(err == NULL || *err == NULL, NULL);
+
+  val = get(client, key, TRUE, NULL, NULL, &error);
+
+  if (val != NULL)
+    {
+      GConfSchema* retval = NULL;
+
+      g_assert(error == NULL);
+      
+      if (check_type(key, val, GCONF_VALUE_SCHEMA, &error))
+        retval = gconf_value_get_schema(val);
+      else
+        handle_error(client, error, err);
+
+      /* This is a cheat; don't copy */
+      if (retval != NULL)
+        val->d.schema_data = NULL; /* don't delete the schema */
+      
+      gconf_value_free(val);
+
+      return retval;
+    }
+  else
+    {
+      if (error != NULL)
+        handle_error(client, error, err);
+      return NULL;
+    }
+}
+
+GSList*
+gconf_client_get_list    (GConfClient* client, const gchar* key,
+                          GConfValueType list_type, GError** err)
+{
+  GError* error = NULL;
+  GConfValue* val;
+
+  g_return_val_if_fail(err == NULL || *err == NULL, NULL);
+
+  val = get(client, key, TRUE, NULL, NULL, &error);
+
+  if (val != NULL)
+    {
+      GSList* retval;
+
+      g_assert(error == NULL);
+
+      /* This function checks the type and destroys "val" */
+      retval = gconf_value_list_to_primitive_list_destructive(val, list_type, &error);
+
+      if (error != NULL)
+        {
+          g_assert(retval == NULL);
+          handle_error(client, error, err);
+          return NULL;
+        }
+      else
+        return retval;
+    }
+  else
+    {
+      if (error != NULL)
+        handle_error(client, error, err);
+      return NULL;
+    }
+}
+
+gboolean
+gconf_client_get_pair    (GConfClient* client, const gchar* key,
+                          GConfValueType car_type, GConfValueType cdr_type,
+                          gpointer car_retloc, gpointer cdr_retloc,
+                          GError** err)
+{
+  GError* error = NULL;
+  GConfValue* val;
+
+  g_return_val_if_fail(err == NULL || *err == NULL, FALSE);
+
+  val = get(client, key, TRUE, NULL, NULL, &error);  
+
+  if (val != NULL)
+    {
+      g_assert(error == NULL);
+
+      /* This function checks the type and destroys "val" */
+      if (gconf_value_pair_to_primitive_pair_destructive(val, car_type, cdr_type,
+                                                         car_retloc, cdr_retloc,
+                                                         &error))
+        {
+          g_assert(error == NULL);
+          return TRUE;
+        }
+      else
+        {
+          g_assert(error != NULL);
+          handle_error(client, error, err);
+          return FALSE;
+        }
+    }
+  else
+    {
+      if (error != NULL)
+        {
+          handle_error(client, error, err);
+          return FALSE;
+        }
+      else
+        return TRUE;
+    }
+
+}
+
+
+/*
+ * For the set functions, we just set normally, and wait for the
+ * notification to come back from the server before we update
+ * our cache. This may be the wrong thing; maybe we should
+ * update immediately?
+ * Problem with delayed update: user calls set() then get(),
+ *  results in weirdness
+ * Problem with with regular update: get() before the notify
+ *  is out of sync with the listening parts of the application
+ * 
+ * It is somewhat academic now anyway because the _set() call
+ * won't return until all the notifications have happened, so the
+ * notify signal will be emitted inside the set() call.
+ */
+
+gboolean
+gconf_client_set_float   (GConfClient* client, const gchar* key,
+                          gdouble val, GError** err)
+{
+  GError* error = NULL;
+  
+  g_return_val_if_fail(client != NULL, FALSE);
+  g_return_val_if_fail(GCONF_IS_CLIENT(client), FALSE);  
+  g_return_val_if_fail(key != NULL, FALSE);
+  
+  if (gconf_engine_set_float(client->engine, key, val, &error))
+    return TRUE;
+  else
+    {
+      handle_error(client, error, err);
+      return FALSE;
+    }
+}
+
+gboolean
+gconf_client_set_int     (GConfClient* client, const gchar* key,
+                          gint val, GError** err)
+{
+  GError* error = NULL;
+  
+  g_return_val_if_fail(client != NULL, FALSE);
+  g_return_val_if_fail(GCONF_IS_CLIENT(client), FALSE);  
+  g_return_val_if_fail(key != NULL, FALSE);
+  
+  if (gconf_engine_set_int(client->engine, key, val, &error))
+    return TRUE;
+  else
+    {
+      handle_error(client, error, err);
+      return FALSE;
+    }
+}
+
+gboolean
+gconf_client_set_string  (GConfClient* client, const gchar* key,
+                          const gchar* val, GError** err)
+{
+  GError* error = NULL;
+  
+  g_return_val_if_fail(client != NULL, FALSE);
+  g_return_val_if_fail(GCONF_IS_CLIENT(client), FALSE);  
+  g_return_val_if_fail(key != NULL, FALSE);
+  g_return_val_if_fail(val != NULL, FALSE);
+  
+  if (gconf_engine_set_string(client->engine, key, val, &error))
+    return TRUE;
+  else
+    {
+      handle_error(client, error, err);
+      return FALSE;
+    }
+}
+
+gboolean
+gconf_client_set_bool    (GConfClient* client, const gchar* key,
+                          gboolean val, GError** err)
+{
+  GError* error = NULL;
+  
+  g_return_val_if_fail(client != NULL, FALSE);
+  g_return_val_if_fail(GCONF_IS_CLIENT(client), FALSE);  
+  g_return_val_if_fail(key != NULL, FALSE);
+  
+  if (gconf_engine_set_bool(client->engine, key, val, &error))
+    return TRUE;
+  else
+    {
+      handle_error(client, error, err);
+      return FALSE;
+    }
+}
+
+gboolean
+gconf_client_set_schema  (GConfClient* client, const gchar* key,
+                          GConfSchema* val, GError** err)
+{
+  GError* error = NULL;
+  
+  g_return_val_if_fail(client != NULL, FALSE);
+  g_return_val_if_fail(GCONF_IS_CLIENT(client), FALSE);  
+  g_return_val_if_fail(key != NULL, FALSE);
+  g_return_val_if_fail(val != NULL, FALSE);
+  
+  if (gconf_engine_set_schema(client->engine, key, val, &error))
+    return TRUE;
+  else
+    {
+      handle_error(client, error, err);
+      return FALSE;
+    }
+}
+
+gboolean
+gconf_client_set_list    (GConfClient* client, const gchar* key,
+                          GConfValueType list_type,
+                          GSList* list,
+                          GError** err)
+{
+  GError* error = NULL;
+  
+  g_return_val_if_fail(client != NULL, FALSE);
+  g_return_val_if_fail(GCONF_IS_CLIENT(client), FALSE);  
+  g_return_val_if_fail(key != NULL, FALSE);
+  
+  if (gconf_engine_set_list(client->engine, key, list_type, list, &error))
+    return TRUE;
+  else
+    {
+      handle_error(client, error, err);
+      return FALSE;
+    }
+}
+
+gboolean
+gconf_client_set_pair    (GConfClient* client, const gchar* key,
+                          GConfValueType car_type, GConfValueType cdr_type,
+                          gconstpointer address_of_car,
+                          gconstpointer address_of_cdr,
+                          GError** err)
+{
+  GError* error = NULL;
+  
+  g_return_val_if_fail(client != NULL, FALSE);
+  g_return_val_if_fail(GCONF_IS_CLIENT(client), FALSE);  
+  g_return_val_if_fail(key != NULL, FALSE);
+  
+  if (gconf_engine_set_pair(client->engine, key, car_type, cdr_type,
+                     address_of_car, address_of_cdr, &error))
+    return TRUE;
+  else
+    {
+      handle_error(client, error, err);
+      return FALSE;
+    }
+}
+
+
+/*
+ * Functions to emit signals
+ */
+
+void
+gconf_client_error                  (GConfClient* client, GError* error)
+{
+  g_return_if_fail(client != NULL);
+  g_return_if_fail(GCONF_IS_CLIENT(client));
+  
+  g_signal_emit(G_OBJECT(client), client_signals[ERROR], 0,
+                error);
+}
+
+void
+gconf_client_unreturned_error       (GConfClient* client, GError* error)
+{
+  g_return_if_fail(client != NULL);
+  g_return_if_fail(GCONF_IS_CLIENT(client));
+
+  g_signal_emit(G_OBJECT(client), client_signals[UNRETURNED_ERROR], 0,
+                error);
+}
+
+void
+gconf_client_value_changed          (GConfClient* client,
+                                     const gchar* key,
+                                     GConfValue* value)
+{
+  g_return_if_fail(client != NULL);
+  g_return_if_fail(GCONF_IS_CLIENT(client));
+  g_return_if_fail(key != NULL);
+  
+  g_signal_emit(G_OBJECT(client), client_signals[VALUE_CHANGED], 0,
+                key, value);
+}
+
+/*
+ * Internal utility
+ */
+
+static void
+gconf_client_cache (GConfClient* client,
+                    const gchar* key,
+                    gboolean is_default,
+                    gboolean is_writable,
+                    GConfValue* value)
+{
+  /* Remember: value may be NULL */
+  
+  gpointer oldkey = NULL, oldval = NULL;
+
+  if (g_hash_table_lookup_extended(client->cache_hash, key, &oldkey, &oldval))
+    {
+      /* Already have a value, update it */
+      CacheEntry* ce = oldval;
+
+      g_assert(ce != NULL);
+
+      if (ce->value != NULL)
+        gconf_value_free(ce->value);
+
+      ce->value = value;
+      ce->is_default = is_default;
+      ce->is_writable = is_writable;
+    }
+  else
+    {
+      /* Create a new entry */
+      CacheEntry* ce = cache_entry_new(value, is_default, is_writable);
+      g_hash_table_insert(client->cache_hash, g_strdup(key), ce);
+    }
+}
+
+static gboolean
+gconf_client_lookup         (GConfClient* client,
+                             const gchar* key,
+                             gboolean use_default,
+                             gboolean* is_default,
+                             gboolean* is_writable,
+                             GConfValue** valp)
+{
+  CacheEntry* ce;
+
+  g_return_val_if_fail(valp != NULL, FALSE);
+  g_return_val_if_fail(*valp == NULL, FALSE);
+  
+  ce = g_hash_table_lookup(client->cache_hash, key);
+
+  if (ce != NULL)
+    {
+      if (ce->is_default)
+        {
+          *is_default = TRUE;
+          
+          if (use_default)
+            *valp = ce->value;            
+          else
+            *valp = NULL;
+        }
+      else
+        {
+          *is_default = FALSE;
+
+          *valp = ce->value;
+        }
+
+      if (is_writable)
+        *is_writable = ce->is_writable;
+      
+      return TRUE;
+    }
+  else
+    return FALSE;
+}
+
+
+/*
+ * CacheEntry
+ */ 
+
+static CacheEntry*
+cache_entry_new(GConfValue* val,
+                gboolean is_default, gboolean is_writable)
+{
+  CacheEntry* ce;
+
+  ce = g_new(CacheEntry, 1);
+
+  /* val may be NULL */
+  ce->value = val;
+  ce->is_default = is_default;
+  ce->is_writable = is_writable;
+  
+  return ce;
+}
+
+static void
+cache_entry_destroy(CacheEntry* ce)
+{
+  g_return_if_fail(ce != NULL);
+  
+  if (ce->value != NULL)
+    gconf_value_free(ce->value);
+
+  g_free(ce);
+}
+
+/*
+ * Dir
+ */
+
+static Dir*
+dir_new(const gchar* name, guint notify_id)
+{
+  Dir* d;
+
+  d = g_new(Dir, 1);
+
+  d->name = g_strdup(name);
+  d->notify_id = notify_id;
+  d->add_count = 0;
+  
+  return d;
+}
+
+static void
+dir_destroy(Dir* d)
+{
+  g_return_if_fail(d != NULL);
+  g_return_if_fail(d->notify_id == 0);
+  
+  g_free(d->name);
+  g_free(d);
+}
+
+/*
+ * Listener
+ */
+
+static Listener* 
+listener_new(GConfClientNotifyFunc func,
+             GFreeFunc destroy_notify,
+             gpointer data)
+{
+  Listener* l;
+
+  l = g_new(Listener, 1);
+
+  l->func = func;
+  l->data = data;
+  l->destroy_notify = destroy_notify;
+  
+  return l;
+}
+
+static void
+listener_destroy(Listener* l)
+{
+  g_return_if_fail(l != NULL);
+
+  if (l->destroy_notify)
+    (* l->destroy_notify) (l->data);
+  
+  g_free(l);
+}
+
+/*
+ * Change sets
+ */
+
+
+struct CommitData {
+  GConfClient* client;
+  GError* error;
+  GSList* remove_list;
+  gboolean remove_committed;
+};
+
+static void
+commit_foreach (GConfChangeSet* cs,
+                const gchar* key,
+                GConfValue* value,
+                gpointer user_data)
+{
+  struct CommitData* cd = user_data;
+
+  g_assert(cd != NULL);
+
+  if (cd->error != NULL)
+    return;
+  
+  if (value)
+    gconf_client_set   (cd->client, key, value, &cd->error);
+  else
+    gconf_client_unset (cd->client, key, &cd->error);
+
+  if (cd->error == NULL && cd->remove_committed)
+    {
+      /* Bad bad bad; we keep the key reference, knowing that it's
+         valid until we modify the change set, to avoid string copies.  */
+      cd->remove_list = g_slist_prepend(cd->remove_list, (gchar*)key);
+    }
+}
+
+gboolean
+gconf_client_commit_change_set   (GConfClient* client,
+                                  GConfChangeSet* cs,
+                                  gboolean remove_committed,
+                                  GError** err)
+{
+  struct CommitData cd;
+  GSList* tmp;
+
+  g_return_val_if_fail(client != NULL, FALSE);
+  g_return_val_if_fail(GCONF_IS_CLIENT(client), FALSE);
+  g_return_val_if_fail(cs != NULL, FALSE);
+  g_return_val_if_fail(err == NULL || *err == NULL, FALSE);
+  
+  cd.client = client;
+  cd.error = NULL;
+  cd.remove_list = NULL;
+  cd.remove_committed = remove_committed;
+
+  /* Because the commit could have lots of side
+     effects, this makes it safer */
+  gconf_change_set_ref(cs);
+  g_object_ref(G_OBJECT(client));
+  
+  gconf_change_set_foreach(cs, commit_foreach, &cd);
+
+  tmp = cd.remove_list;
+  while (tmp != NULL)
+    {
+      const gchar* key = tmp->data;
+      
+      gconf_change_set_remove(cs, key);
+
+      /* key is now invalid due to our little evil trick */
+
+      tmp = g_slist_next(tmp);
+    }
+
+  g_slist_free(cd.remove_list);
+  
+  gconf_change_set_unref(cs);
+  g_object_unref(G_OBJECT(client));
+
+  if (cd.error != NULL)
+    {
+      if (err != NULL)
+        *err = cd.error;
+      else
+        g_error_free(cd.error);
+
+      return FALSE;
+    }
+  else
+    {
+      g_assert((!remove_committed) ||
+               (gconf_change_set_size(cs) == 0));
+      
+      return TRUE;
+    }
+}
+
+struct RevertData {
+  GConfClient* client;
+  GError* error;
+  GConfChangeSet* revert_set;
+};
+
+static void
+revert_foreach (GConfChangeSet* cs,
+                const gchar* key,
+                GConfValue* value,
+                gpointer user_data)
+{
+  struct RevertData* rd = user_data;
+  GConfValue* old_value;
+  GError* error = NULL;
+  
+  g_assert(rd != NULL);
+
+  if (rd->error != NULL)
+    return;
+
+  old_value = gconf_client_get_without_default(rd->client, key, &error);
+
+  if (error != NULL)
+    {
+      /* FIXME */
+      g_warning("error creating revert set: %s", error->message);
+      g_error_free(error);
+      error = NULL;
+    }
+  
+  if (old_value == NULL &&
+      value == NULL)
+    return; /* this commit will have no effect. */
+
+  if (old_value == NULL)
+    gconf_change_set_unset(rd->revert_set, key);
+  else
+    gconf_change_set_set_nocopy(rd->revert_set, key, old_value);
+}
+
+
+GConfChangeSet*
+gconf_client_reverse_change_set  (GConfClient* client,
+                                         GConfChangeSet* cs,
+                                         GError** err)
+{
+  struct RevertData rd;
+
+  rd.error = NULL;
+  rd.client = client;
+  rd.revert_set = gconf_change_set_new();
+
+  /* we're emitting signals and such, avoid
+     nasty side effects with these.
+  */
+  g_object_ref(G_OBJECT(rd.client));
+  gconf_change_set_ref(cs);
+  
+  gconf_change_set_foreach(cs, revert_foreach, &rd);
+
+  if (rd.error != NULL)
+    {
+      if (err != NULL)
+        *err = rd.error;
+      else
+        g_error_free(rd.error);
+    }
+
+  g_object_unref(G_OBJECT(rd.client));
+  gconf_change_set_unref(cs);
+  
+  return rd.revert_set;
+}
+
+
+GConfChangeSet*
+gconf_client_change_set_from_currentv (GConfClient* client,
+                                              const gchar** keys,
+                                              GError** err)
+{
+  GConfValue* old_value;
+  GConfChangeSet* new_set;
+  const gchar** keyp;
+  
+  g_return_val_if_fail(err == NULL || *err == NULL, NULL);
+
+  new_set = gconf_change_set_new();
+  
+  keyp = keys;
+
+  while (*keyp != NULL)
+    {
+      GError* error = NULL;
+      const gchar* key = *keyp;
+      
+      old_value = gconf_client_get_without_default(client, key, &error);
+
+      if (error != NULL)
+        {
+          /* FIXME */
+          g_warning("error creating change set from current keys: %s", error->message);
+          g_error_free(error);
+          error = NULL;
+        }
+      
+      if (old_value == NULL)
+        gconf_change_set_unset(new_set, key);
+      else
+        gconf_change_set_set_nocopy(new_set, key, old_value);
+
+      ++keyp;
+    }
+
+  return new_set;
+}
+
+GConfChangeSet*
+gconf_client_change_set_from_current (GConfClient* client,
+                                             GError** err,
+                                             const gchar* first_key,
+                                             ...)
+{
+  GSList* keys = NULL;
+  va_list args;
+  const gchar* arg;
+  const gchar** vec;
+  GConfChangeSet* retval;
+  GSList* tmp;
+  guint i;
+  
+  g_return_val_if_fail(err == NULL || *err == NULL, NULL);
+
+  va_start (args, first_key);
+
+  arg = first_key;
+
+  while (arg != NULL)
+    {
+      keys = g_slist_prepend(keys, (/*non-const*/gchar*)arg);
+
+      arg = va_arg (args, const gchar*);
+    }
+  
+  va_end (args);
+
+  vec = g_new0(const gchar*, g_slist_length(keys) + 1);
+
+  i = 0;
+  tmp = keys;
+
+  while (tmp != NULL)
+    {
+      vec[i] = tmp->data;
+      
+      ++i;
+      tmp = g_slist_next(tmp);
+    }
+
+  g_slist_free(keys);
+  
+  retval = gconf_client_change_set_from_currentv(client, vec, err);
+  
+  g_free(vec);
+
+  return retval;
+}
+
+static GHashTable * clients = NULL;
+
+static void
+register_client (GConfClient *client)
+{
+  if (clients == NULL)
+    clients = g_hash_table_new (NULL, NULL);
+
+  g_hash_table_insert (clients, client->engine, client);
+}
+
+static GConfClient *
+lookup_client (GConfEngine *engine)
+{
+  if (clients == NULL)
+    return NULL;
+  else
+    return g_hash_table_lookup (clients, engine);
+}
+
+static void
+unregister_client (GConfClient *client)
+{
+  g_return_if_fail (clients != NULL);
+
+  g_hash_table_remove (clients, client->engine);
+}
Index: gconf/gconf-client.h
===================================================================
RCS file: gconf-client.h
diff -N gconf-client.h
--- /dev/null	Tue May  5 16:32:27 1998
+++ gconf-client.h	Sun Mar 18 13:19:33 2001
@@ -0,0 +1,379 @@
+/* -*- tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* GConf
+ * Copyright (C) 1999, 2000 Red Hat Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef GCONF_GCONF_CLIENT_H
+#define GCONF_GCONF_CLIENT_H
+
+#include <gobject/gobject.h>
+#include <gconf/gconf.h>
+#include <gconf/gconf-listeners.h>
+#include <gconf/gconf-changeset.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/*
+ * This is a wrapper for the client-side GConf API which provides several
+ * convenient features.
+ *
+ *  - It (recursively) caches the contents of certain directories on
+ *    the client side, such as your application's configuration
+ *    directory
+ *
+ *  - It allows you to register per-key callbacks within these directories,
+ *    without having to register multiple server-side callbacks
+ *    (gconf_engine_notify_add() adds a request-for-notify to the server,
+ *    this wrapper adds a notify to the server for the whole directory
+ *    and keeps your per-key notify requests on the client side).
+ *
+ *  - It has some error-handling features
+ *
+ * This class is heavily specialized for per-user desktop applications -
+ * even more so than GConf itself.
+ */
+
+/*
+ * IMPORTANT: you can't mix GConfClient with direct GConfEngine access,
+ * or you will have a mess because the client won't know what you're doing
+ * underneath it.
+ */
+
+typedef enum {
+  GCONF_CLIENT_PRELOAD_NONE,     /* don't preload anything */
+  GCONF_CLIENT_PRELOAD_ONELEVEL, /* load entries directly under the directory. */
+  GCONF_CLIENT_PRELOAD_RECURSIVE /* recurse the directory tree; possibly quite expensive! */
+} GConfClientPreloadType;
+
+typedef enum {
+  GCONF_CLIENT_HANDLE_NONE,
+  GCONF_CLIENT_HANDLE_UNRETURNED,
+  GCONF_CLIENT_HANDLE_ALL
+} GConfClientErrorHandlingMode;
+
+
+typedef struct _GConfClient       GConfClient;
+typedef struct _GConfClientClass  GConfClientClass;
+
+
+typedef void (*GConfClientNotifyFunc)(GConfClient* client,
+                                      guint cnxn_id,
+                                      GConfEntry *entry,
+                                      gpointer user_data);
+
+typedef void (*GConfClientErrorHandlerFunc) (GConfClient* client,
+                                             GError* error);
+
+#define GCONF_TYPE_CLIENT                  (gconf_client_get_type ())
+#define GCONF_CLIENT(obj)                  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GCONF_TYPE_CLIENT, GConfClient))
+#define GCONF_CLIENT_CLASS(klass)          (G_TYPE_CHECK_CLASS_CAST ((klass), GCONF_TYPE_CLIENT, GConfClientClass))
+#define GCONF_IS_CLIENT(obj)               (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GCONF_TYPE_CLIENT))
+#define GCONF_IS_CLIENT_CLASS(klass)       (G_TYPE_CHECK_CLASS_TYPE ((klass), GCONF_TYPE_CLIENT))
+
+struct _GConfClient
+{
+  GObject object;
+
+  /*< private >*/
+
+  GConfEngine* engine;
+  GConfClientErrorHandlingMode error_mode;
+  GHashTable* dir_hash;
+  GHashTable* cache_hash;
+  GConfListeners* listeners;
+};
+
+struct _GConfClientClass
+{
+  GObjectClass parent_class;
+
+  /* emitted whenever a value changes. Often, you should use a notify
+     function instead; the problem with this signal is that you
+     probably have to do an expensive chain of strcmp() to
+     determine how to respond to it.
+  */
+
+  void (* value_changed) (GConfClient* client,
+                          const gchar* key,
+                          GConfValue* value);
+
+  /* General note about error handling: AVOID DIALOG DELUGES.
+     That is, if lots of errors could happen in a row you need
+     to collect those and put them in _one_ dialog, maybe using
+     an idle function. gconf_client_set_error_handling()
+     is provided and it does this using GnomeDialog.  */
+
+  /* emitted when you pass NULL for the error return location to a
+     GConfClient function and an error occurs. This allows you to
+     ignore errors when your generic handler will work, and handle
+     them specifically when you need to */
+  void (* unreturned_error) (GConfClient* client,
+                             GError* error);
+
+  /* emitted unconditionally anytime there's an error, whether you ask
+     for that error or not. Useful for creating an error log or
+     something. */
+  void (* error)            (GConfClient* client,
+                             GError* error);
+};
+
+
+GType             gconf_client_get_type        (void);
+
+/* use the default engine */
+GConfClient*      gconf_client_get_default             (void);
+
+/* refcount on engine is incremented, you still own your ref */
+GConfClient*      gconf_client_get_for_engine (GConfEngine* engine);
+
+/* Add a directory to monitor and emit the value_changed signal and
+   key notifications for.  Optionally pre-load the contents of this
+   directory, much faster if you plan to access most of the directory
+   contents. You can't add overlapping directories.
+*/
+
+void              gconf_client_add_dir     (GConfClient* client,
+                                            const gchar* dir,
+                                            GConfClientPreloadType preload,
+                                            GError** err);
+
+
+/* This removes any notifications associated with the dir */
+void              gconf_client_remove_dir  (GConfClient* client,
+                                            const gchar* dir,
+                                            GError** err);
+
+/*
+ *  The notification facility allows you to attach a callback to a single
+ *  key or directory, which is more convenient most of the time than
+ *  the value_changed signal. The key you're monitoring must be inside one
+ *  of the GConfClient's directories.
+ */
+
+
+/* Returns ID of the notification */
+/* returns 0 on error, 0 is an invalid ID */
+guint        gconf_client_notify_add(GConfClient* client,
+                                     const gchar* namespace_section, /* dir or key to listen to */
+                                     GConfClientNotifyFunc func,
+                                     gpointer user_data,
+                                     GFreeFunc destroy_notify,
+                                     GError** err);
+
+void         gconf_client_notify_remove  (GConfClient* client,
+                                          guint cnxn);
+
+/*
+ * Error handling convenience; if you don't want the default handler,
+ * set the error handling to GCONF_CLIENT_HANDLE_NONE
+ */
+
+/* 
+ * Error handling happens in the default signal handler, so you can
+ * selectively override the default handling by connecting to the error
+ * signal and calling gtk_signal_emit_stop()
+ */
+
+void              gconf_client_set_error_handling(GConfClient* client,
+                                                  GConfClientErrorHandlingMode mode);
+
+
+/* Intended for use by gnome-libs */
+void              gconf_client_set_global_default_error_handler(GConfClientErrorHandlerFunc func);
+
+/*
+ * If you know you're done reading values for a while,
+ * you can blow away the cache. Note that this nullifies the effect of
+ * any preloading you may have done. However it frees some memory.
+ */
+void              gconf_client_clear_cache(GConfClient* client);
+
+/*
+ * Preload a directory; the directory must have been added already.
+ * This is only useful as an optimization if you clear the cache,
+ * then later want to do a lot of reads again. It's not useful
+ * unless you clear the cache, because you can preload when you
+ * call gconf_client_add_dir()
+ */
+void              gconf_client_preload    (GConfClient* client,
+                                           const gchar* dirname,
+                                           GConfClientPreloadType type,
+                                           GError** err);
+
+/*
+ * Basic key-manipulation facilities; these keys do _not_ have to be in the
+ * client's directory list, but they won't be cached unless they are.
+ */
+
+void              gconf_client_set             (GConfClient* client,
+                                                const gchar* key,
+                                                GConfValue* val,
+                                                GError** err);
+
+GConfValue*       gconf_client_get             (GConfClient* client,
+                                                const gchar* key,
+                                                GError** err);
+
+GConfValue*       gconf_client_get_without_default  (GConfClient* client,
+                                                     const gchar* key,
+                                                     GError** err);
+
+GConfEntry*       gconf_client_get_entry        (GConfClient* client,
+                                                 const gchar* key,
+                                                 const gchar* locale,
+                                                 gboolean use_schema_default,
+                                                 GError** err);
+
+GConfValue*       gconf_client_get_default_from_schema (GConfClient* client,
+                                                        const gchar* key,
+                                                        GError** err);
+
+gboolean     gconf_client_unset          (GConfClient* client,
+                                          const gchar* key, GError** err);
+
+GSList*      gconf_client_all_entries    (GConfClient* client,
+                                          const gchar* dir, GError** err);
+
+GSList*      gconf_client_all_dirs       (GConfClient* client,
+                                          const gchar* dir, GError** err);
+
+void         gconf_client_suggest_sync   (GConfClient* client,
+                                          GError** err);
+
+gboolean     gconf_client_dir_exists     (GConfClient* client,
+                                          const gchar* dir, GError** err);
+
+gboolean     gconf_client_key_is_writable(GConfClient* client,
+                                          const gchar* key,
+                                          GError**     err);
+
+/* Get/Set convenience wrappers */
+
+gdouble      gconf_client_get_float (GConfClient* client, const gchar* key,
+                                     GError** err);
+
+gint         gconf_client_get_int   (GConfClient* client, const gchar* key,
+                                     GError** err);
+
+/* free the retval, if non-NULL */
+gchar*       gconf_client_get_string(GConfClient* client, const gchar* key,
+                                     GError** err);
+
+gboolean     gconf_client_get_bool  (GConfClient* client, const gchar* key,
+                                     GError** err);
+
+/* this one has no default since it would be expensive and make little
+   sense; it returns NULL as a default, to indicate unset or error */
+/* free the retval */
+/* Note that this returns the schema stored at key, NOT
+   the schema that key conforms to. */
+GConfSchema* gconf_client_get_schema  (GConfClient* client,
+                                       const gchar* key, GError** err);
+
+GSList*      gconf_client_get_list    (GConfClient* client, const gchar* key,
+                                       GConfValueType list_type, GError** err);
+
+gboolean     gconf_client_get_pair    (GConfClient* client, const gchar* key,
+                                       GConfValueType car_type, GConfValueType cdr_type,
+                                       gpointer car_retloc, gpointer cdr_retloc,
+                                       GError** err);
+
+/* No convenience functions for lists or pairs, since there are too
+   many combinations of types possible
+*/
+
+/* setters return TRUE on success; note that you still should suggest a sync */
+
+gboolean     gconf_client_set_float   (GConfClient* client, const gchar* key,
+                                       gdouble val, GError** err);
+
+gboolean     gconf_client_set_int     (GConfClient* client, const gchar* key,
+                                       gint val, GError** err);
+
+gboolean     gconf_client_set_string  (GConfClient* client, const gchar* key,
+                                       const gchar* val, GError** err);
+
+gboolean     gconf_client_set_bool    (GConfClient* client, const gchar* key,
+                                       gboolean val, GError** err);
+
+gboolean     gconf_client_set_schema  (GConfClient* client, const gchar* key,
+                                       GConfSchema* val, GError** err);
+
+/* List should be the same as the one gconf_client_get_list() would return */
+gboolean     gconf_client_set_list    (GConfClient* client, const gchar* key,
+                                       GConfValueType list_type,
+                                       GSList* list,
+                                       GError** err);
+
+gboolean     gconf_client_set_pair    (GConfClient* client, const gchar* key,
+                                       GConfValueType car_type, GConfValueType cdr_type,
+                                       gconstpointer address_of_car,
+                                       gconstpointer address_of_cdr,
+                                       GError** err);
+
+/*
+ * Functions to emit signals
+ */
+
+/* these are useful to manually invoke the default error handlers */
+void         gconf_client_error                  (GConfClient* client, GError* error);
+void         gconf_client_unreturned_error       (GConfClient* client, GError* error);
+
+/* useful to force an update */
+void         gconf_client_value_changed          (GConfClient* client,
+                                                  const gchar* key,
+                                                  GConfValue* value);
+
+/*
+ * Change set stuff
+ */
+
+gboolean        gconf_client_commit_change_set   (GConfClient* client,
+                                                  GConfChangeSet* cs,
+                                                  /* remove all
+                                                     successfully
+                                                     committed changes
+                                                     from the set */
+                                                  gboolean remove_committed,
+                                                  GError** err);
+
+/* Create a change set that would revert the given change set
+   for the given GConfClient */
+GConfChangeSet* gconf_client_reverse_change_set  (GConfClient* client,
+                                                         GConfChangeSet* cs,
+                                                         GError** err);
+
+GConfChangeSet* gconf_client_change_set_from_currentv (GConfClient* client,
+                                                              const gchar** keys,
+                                                              GError** err);
+
+GConfChangeSet* gconf_client_change_set_from_current (GConfClient* client,
+                                                             GError** err,
+                                                             const gchar* first_key,
+                                                             ...);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+
+
+
Index: gconf/gconf-database.h
===================================================================
RCS file: /cvs/gnome/gconf/gconf/gconf-database.h,v
retrieving revision 1.6
diff -u -u -p -r1.6 gconf-database.h
--- gconf/gconf-database.h	2000/10/08 19:51:32	1.6
+++ gconf/gconf-database.h	2001/03/18 18:19:33
@@ -31,7 +31,6 @@ extern "C" {
 #include "gconf-listeners.h"
 #include "gconf-sources.h"
 #include "gconf-internals.h"
-#include "gconf-glib-private.h"
 
 typedef struct _GConfDatabase GConfDatabase;
 
Index: gconf/gconf-error.h
===================================================================
RCS file: /cvs/gnome/gconf/gconf/gconf-error.h,v
retrieving revision 1.15
diff -u -u -p -r1.15 gconf-error.h
--- gconf/gconf-error.h	2000/10/07 01:31:18	1.15
+++ gconf/gconf-error.h	2001/03/18 18:19:33
@@ -22,8 +22,6 @@
 
 #include <glib.h>
 
-#include <gconf/gconf-glib-public.h>
-
 #ifdef __cplusplus
 extern "C" {
 #endif /* __cplusplus */
Index: gconf/gconf-glib-private.h
===================================================================
RCS file: gconf-glib-private.h
diff -N gconf-glib-private.h
--- /tmp/cvskYBWh8	Sun Mar 18 13:19:37 2001
+++ /dev/null	Tue May  5 16:32:27 1998
@@ -1,38 +0,0 @@
-/* GConf
- * Copyright (C) 1999, 2000 Red Hat Inc.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#ifndef GCONF_GCONF_GLIB_PRIVATE_H
-#define GCONF_GCONF_GLIB_PRIVATE_H
-
-#include <glib.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-#include "gconf-glib-public.h"
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif
-
-
-
Index: gconf/gconf-glib-public.h
===================================================================
RCS file: gconf-glib-public.h
diff -N gconf-glib-public.h
--- /tmp/cvsiBuORp	Sun Mar 18 13:19:37 2001
+++ /dev/null	Tue May  5 16:32:27 1998
@@ -1,79 +0,0 @@
-/* GConf
- * Copyright (C) 1999, 2000 Red Hat Inc.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#ifndef GCONF_GCONF_GLIB_PUBLIC_H
-#define GCONF_GCONF_GLIB_PUBLIC_H
-
-#include <glib.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-typedef struct _GError GError;
-
-struct _GError
-{
-  GQuark       domain;
-  gint         code;
-  gchar       *message;
-};
-
-GError*  g_error_new           (GQuark         domain,
-                                gint           code,
-                                const gchar   *format,
-                                ...) G_GNUC_PRINTF (3, 4);
-
-GError*  g_error_new_literal   (GQuark         domain,
-                                gint           code,
-                                const gchar   *message);
-
-void     g_error_free          (GError        *error);
-GError*  g_error_copy          (const GError  *error);
-
-gboolean g_error_matches       (const GError  *error,
-                                GQuark         domain,
-                                gint           code);
-
-/* if (err) *err = g_error_new(domain, code, format, ...), also has
- * some sanity checks.
- */
-void     g_set_error           (GError       **err,
-                                GQuark         domain,
-                                gint           code,
-                                const gchar   *format,
-                                ...) G_GNUC_PRINTF (4, 5);
-
-/* if (err && *err) { g_error_free(*err); *err = NULL; } */
-void     g_clear_error         (GError       **err);
-
-/* if (dest) *dest = src; also has some sanity checks.
- */
-void     g_propagate_error     (GError       **dest,
-				GError        *src);
-
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif
-
-
-
Index: gconf/gconfd.c
===================================================================
RCS file: /cvs/gnome/gconf/gconf/gconfd.c,v
retrieving revision 1.100
diff -u -u -p -r1.100 gconfd.c
--- gconf/gconfd.c	2001/03/07 00:14:29	1.100
+++ gconf/gconfd.c	2001/03/18 18:19:34
@@ -32,7 +32,6 @@
 #include "gconf-listeners.h"
 #include "gconf-locale.h"
 #include "gconf-schema.h"
-#include "gconf-glib-private.h"
 #include "gconf.h"
 #include "gconfd.h"
 #include "gconf-database.h"
Index: gconf/gconfmarshal.list
===================================================================
RCS file: gconfmarshal.list
diff -N gconfmarshal.list
--- /dev/null	Tue May  5 16:32:27 1998
+++ gconfmarshal.list	Sun Mar 18 13:19:34 2001
@@ -0,0 +1,2 @@
+VOID:POINTER
+VOID:STRING,POINTER
Index: gconf/gconftool.c
===================================================================
RCS file: /cvs/gnome/gconf/gconf/gconftool.c,v
retrieving revision 1.54
diff -u -u -p -r1.54 gconftool.c
--- gconf/gconftool.c	2001/03/13 11:02:04	1.54
+++ gconf/gconftool.c	2001/03/18 18:19:36
@@ -22,9 +22,9 @@
 #include <stdio.h>
 #include <unistd.h>
 #include <popt.h>
-#include <gnome-xml/tree.h>
-#include <gnome-xml/parser.h>
-#include <gnome-xml/xmlmemory.h>
+#include <libxml/tree.h>
+#include <libxml/parser.h>
+#include <libxml/xmlmemory.h>
 #include <stdlib.h>
 #include <errno.h>
 
@@ -314,6 +314,9 @@ main (int argc, char** argv)
   poptContext ctx;
   gint nextopt;
   GError* err = NULL;
+
+  LIBXML_TEST_VERSION;
+  xmlKeepBlanksDefault(1);
   
   ctx = poptGetContext("gconftool", argc, argv, options, 0);
 
@@ -1466,7 +1469,7 @@ extract_global_info(xmlNodePtr node,
   xmlNodePtr iter;
   char* default_value = NULL;
       
-  iter = node->childs;
+  iter = node->xmlChildrenNode;
 
   while (iter != NULL)
     {
@@ -1671,7 +1674,7 @@ process_locale_info(xmlNodePtr node, Sch
 
 
   /* Locale-specific info */
-  iter = node->childs;
+  iter = node->xmlChildrenNode;
   
   while (iter != NULL)
     {
@@ -1825,7 +1828,7 @@ process_schema(GConfEngine* conf, xmlNod
       return 1;
     }
   
-  iter = node->childs;
+  iter = node->xmlChildrenNode;
 
   while (iter != NULL)
     {
@@ -1887,7 +1890,7 @@ process_schema_list(GConfEngine* conf, x
 {
   xmlNodePtr iter;
 
-  iter = node->childs;
+  iter = node->xmlChildrenNode;
 
   while (iter != NULL)
     {
@@ -1921,14 +1924,14 @@ do_load_schema_file(GConfEngine* conf, c
       return 1;
     }
 
-  if (doc->root == NULL)
+  if (doc->xmlRootNode == NULL)
     {
       fprintf(stderr, _("Document `%s' is empty?\n"),
               file);
       return 1;
     }
 
-  iter = doc->root;
+  iter = doc->xmlRootNode;
   while (iter != NULL) 
     {
       if (iter->type == XML_ELEMENT_NODE)
@@ -1953,7 +1956,7 @@ do_load_schema_file(GConfEngine* conf, c
       return 1;
     }
 
-  iter = iter->childs;
+  iter = iter->xmlChildrenNode;
 
   while (iter != NULL)
     {
Index: gconf/testgconfclient.c
===================================================================
RCS file: testgconfclient.c
diff -N testgconfclient.c
--- /dev/null	Tue May  5 16:32:27 1998
+++ testgconfclient.c	Sun Mar 18 13:19:36 2001
@@ -0,0 +1,322 @@
+/* -*- tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* GConf
+ * Copyright (C) 1999, 2000, 2000 Red Hat Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include "gconf-client.h"
+
+#include <gtk/gtk.h>
+
+static void create_controls(GConfClient* client);
+
+int
+main(int argc, char** argv)
+{
+  GError* error = NULL;
+  GConfClient* client = NULL;
+
+  gtk_init(&argc, &argv);
+  
+  if (!gconf_init(argc, argv, &error))
+    {
+      g_assert(error != NULL);
+      g_warning("GConf init failed:\n  %s", error->message);
+      return 1;
+    }
+
+  g_assert(error == NULL);
+
+  client = gconf_client_get_default();
+
+  gconf_client_add_dir(client, "/apps/gnome/testgconfclient", GCONF_CLIENT_PRELOAD_NONE, NULL);
+
+  create_controls(client);
+  
+  gtk_main();
+
+  gtk_object_unref(GTK_OBJECT(client));
+  
+  return 0;
+}
+
+static void
+entry_notify_func(GConfClient* client, guint cnxn_id,
+                  GConfEntry *gconf_entry,
+                  gpointer user_data)
+{
+  GtkWidget* entry = user_data;
+  
+  g_return_if_fail(GTK_IS_ENTRY(entry));
+
+  gtk_signal_handler_block_by_data(GTK_OBJECT(entry), client);
+  gtk_entry_set_text(GTK_ENTRY(entry),
+                     gconf_value_get_string(gconf_entry->value));
+  gtk_signal_handler_unblock_by_data(GTK_OBJECT(entry), client);
+}
+
+static void
+entry_destroyed_callback(GtkWidget* entry, gpointer data)
+{
+  GConfClient* client = data;
+
+  guint notify_id = GPOINTER_TO_UINT(gtk_object_get_data(GTK_OBJECT(entry),
+                                                         "notify_id"));
+
+  gconf_client_notify_remove(client, notify_id);
+}
+
+static void
+entry_changed_callback(GtkWidget* entry, gpointer data)
+{
+  GConfClient* client = data;
+  const gchar* key;
+  gchar* text;
+
+  text = gtk_editable_get_chars(GTK_EDITABLE(entry), 0, -1);
+  key = gtk_object_get_data(GTK_OBJECT(entry), "key");
+  
+  gconf_client_set_string(client, key, text, NULL);
+
+  g_free(text);
+}
+
+static GtkWidget*
+entry_attached_to(GConfClient* client, const gchar* key)
+{
+  GtkWidget* entry;
+  GtkWidget* hbox;
+  GtkWidget* label;
+  gchar* val;
+  guint notify_id;
+  
+  entry = gtk_entry_new();
+
+  gtk_object_set_data_full(GTK_OBJECT(entry), "key",
+                           g_strdup(key), g_free);
+
+
+  val = gconf_client_get_string(client, key, NULL);
+
+  gtk_entry_set_text(GTK_ENTRY(entry), val ? val : "");
+
+  g_free(val);
+  
+  notify_id = gconf_client_notify_add(client, key, entry_notify_func, entry, NULL, NULL);
+
+  gtk_object_set_data(GTK_OBJECT(entry), "notify_id",
+                      GUINT_TO_POINTER(notify_id));
+  
+  gtk_signal_connect(GTK_OBJECT(entry), "changed",
+                     GTK_SIGNAL_FUNC(entry_changed_callback),
+                     client);
+
+  gtk_signal_connect(GTK_OBJECT(entry), "destroy",
+                     GTK_SIGNAL_FUNC(entry_destroyed_callback),
+                     client);
+  
+  hbox = gtk_hbox_new(FALSE, 10);
+
+  label = gtk_label_new(key);
+
+  gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
+  gtk_box_pack_end(GTK_BOX(hbox), entry, FALSE, FALSE, 0);
+
+  /* Set sensitive according to whether the key is writable or not. */
+  gtk_widget_set_sensitive (entry,
+                            gconf_client_key_is_writable (client,
+                                                          key, NULL));
+  
+  return hbox;
+}
+
+static void
+destroy_callback(GtkWidget* win, gpointer data)
+{
+  GConfClient* client = data;
+
+  gtk_object_unref(GTK_OBJECT(client));
+}
+
+static void
+quit_callback(GtkWidget* button, gpointer data)
+{
+  GtkWidget* win = data;
+
+  gtk_widget_destroy(win);
+
+  gtk_main_quit();
+}
+
+static void
+addsub_callback(GtkWidget* button, gpointer data)
+{
+  GtkWidget* win = data;
+  GConfClient* client = gtk_object_get_data(GTK_OBJECT(win), "client");
+  GtkWidget* label = gtk_object_get_data(GTK_OBJECT(win), "label");
+  int subdir = GPOINTER_TO_INT(gtk_object_get_data(GTK_OBJECT(win), "subdir"));
+  int maindir = GPOINTER_TO_INT(gtk_object_get_data(GTK_OBJECT(win), "maindir"));
+  char *s;
+
+  subdir++;
+
+  gtk_object_set_data(GTK_OBJECT(win), "subdir", GINT_TO_POINTER(subdir));
+
+  gconf_client_add_dir(client, "/apps/gnome/testgconfclient/subdir", GCONF_CLIENT_PRELOAD_NONE, NULL);
+
+  s = g_strdup_printf("Maindir added %d times\nSubdir added %d times", maindir, subdir);
+  gtk_label_set(GTK_LABEL(label), s);
+  g_free(s);
+}
+
+static void
+removesub_callback(GtkWidget* button, gpointer data)
+{
+  GtkWidget* win = data;
+  GConfClient* client = gtk_object_get_data(GTK_OBJECT(win), "client");
+  GtkWidget* label = gtk_object_get_data(GTK_OBJECT(win), "label");
+  int subdir = GPOINTER_TO_INT(gtk_object_get_data(GTK_OBJECT(win), "subdir"));
+  int maindir = GPOINTER_TO_INT(gtk_object_get_data(GTK_OBJECT(win), "maindir"));
+  char *s;
+
+  subdir--;
+
+  gtk_object_set_data(GTK_OBJECT(win), "subdir", GINT_TO_POINTER(subdir));
+
+  gconf_client_remove_dir(client, "/apps/gnome/testgconfclient/subdir", NULL);
+
+  s = g_strdup_printf("Maindir added %d times\nSubdir added %d times", maindir, subdir);
+  gtk_label_set(GTK_LABEL(label), s);
+  g_free(s);
+}
+
+static void
+addmain_callback(GtkWidget* button, gpointer data)
+{
+  GtkWidget* win = data;
+  GConfClient* client = gtk_object_get_data(GTK_OBJECT(win), "client");
+  GtkWidget* label = gtk_object_get_data(GTK_OBJECT(win), "label");
+  int subdir = GPOINTER_TO_INT(gtk_object_get_data(GTK_OBJECT(win), "subdir"));
+  int maindir = GPOINTER_TO_INT(gtk_object_get_data(GTK_OBJECT(win), "maindir"));
+  char *s;
+
+  maindir++;
+
+  gtk_object_set_data(GTK_OBJECT(win), "maindir", GINT_TO_POINTER(maindir));
+
+  gconf_client_add_dir(client, "/apps/gnome/testgconfclient", GCONF_CLIENT_PRELOAD_NONE, NULL);
+
+  s = g_strdup_printf("Maindir added %d times\nSubdir added %d times", maindir, subdir);
+  gtk_label_set(GTK_LABEL(label), s);
+  g_free(s);
+}
+  
+static void
+removemain_callback(GtkWidget* button, gpointer data)
+{
+  GtkWidget* win = data;
+  GConfClient* client = gtk_object_get_data(GTK_OBJECT(win), "client");
+  GtkWidget* label = gtk_object_get_data(GTK_OBJECT(win), "label");
+  int subdir = GPOINTER_TO_INT(gtk_object_get_data(GTK_OBJECT(win), "subdir"));
+  int maindir = GPOINTER_TO_INT(gtk_object_get_data(GTK_OBJECT(win), "maindir"));
+  char *s;
+
+  maindir--;
+
+  gtk_object_set_data(GTK_OBJECT(win), "maindir", GINT_TO_POINTER(maindir));
+
+  gconf_client_remove_dir(client, "/apps/gnome/testgconfclient", NULL);
+
+  s = g_strdup_printf("Maindir added %d times\nSubdir added %d times", maindir, subdir);
+  gtk_label_set(GTK_LABEL(label), s);
+  g_free(s);
+}
+
+static void
+create_controls(GConfClient* client)
+{
+  GtkWidget* win;
+  GtkWidget* label;
+  GtkWidget* vbox;
+  GtkWidget* button;
+  GtkWidget* entry;
+  
+  /* Reference held by the window */
+
+  gtk_object_ref(GTK_OBJECT(client));
+
+  win = gtk_window_new(GTK_WINDOW_TOPLEVEL);
+  
+  gtk_object_set_data(GTK_OBJECT(win), "client", client);
+
+  gtk_signal_connect(GTK_OBJECT(win), "destroy",
+                     GTK_SIGNAL_FUNC(destroy_callback), client);
+
+  vbox = gtk_vbox_new(FALSE, 10);
+
+  gtk_container_add(GTK_CONTAINER(win), vbox);
+
+  label = gtk_label_new("Maindir added 1 times\nSubdir added 0 times");
+  gtk_box_pack_end(GTK_BOX(vbox), label, FALSE, FALSE, 0);
+  gtk_object_set_data(GTK_OBJECT(win), "label", label);
+  gtk_object_set_data(GTK_OBJECT(win), "subdir", GINT_TO_POINTER(0));
+  gtk_object_set_data(GTK_OBJECT(win), "maindir", GINT_TO_POINTER(1));
+
+  button = gtk_button_new_with_label("Quit");
+  gtk_signal_connect(GTK_OBJECT(button), "clicked",
+                     GTK_SIGNAL_FUNC(quit_callback), win);
+  gtk_box_pack_end(GTK_BOX(vbox), button, FALSE, FALSE, 0);
+  
+  button = gtk_button_new_with_label("Remove subdir");
+  gtk_signal_connect(GTK_OBJECT(button), "clicked",
+                     GTK_SIGNAL_FUNC(removesub_callback), win);
+  gtk_box_pack_end(GTK_BOX(vbox), button, FALSE, FALSE, 0);
+
+  button = gtk_button_new_with_label("Add subdir");
+  gtk_signal_connect(GTK_OBJECT(button), "clicked",
+                     GTK_SIGNAL_FUNC(addsub_callback), win);
+  gtk_box_pack_end(GTK_BOX(vbox), button, FALSE, FALSE, 0);
+
+  button = gtk_button_new_with_label("Remove maindir");
+  gtk_signal_connect(GTK_OBJECT(button), "clicked",
+                     GTK_SIGNAL_FUNC(removemain_callback), win);
+  gtk_box_pack_end(GTK_BOX(vbox), button, FALSE, FALSE, 0);
+
+  button = gtk_button_new_with_label("Add maindir");
+  gtk_signal_connect(GTK_OBJECT(button), "clicked",
+                     GTK_SIGNAL_FUNC(addmain_callback), win);
+  gtk_box_pack_end(GTK_BOX(vbox), button, FALSE, FALSE, 0);
+
+  entry = entry_attached_to(client, "/apps/gnome/testgconfclient/blah");
+  gtk_box_pack_start(GTK_BOX(vbox), entry, FALSE, FALSE, 0);
+
+  entry = entry_attached_to(client, "/apps/gnome/testgconfclient/foo");
+  gtk_box_pack_start(GTK_BOX(vbox), entry, FALSE, FALSE, 0);
+
+  entry = entry_attached_to(client, "/apps/gnome/testgconfclient/bar");
+  gtk_box_pack_start(GTK_BOX(vbox), entry, FALSE, FALSE, 0);
+
+  entry = entry_attached_to(client, "/apps/gnome/testgconfclient/subdir/testsub1");
+  gtk_box_pack_start(GTK_BOX(vbox), entry, FALSE, FALSE, 0);
+
+  entry = entry_attached_to(client, "/apps/gnome/testgconfclient/subdir/testsub2");
+  gtk_box_pack_start(GTK_BOX(vbox), entry, FALSE, FALSE, 0);
+  
+  gtk_widget_show_all(win);
+}
+
+
Index: po/POTFILES.in
===================================================================
RCS file: /cvs/gnome/gconf/po/POTFILES.in,v
retrieving revision 1.8
diff -u -u -p -r1.8 POTFILES.in
--- po/POTFILES.in	2000/12/05 12:16:48	1.8
+++ po/POTFILES.in	2001/03/18 18:19:36
@@ -14,4 +14,4 @@ gconf/gconf-value.c
 gconf/gconf.c
 gconf/gconfd.c
 gconf/gconftool.c
-wrappers/gtk/gconf-client.c
+gconf/gconf-client.c
Index: wrappers/Makefile.am
===================================================================
RCS file: /cvs/gnome/gconf/wrappers/Makefile.am,v
retrieving revision 1.6
diff -u -u -p -r1.6 Makefile.am
--- wrappers/Makefile.am	1999/11/23 20:47:41	1.6
+++ wrappers/Makefile.am	2001/03/18 18:19:36
@@ -6,11 +6,5 @@ else
 GUILE_SUBDIRS=
 endif
 
-if GTK
-GTK_SUBDIRS=gtk
-else
-GTK_SUBDIRS=
-endif
-
-SUBDIRS = $(GTK_SUBDIRS) $(GUILE_SUBDIRS)
+SUBDIRS = $(GUILE_SUBDIRS)
 
Index: wrappers/gtk/.cvsignore
===================================================================
RCS file: .cvsignore
diff -N .cvsignore
--- /tmp/cvs0DcSu0	Sun Mar 18 13:19:37 2001
+++ /dev/null	Tue May  5 16:32:27 1998
@@ -1,7 +0,0 @@
-Makefile.in
-Makefile
-.deps
-.libs
-*.lo
-*.la
-testgconfclient
Index: wrappers/gtk/Makefile.am
===================================================================
RCS file: Makefile.am
diff -N Makefile.am
--- /tmp/cvsGj7RBm	Sun Mar 18 13:19:37 2001
+++ /dev/null	Tue May  5 16:32:27 1998
@@ -1,23 +0,0 @@
-INCLUDES=-I$(top_srcdir) -I$(top_builddir) -I$(top_builddir)/gconf \
-	 -DGCONF_LOCALE_DIR=\""$(gconflocaledir)"\" $(GLIB_CFLAGS) $(OAF_CFLAGS) $(GMODULE_CFLAGS) $(ORBIT_CFLAGS) $(GTK_CFLAGS) \
-	-DGCONF_SRCDIR=\""$(absolute_top_srcdir)"\" -DGCONF_SYSCONFDIR=\""$(sysconfdir)/$(MAJOR_VERSION)"\" -DGCONF_BACKEND_DIR=\""$(pkglibdir)/$(MAJOR_VERSION)"\"  -DGCONF_ENABLE_INTERNALS=1 -DG_LOG_DOMAIN=\"GConfClient\"
-
-lib_LTLIBRARIES = libgconf-gtk-1.la
-
-gconfincludedir = $(includedir)/gconf/$(MAJOR_VERSION)/gconf
-gconfinclude_HEADERS =     \
-	gconf-client.h
-
-libgconf_gtk_1_la_SOURCES = \
-	gconf-client.c
-
-libgconf_gtk_1_la_LDFLAGS=-version-info $(GCONFGTK_CURRENT):$(GCONFGTK_REVISION):$(GCONFGTK_AGE)
-
-libgconf_gtk_1_la_LIBADD= $(INTLLIBS) $(OAF_LIBS) $(GTK_LIBS)
-
-noinst_PROGRAMS= testgconfclient
-
-testgconfclient_SOURCES = testgconfclient.c
-
-testgconfclient_DEPS=$(top_builddir)/gconf/libgconf-$(MAJOR_VERSION).la libgconf-gtk-$(MAJOR_VERSION).la
-testgconfclient_LDADD = $(INTLLIBS) $(ORBIT_LIBS) $(GTK_LIBS) $(top_builddir)/gconf/libgconf-$(MAJOR_VERSION).la $(top_builddir)/wrappers/gtk/libgconf-gtk-$(MAJOR_VERSION).la
Index: wrappers/gtk/gconf-client.c
===================================================================
RCS file: gconf-client.c
diff -N gconf-client.c
--- /tmp/cvsKjqcyI	Sun Mar 18 13:19:37 2001
+++ /dev/null	Tue May  5 16:32:27 1998
@@ -1,2145 +0,0 @@
-/* -*- tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* GConf
- * Copyright (C) 1999, 2000, 2000 Red Hat Inc.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#include <stdio.h>
-#include "gconf-client.h"
-#include <gtk/gtksignal.h>
-#include <gtk/gtktypeutils.h>
-#include <gconf/gconf-internals.h>
-
-/*
- * Error handler override
- */
-
-static GConfClientErrorHandlerFunc global_error_handler = NULL;
-
-void
-gconf_client_set_global_default_error_handler(GConfClientErrorHandlerFunc func)
-{
-  global_error_handler = func;
-}
-
-/*
- * CacheEntry
- */ 
-
-typedef struct _CacheEntry CacheEntry;
-
-struct _CacheEntry {
-  GConfValue* value;
-  /* Whether "value" was a default from a schema; i.e.
-     if this is TRUE, then value wasn't set, we just used
-     a default. */
-  guint is_default : 1;
-  guint is_writable : 1;
-};
-
-static CacheEntry* cache_entry_new(GConfValue* val,
-                                   gboolean is_default,
-                                   gboolean is_writable);
-static void        cache_entry_destroy(CacheEntry* ce);
-
-/*
- * Dir object (for list of directories we're watching)
- */
-
-typedef struct _Dir Dir;
-
-struct _Dir {
-  gchar* name;
-  guint notify_id;
-  /* number of times this dir has been added */
-  guint add_count;
-};
-
-static Dir* dir_new(const gchar* name, guint notify_id);
-static void dir_destroy(Dir* d);
-
-/*
- * Listener object
- */
-
-typedef struct _Listener Listener;
-
-struct _Listener {
-  GConfClientNotifyFunc func;
-  gpointer data;
-  GFreeFunc destroy_notify;
-};
-
-static Listener* listener_new(GConfClientNotifyFunc func,
-                              GFreeFunc destroy_notify,
-                              gpointer data);
-
-static void listener_destroy(Listener* l);
-
-/*
- * GConfClient proper
- */
-
-
-enum {
-  VALUE_CHANGED,
-  UNRETURNED_ERROR,
-  ERROR,
-  LAST_SIGNAL
-};
-
-static void         register_client   (GConfClient *client);
-static GConfClient *lookup_client     (GConfEngine *engine);
-static void         unregister_client (GConfClient *client);
-
-static void gconf_client_class_init (GConfClientClass *klass);
-static void gconf_client_init       (GConfClient      *client);
-static void gconf_client_real_unreturned_error (GConfClient* client, GError* error);
-static void gconf_client_real_error            (GConfClient* client, GError* error);
-static void gconf_client_finalize              (GtkObject* object); 
-
-static void gconf_client_cache                 (GConfClient* client,
-                                                const gchar* key,
-                                                gboolean is_default,
-                                                gboolean is_writable,
-                                                GConfValue* value); /* takes ownership of value */
-
-static gboolean gconf_client_lookup         (GConfClient* client,
-                                             const gchar* key,
-                                             gboolean use_default,
-                                             gboolean* is_default,
-                                             gboolean* is_writable,
-                                             GConfValue** valp);
-
-static void gconf_client_real_remove_dir    (GConfClient* client,
-                                             Dir* d,
-					     GError** err);
-
-static GConfValue* get (GConfClient  *client,
-                        const gchar  *key,
-                        gboolean      use_default,
-                        gboolean     *is_default_retloc,
-                        gboolean     *is_writable_retloc,
-                        GError      **error);
-
-
-static guint client_signals[LAST_SIGNAL] = { 0 };
-static GtkObjectClass* parent_class = NULL;
-
-GtkType
-gconf_client_get_type (void)
-{
-  static GtkType client_type = 0;
-
-  if (!client_type)
-    {
-      static const GtkTypeInfo client_info =
-      {
-        "GConfClient",
-        sizeof (GConfClient),
-        sizeof (GConfClientClass),
-        (GtkClassInitFunc) gconf_client_class_init,
-        (GtkObjectInitFunc) gconf_client_init,
-        /* reserved_1 */ NULL,
-        /* reserved_2 */ NULL,
-        (GtkClassInitFunc) NULL,
-      };
-
-      client_type = gtk_type_unique (GTK_TYPE_OBJECT, &client_info);
-    }
-
-  return client_type;
-}
-
-static void
-gconf_client_class_init (GConfClientClass *class)
-{
-  GtkObjectClass *object_class;
-
-  object_class = (GtkObjectClass*) class;
-
-  parent_class = gtk_type_class (gtk_object_get_type ());
-  
-  client_signals[VALUE_CHANGED] =
-    gtk_signal_new ("value_changed",
-                    GTK_RUN_LAST,
-                    object_class->type,
-                    GTK_SIGNAL_OFFSET (GConfClientClass, value_changed),
-                    gtk_marshal_NONE__POINTER_POINTER,
-                    GTK_TYPE_NONE, 2, GTK_TYPE_POINTER, GTK_TYPE_POINTER);
-  
-  client_signals[UNRETURNED_ERROR] =
-    gtk_signal_new ("unreturned_error",
-                    GTK_RUN_LAST,
-                    object_class->type,
-                    GTK_SIGNAL_OFFSET (GConfClientClass, unreturned_error),
-                    gtk_marshal_NONE__POINTER,
-                    GTK_TYPE_NONE, 1, GTK_TYPE_POINTER);
-
-  client_signals[ERROR] =
-    gtk_signal_new ("error",
-                    GTK_RUN_LAST,
-                    object_class->type,
-                    GTK_SIGNAL_OFFSET (GConfClientClass, error),
-                    gtk_marshal_NONE__POINTER,
-                    GTK_TYPE_NONE, 1, GTK_TYPE_POINTER);
-  
-  gtk_object_class_add_signals (object_class, client_signals, LAST_SIGNAL);
-
-  class->value_changed    = NULL;
-  class->unreturned_error = gconf_client_real_unreturned_error;
-  class->error            = gconf_client_real_error;
-  
-  object_class->finalize  = gconf_client_finalize;
-}
-
-static void
-gconf_client_init (GConfClient *client)
-{
-  client->engine = NULL;
-  client->error_mode = GCONF_CLIENT_HANDLE_UNRETURNED;
-  client->dir_hash = g_hash_table_new(g_str_hash, g_str_equal);
-  client->cache_hash = g_hash_table_new(g_str_hash, g_str_equal);
-  /* We create the listeners only if they're actually used */
-  client->listeners = NULL;
-}
-
-static gboolean
-destroy_dir_foreach_remove(gpointer key, gpointer value, gpointer user_data)
-{
-  GConfClient *client = user_data;
-  Dir* d = value;
-  
-  /* remove notify for this dir */
-  
-  if(d->notify_id != 0)
-	  gconf_engine_notify_remove(client->engine, d->notify_id);
-  d->notify_id = 0;
-
-  dir_destroy(value);
-
-  return TRUE;
-}
-
-static void
-gconf_client_finalize (GtkObject* object)
-{
-  GConfClient* client = GCONF_CLIENT(object);
-
-  g_hash_table_foreach_remove(client->dir_hash,
-                              destroy_dir_foreach_remove, client);
-  
-  gconf_client_clear_cache(client);
-  
-  if (client->listeners != NULL)
-    {
-      gconf_listeners_free(client->listeners);
-      client->listeners = NULL;
-    }
-
-  g_hash_table_destroy(client->dir_hash);
-  client->dir_hash = NULL;
-  
-  g_hash_table_destroy(client->cache_hash);
-  client->cache_hash = NULL;
-
-  unregister_client (client);
-  
-  if (client->engine != NULL)
-    {
-      gconf_engine_unref(client->engine);
-      client->engine = NULL;
-    }
-
-  if (parent_class->finalize)
-    (*parent_class->finalize)(object);
-}
-
-/*
- * Default error handlers
- */
-
-static void
-gconf_client_real_unreturned_error (GConfClient* client, GError* error)
-{
-  if (client->error_mode == GCONF_CLIENT_HANDLE_UNRETURNED)
-    {
-      if (global_error_handler != NULL)
-        {
-          (*global_error_handler) (client, error);
-        }
-      else
-        {
-          fprintf (stderr, _("GConf Error: %s\n"),
-                   error->message);
-        }
-    }
-}
-
-static void
-gconf_client_real_error            (GConfClient* client, GError* error)
-{
-  if (client->error_mode == GCONF_CLIENT_HANDLE_ALL)
-    {
-      if (global_error_handler != NULL)
-        {
-          (*global_error_handler) (client, error);
-        }
-      else
-        {
-          fprintf (stderr, _("GConf Error: %s\n"),
-                   error->message);
-        }
-    }
-}
-
-/* Emit the proper signals for the error, and fill in err */
-static gboolean
-handle_error(GConfClient* client, GError* error, GError** err)
-{
-  if (error != NULL)
-    {
-      gconf_client_error(client, error);
-      
-      if (err == NULL)
-        {
-          gconf_client_unreturned_error(client, error);
-
-          g_error_free(error);
-        }
-      else
-        *err = error;
-
-      return TRUE;
-    }
-  else
-    return FALSE;
-}
-
-struct client_and_val {
-  GConfClient* client;
-  GConfEntry* entry;
-};
-
-static void
-notify_listeners_callback(GConfListeners* listeners,
-                          const gchar* key,
-                          guint cnxn_id,
-                          gpointer listener_data,
-                          gpointer user_data)
-{
-  struct client_and_val* cav = user_data;
-  Listener* l = listener_data;
-  
-  g_return_if_fail(cav != NULL);
-  g_return_if_fail(cav->client != NULL);
-  g_return_if_fail(GCONF_IS_CLIENT(cav->client));
-  g_return_if_fail(l != NULL);
-  g_return_if_fail(l->func != NULL);
-
-  (*l->func)(cav->client, cnxn_id, cav->entry, l->data);
-}
-
-static void
-notify_from_server_callback(GConfEngine* conf, guint cnxn_id,
-                            GConfEntry *entry,
-                            gpointer user_data)
-{
-  GConfClient* client = user_data;
-
-  g_return_if_fail(client != NULL);
-  g_return_if_fail(GCONF_IS_CLIENT(client));
-  g_return_if_fail(client->engine == conf);
-
-  /* First do the caching, so that state is sane for the
-   * listeners or functions connected to value_changed.
-   * We know this key is under a directory in our dir list.
-   */
-  gconf_client_cache(client,
-                     entry->key,
-                     entry->is_default,
-                     entry->is_writable,
-                     entry->value ? gconf_value_copy(entry->value) : NULL);
-
-  /* Emit the value_changed signal before notifying specific listeners;
-   * I'm not sure there's a reason this matters though
-   */
-  gconf_client_value_changed(client,
-                             entry->key,
-                             entry->value);
-
-  /* Now notify our listeners, if any */
-  if (client->listeners != NULL)
-    {
-      struct client_and_val cav;
-
-      cav.client = client;
-      cav.entry = entry;
-      
-      gconf_listeners_notify(client->listeners,
-                             entry->key,
-                             notify_listeners_callback,
-                             &cav);
-    }
-}
-
-/*
- * Public API
- */
-
-GConfClient*
-gconf_client_get_default (void)
-{
-  GConfClient *client;
-  GConfEngine *engine;
-  
-  g_return_val_if_fail(gconf_is_initialized(), NULL);
-
-  engine = gconf_engine_get_default ();
-  
-  client = lookup_client (engine);
-  if (client)
-    {
-      g_assert (client->engine == engine);
-      gtk_object_ref (GTK_OBJECT (client));
-      gconf_engine_unref (engine);
-      return client;
-    }
-  else
-    {
-      client = gtk_type_new (gconf_client_get_type ());
-
-      /* Emulate GObject */
-      gtk_object_ref (GTK_OBJECT (client));
-      gtk_object_sink (GTK_OBJECT (client));
-
-      client->engine = engine;
-      register_client (client);
-    }
-  
-  return client;
-}
-
-GConfClient*
-gconf_client_get_for_engine (GConfEngine* engine)
-{
-  GConfClient *client;
-
-  g_return_val_if_fail(gconf_is_initialized(), NULL);
-
-  client = lookup_client (engine);
-  if (client)
-    {
-      g_assert (client->engine == engine);
-      gtk_object_ref (GTK_OBJECT (client));
-      return client;
-    }
-  else
-    {
-      client = gtk_type_new (gconf_client_get_type ());
-
-      /* Emulate GObject */
-      gtk_object_ref (GTK_OBJECT (client));
-      gtk_object_sink (GTK_OBJECT (client));
-      
-      client->engine = engine;
-
-      gconf_engine_ref(client->engine);
-
-      register_client (client);
-    }
-  
-  return client;
-}
-
-typedef struct {
-  GConfClient *client;
-  Dir *lower_dir;
-  const char *dirname;
-} OverlapData;
-
-static void
-foreach_setup_overlap(gpointer key, gpointer value, gpointer user_data)
-{
-  GConfClient *client;
-  Dir *dir = value;
-  OverlapData * od = user_data;
-
-  client = od->client;
-
-  /* if we have found the first (well there is only one anyway) directory
-   * that includes us that has a notify handler
-   */
-#ifdef GCONF_ENABLE_DEBUG
-  if (dir->notify_id != 0 &&
-      gconf_key_is_below(dir->name, od->dirname))
-    {
-      g_assert(od->lower_dir == NULL);
-      od->lower_dir = dir;
-    }
-#else
-  if (od->lower_dir == NULL &&
-      dir->notify_id != 0 &&
-      gconf_key_is_below(dir->name, od->dirname))
-      od->lower_dir = dir;
-#endif
-  /* if we have found a directory that we include and it has
-   * a notify_id, remove the notify handler now
-   * FIXME: this is a race, from now on we can miss notifies, it is
-   * not an incredible amount of time so this is not a showstopper */
-  else if (dir->notify_id != 0 &&
-           gconf_key_is_below (od->dirname, dir->name))
-    {
-      gconf_engine_notify_remove (client->engine, dir->notify_id);
-      dir->notify_id = 0;
-    }
-}
-
-static Dir *
-setup_overlaps(GConfClient* client, const gchar* dirname)
-{
-  OverlapData od;
-
-  od.client = client;
-  od.lower_dir = NULL;
-  od.dirname = dirname;
-
-  g_hash_table_foreach(client->dir_hash, foreach_setup_overlap, &od);
-
-  return od.lower_dir;
-}
-
-void
-gconf_client_add_dir     (GConfClient* client,
-                          const gchar* dirname,
-                          GConfClientPreloadType preload,
-                          GError** err)
-{
-  Dir* d;
-  guint notify_id = 0;
-  GError* error = NULL;
-
-  g_return_if_fail(gconf_valid_key(dirname, NULL));
-  
-  d = g_hash_table_lookup (client->dir_hash, dirname);
-
-  if (d == NULL)
-    {
-      Dir *overlap_dir;
-
-      overlap_dir = setup_overlaps (client, dirname);
-
-      /* only if there is no directory that includes us
-       * already add a notify
-       */
-      if (overlap_dir == NULL)
-        {
-
-          notify_id = gconf_engine_notify_add (client->engine,
-                                               dirname,
-                                               notify_from_server_callback,
-                                               client,
-                                               &error);
-      
-          /* We got a notify ID or we got an error, not both */
-          g_return_if_fail( (notify_id != 0 && error == NULL) ||
-                            (notify_id == 0 && error != NULL) );
-      
-      
-          if (handle_error(client, error, err))
-            return;
-
-          g_assert(error == NULL);
-        }
-      else
-        {
-          notify_id = 0;
-        }
-      
-      d = dir_new(dirname, notify_id);
-
-      g_hash_table_insert(client->dir_hash, d->name, d);
-
-      gconf_client_preload(client, dirname, preload, &error);
-
-      handle_error(client, error, err);
-    }
-
-  g_assert(d != NULL);
-
-  d->add_count += 1;
-}
-
-typedef struct {
-  GConfClient *client;
-  GError *error;
-} AddNotifiesData;
-
-static void
-foreach_add_notifies(gpointer key, gpointer value, gpointer user_data)
-{
-  AddNotifiesData *ad = user_data;
-  GConfClient *client;
-  Dir *dir = value;
-
-  client = ad->client;
-
-  if (ad->error != NULL)
-    return;
-
-  if (dir->notify_id == 0)
-    {
-      Dir *overlap_dir;
-      overlap_dir = setup_overlaps(client, dir->name);
-
-      /* only if there is no directory that includes us
-       * already add a notify */
-      if (overlap_dir == NULL)
-        {
-          dir->notify_id = gconf_engine_notify_add(client->engine,
-					    dir->name,
-					    notify_from_server_callback,
-					    client,
-					    &ad->error);
-
-          /* We got a notify ID or we got an error, not both */
-          g_return_if_fail( (dir->notify_id != 0 && ad->error == NULL) ||
-		            (dir->notify_id == 0 && ad->error != NULL) );
-
-          /* if error is returned, then we'll just ignore
-           * things until the end */
-        }
-    }
-}
-
-static void
-gconf_client_real_remove_dir    (GConfClient* client,
-                                 Dir* d,
-                                 GError** err)
-{
-  AddNotifiesData ad;
-
-  g_return_if_fail(d != NULL);
-  g_return_if_fail(d->add_count == 0);
-  
-  g_hash_table_remove(client->dir_hash, d->name);
-  
-  /* remove notify for this dir */
-  
-  if (d->notify_id != 0)
-    gconf_engine_notify_remove(client->engine, d->notify_id);
-  d->notify_id = 0;
-  
-  dir_destroy(d);
-
-  ad.client = client;
-  ad.error = NULL;
-
-  g_hash_table_foreach(client->dir_hash, foreach_add_notifies, &ad);
-
-  handle_error(client, ad.error, err);
-}
-
-void
-gconf_client_remove_dir  (GConfClient* client,
-                          const gchar* dirname,
-                          GError** err)
-{
-  Dir* found = NULL;
-
-  found = g_hash_table_lookup(client->dir_hash,
-                              dirname);
-  
-  if (found != NULL)
-    {
-      g_return_if_fail(found->add_count > 0);
-
-      found->add_count -= 1;
-
-      if (found->add_count == 0) 
-        gconf_client_real_remove_dir(client, found, err);
-    }
-#ifndef G_DISABLE_CHECKS
-  else
-    g_warning("Directory `%s' was not being monitored by GConfClient %p",
-              dirname, client);
-#endif
-}
-
-
-guint
-gconf_client_notify_add(GConfClient* client,
-                        const gchar* namespace_section,
-                        GConfClientNotifyFunc func,
-                        gpointer user_data,
-                        GFreeFunc destroy_notify,
-                        GError** err)
-{
-  guint cnxn_id = 0;
-  
-  g_return_val_if_fail(client != NULL, 0);
-  g_return_val_if_fail(GCONF_IS_CLIENT(client), 0);
-
-  if (client->listeners == NULL)
-    client->listeners = gconf_listeners_new();
-  
-  cnxn_id = gconf_listeners_add (client->listeners,
-                                 namespace_section,
-                                 listener_new (func, destroy_notify, user_data),
-                                 (GFreeFunc)listener_destroy);
-
-  return cnxn_id;
-}
-
-void
-gconf_client_notify_remove  (GConfClient* client,
-                             guint cnxn)
-{
-  g_return_if_fail(client != NULL);
-  g_return_if_fail(GCONF_IS_CLIENT(client));
-  g_return_if_fail(client->listeners != NULL);
-  
-  gconf_listeners_remove(client->listeners, cnxn);
-  
-  if (gconf_listeners_count(client->listeners) == 0)
-    {
-      gconf_listeners_free(client->listeners);
-      client->listeners = NULL;
-    }
-}
-
-void
-gconf_client_set_error_handling(GConfClient* client,
-                                GConfClientErrorHandlingMode mode)
-{
-  g_return_if_fail(client != NULL);
-  g_return_if_fail(GCONF_IS_CLIENT(client));
-
-  client->error_mode = mode;
-}
-
-static gboolean
-clear_cache_foreach(gchar* key, CacheEntry* ce, GConfClient* client)
-{
-  g_free(key);
-  cache_entry_destroy(ce);
-
-  return TRUE;
-}
-
-void
-gconf_client_clear_cache(GConfClient* client)
-{
-  g_return_if_fail(client != NULL);
-  g_return_if_fail(GCONF_IS_CLIENT(client));
-  
-  g_hash_table_foreach_remove(client->cache_hash, (GHRFunc)clear_cache_foreach,
-                              client);
-
-  g_assert(g_hash_table_size(client->cache_hash) == 0);
-}
-
-static void
-cache_pairs_in_dir(GConfClient* client, const gchar* path);
-
-static void 
-recurse_subdir_list(GConfClient* client, GSList* subdirs, const gchar* parent)
-{
-  GSList* tmp;
-
-  tmp = subdirs;
-  
-  while (tmp != NULL)
-    {
-      gchar* s = tmp->data;
-      gchar* full = gconf_concat_dir_and_key(parent, s);
-      
-      cache_pairs_in_dir(client, full);
-
-      recurse_subdir_list(client, gconf_engine_all_dirs(client->engine, full, NULL), full);
-
-      g_free(s);
-      g_free(full);
-      
-      tmp = g_slist_next(tmp);
-    }
-  
-  g_slist_free(subdirs);
-}
-
-static void 
-cache_pairs_in_dir(GConfClient* client, const gchar* dir)
-{
-  GSList* pairs;
-  GSList* tmp;
-  GError* error = NULL;
-
-  pairs = gconf_engine_all_entries(client->engine, dir, &error);
-          
-  if (error != NULL)
-    {
-      fprintf(stderr, _("GConf warning: failure listing pairs in `%s': %s"),
-              dir, error->message);
-      g_error_free(error);
-      error = NULL;
-    }
-
-  if (pairs != NULL)
-    {
-      tmp = pairs;
-
-      while (tmp != NULL)
-        {
-          GConfEntry* pair = tmp->data;
-          
-          gconf_client_cache(client,
-                             gconf_entry_get_key (pair),
-                             gconf_entry_get_is_default(pair),
-                             gconf_entry_get_is_writable(pair),
-                             gconf_entry_steal_value(pair));
-
-          gconf_entry_free(pair);
-
-          tmp = g_slist_next(tmp);
-        }
-
-      g_slist_free(pairs);
-    }
-}
-
-void
-gconf_client_preload    (GConfClient* client,
-                         const gchar* dirname,
-                         GConfClientPreloadType type,
-                         GError** err)
-{
-
-  g_return_if_fail(client != NULL);
-  g_return_if_fail(GCONF_IS_CLIENT(client));
-  g_return_if_fail(dirname != NULL);
-
-#ifdef GCONF_ENABLE_DEBUG
-  if (g_hash_table_lookup(client->dir_hash, dirname) == NULL)
-    {
-      g_warning("Can only preload directories you've added with gconf_client_add_dir()");
-      return;
-    }
-#endif
-  
-  switch (type)
-    {
-    case GCONF_CLIENT_PRELOAD_NONE:
-      /* nothing */
-      break;
-
-    case GCONF_CLIENT_PRELOAD_ONELEVEL:
-      {
-        GSList* subdirs;
-        
-        subdirs = gconf_engine_all_dirs(client->engine, dirname, NULL);
-        
-        cache_pairs_in_dir(client, dirname);
-      }
-      break;
-
-    case GCONF_CLIENT_PRELOAD_RECURSIVE:
-      {
-        GSList* subdirs;
-        
-        subdirs = gconf_engine_all_dirs(client->engine, dirname, NULL);
-        
-        cache_pairs_in_dir(client, dirname);
-          
-        recurse_subdir_list(client, subdirs, dirname);
-      }
-      break;
-
-    default:
-      g_assert_not_reached();
-      break;
-    }
-}
-
-/*
- * Basic key-manipulation facilities
- */
-
-void
-gconf_client_set             (GConfClient* client,
-                              const gchar* key,
-                              GConfValue* val,
-                              GError** err)
-{
-  GError* error = NULL;
-  
-  gconf_engine_set (client->engine, key, val, &error);
-
-  handle_error(client, error, err);
-}
-
-gboolean
-gconf_client_unset          (GConfClient* client,
-                             const gchar* key, GError** err)
-{
-  GError* error = NULL;
-  
-  gconf_engine_unset(client->engine, key, &error);
-
-  handle_error(client, error, err);
-
-  if (error != NULL)
-    return FALSE;
-  else
-    return TRUE;
-}
-
-GSList*
-gconf_client_all_entries    (GConfClient* client,
-                             const gchar* dir, GError** err)
-{
-  GError* error = NULL;
-  GSList* retval;
-  
-  retval = gconf_engine_all_entries(client->engine, dir, &error);
-
-  handle_error(client, error, err);
-
-  return retval;
-}
-
-GSList*
-gconf_client_all_dirs       (GConfClient* client,
-                             const gchar* dir, GError** err)
-{
-  GError* error = NULL;
-  GSList* retval;
-  
-  retval = gconf_engine_all_dirs(client->engine, dir, &error);
-
-  handle_error(client, error, err);
-
-  return retval;
-}
-
-void
-gconf_client_suggest_sync   (GConfClient* client,
-                             GError** err)
-{
-  GError* error = NULL;
-  
-  gconf_engine_suggest_sync(client->engine, &error);
-
-  handle_error(client, error, err);
-}
-
-gboolean
-gconf_client_dir_exists     (GConfClient* client,
-                             const gchar* dir, GError** err)
-{
-  GError* error = NULL;
-  gboolean retval;
-  
-  retval = gconf_engine_dir_exists(client->engine, dir, &error);
-
-  handle_error(client, error, err);
-
-  return retval;
-}
-
-gboolean
-gconf_client_key_is_writable(GConfClient* client,
-                             const gchar* key,
-                             GError**     err)
-{
-  GError* error = NULL;
-  GConfValue* val = NULL;
-  gboolean is_writable = TRUE;
-  
-  g_return_val_if_fail(err == NULL || *err == NULL, FALSE);
-  
-  val = get (client, key, TRUE,
-             NULL, &is_writable, &error);
-
-  if (val == NULL && error != NULL)
-    handle_error(client, error, err);
-  else
-    g_assert(error == NULL);
-
-  /* FIXME we could avoid creating this value at all if
-   * we were somewhat less lame.
-   */
-  if (val)
-    gconf_value_free (val);
-  
-  return is_writable;
-}
-
-static gboolean
-check_type(const gchar* key, GConfValue* val, GConfValueType t, GError** err)
-{
-  if (val->type != t)
-    {
-      gconf_set_error(err, GCONF_ERROR_TYPE_MISMATCH,
-                      _("Expected `%s' got `%s' for key %s"),
-                      gconf_value_type_to_string(t),
-                      gconf_value_type_to_string(val->type),
-                      key);
-      return FALSE;
-    }
-  else
-    return TRUE;
-}
-
-static GConfValue*
-get (GConfClient *client,
-     const gchar *key,
-     gboolean     use_default,
-     gboolean    *is_default_retloc,
-     gboolean    *is_writable_retloc,
-     GError     **error)
-{
-  GConfValue* val = NULL;
-  gboolean is_default = FALSE;
-  gboolean is_writable = TRUE;
-  
-  g_return_val_if_fail(client != NULL, NULL);
-  g_return_val_if_fail(GCONF_IS_CLIENT(client), NULL);
-  g_return_val_if_fail(error != NULL, NULL);
-  g_return_val_if_fail(*error == NULL, NULL);
-  
-  /* Check our client-side cache */
-  if (gconf_client_lookup(client, key, use_default,
-                          &is_default,
-                          &is_writable,
-                          &val))
-    {
-      if (is_default_retloc)
-        *is_default_retloc = is_default;
-
-      if (is_writable_retloc)
-        *is_writable_retloc = is_writable;
-      
-      /* may be NULL of course */
-      return val ? gconf_value_copy (val) : NULL;
-    }
-      
-  g_assert(val == NULL); /* if it was in the cache we should have returned */
-
-  /* Check the GConfEngine */
-  val = gconf_engine_get_full(client->engine, key,
-                              gconf_current_locale(),
-                              use_default, &is_default, &is_writable,
-                              error);
-
-  if (is_default_retloc)
-    *is_default_retloc = is_default;
-
-  if (is_writable_retloc)
-    *is_writable_retloc = is_writable;
-  
-  if (*error != NULL)
-    {
-      g_return_val_if_fail(val == NULL, NULL);
-      return NULL;
-    }
-  else
-    {
-      /* Cache this value, if it's in our directory list. FIXME could
-       * speed this up.
-       */
-      gchar* parent = g_strdup(key);
-      gchar* end;
-
-      end = strrchr(parent, '/');
-
-      while (end && parent != end)
-        {
-          *end = '\0';
-          
-          if (g_hash_table_lookup(client->dir_hash, parent) != NULL)
-            {
-              /* cache a copy of val */
-              gconf_client_cache (client, key, is_default, is_writable,
-                                  val ? gconf_value_copy (val) : NULL);
-              break;
-            }
-          
-          end = strrchr(parent, '/');
-        }
-
-      g_free(parent);
-
-      /* We don't own val, we're returning this copy belonging
-       * to the caller
-       */
-      return val;
-    }
-}
-     
-static GConfValue*
-gconf_client_get_full        (GConfClient* client,
-                              const gchar* key, const gchar* locale,
-                              gboolean use_schema_default,
-                              gboolean* value_is_default,
-                              gboolean* value_is_writable,
-                              GError** err)
-{
-  GError* error = NULL;
-  GConfValue* val = NULL;
-  gboolean is_default = FALSE;
-  gboolean is_writable = TRUE;
-  
-  g_return_val_if_fail(err == NULL || *err == NULL, NULL);
-
-  if (locale != NULL)
-    g_warning("haven't implemented getting a specific locale in GConfClient");
-  
-  val = get(client, key, use_schema_default,
-            &is_default, &is_writable, &error);
-
-  if (val == NULL && error != NULL)
-    handle_error(client, error, err);
-  else
-    g_assert(error == NULL);
-
-
-  if (value_is_default)
-    *value_is_default = is_default;
-
-  if (value_is_writable)
-    *value_is_writable = is_writable;
-
-  return val;
-}
-
-GConfEntry*
-gconf_client_get_entry (GConfClient* client,
-                        const gchar* key,
-                        const gchar* locale,
-                        gboolean use_schema_default,
-                        GError** err)
-{
-  GError* error = NULL;
-  GConfValue* val = NULL;
-  gboolean is_default = FALSE;
-  gboolean is_writable = TRUE;
-  GConfEntry *entry;
-  
-  g_return_val_if_fail(err == NULL || *err == NULL, NULL);
-
-  if (locale != NULL)
-    g_warning("haven't implemented getting a specific locale in GConfClient");
-  
-  val = get(client, key, use_schema_default,
-            &is_default, &is_writable, &error);
-
-  if (val == NULL && error != NULL)
-    handle_error(client, error, err);
-  else
-    g_assert(error == NULL);
-
-  entry = gconf_entry_new_nocopy (g_strdup (key), val);
-  entry->is_default = is_default;
-  entry->is_writable = is_writable;
-  
-  return entry;
-}
-
-GConfValue*
-gconf_client_get             (GConfClient* client,
-                              const gchar* key,
-                              GError** err)
-{
-  return gconf_client_get_full(client, key, NULL, TRUE, NULL, NULL, err);
-}
-
-GConfValue*
-gconf_client_get_without_default  (GConfClient* client,
-                                   const gchar* key,
-                                   GError** err)
-{
-  return gconf_client_get_full(client, key, NULL, FALSE, NULL, NULL, err);
-}
-
-GConfValue*
-gconf_client_get_default_from_schema (GConfClient* client,
-                                      const gchar* key,
-                                      GError** err)
-{
-  GError* error = NULL;
-  GConfValue* val = NULL;
-  gboolean is_default = FALSE;
-  
-  g_return_val_if_fail(err == NULL || *err == NULL, NULL);  
-  g_return_val_if_fail(client != NULL, NULL);
-  g_return_val_if_fail(GCONF_IS_CLIENT(client), NULL);
-  
-  /* Check our client-side cache to see if the default is the same as
-   the regular value (FIXME put a default_value field in the
-   CacheEntry and store both, lose the is_default flag in CacheEntry) */
-  if (gconf_client_lookup(client, key, TRUE,
-                          &is_default,
-                          NULL,
-                          &val))
-    {        
-      if (is_default)
-        return val ? gconf_value_copy(val) : NULL;
-    }
-
-  /* Check the GConfEngine */
-  val = gconf_engine_get_default_from_schema(client->engine, key,
-                                             &error);
-  
-  if (error != NULL)
-    {
-      g_assert(val == NULL);
-      handle_error(client, error, err);
-      return NULL;
-    }
-  else
-    {
-      /* FIXME eventually we'll cache the value
-         by adding a field to CacheEntry */
-      return val;
-    }
-}
-
-gdouble
-gconf_client_get_float (GConfClient* client, const gchar* key,
-                        GError** err)
-{
-  static const gdouble def = 0.0;
-  GError* error = NULL;
-  GConfValue* val;
-
-  g_return_val_if_fail(err == NULL || *err == NULL, 0.0);
-  
-  val = get(client, key, TRUE, NULL, NULL, &error);
-
-  if (val != NULL)
-    {
-      gdouble retval = def;
-
-      g_assert(error == NULL);
-      
-      if (check_type(key, val, GCONF_VALUE_FLOAT, &error))
-        retval = gconf_value_get_float(val);
-      else
-        handle_error(client, error, err);
-
-      gconf_value_free(val);
-
-      return retval;
-    }
-  else
-    {
-      if (error != NULL)
-        handle_error(client, error, err);
-      return def;
-    }
-}
-
-gint
-gconf_client_get_int   (GConfClient* client, const gchar* key,
-                        GError** err)
-{
-  static const gint def = 0;
-  GError* error = NULL;
-  GConfValue* val;
-
-  g_return_val_if_fail(err == NULL || *err == NULL, 0);
-
-  val = get(client, key, TRUE, NULL, NULL, &error);
-
-  if (val != NULL)
-    {
-      gint retval = def;
-
-      g_assert(error == NULL);
-      
-      if (check_type(key, val, GCONF_VALUE_INT, &error))
-        retval = gconf_value_get_int(val);
-      else
-        handle_error(client, error, err);
-
-      gconf_value_free(val);
-
-      return retval;
-    }
-  else
-    {
-      if (error != NULL)
-        handle_error(client, error, err);
-      return def;
-    }
-}
-
-gchar*
-gconf_client_get_string(GConfClient* client, const gchar* key,
-                        GError** err)
-{
-  static const gchar* def = NULL;
-  GError* error = NULL;
-  GConfValue* val;
-
-  g_return_val_if_fail(err == NULL || *err == NULL, NULL);
-  
-  val = get(client, key, TRUE, NULL, NULL, &error);
-
-  if (val != NULL)
-    {
-      gchar* retval = NULL;
-
-      g_assert(error == NULL);
-      
-      if (check_type(key, val, GCONF_VALUE_STRING, &error))
-	/* we cheat here (look below) so we have to cast this */
-        retval = (gchar *)gconf_value_get_string(val);
-      else
-        handle_error(client, error, err);
-
-      /* This is a cheat; don't copy */
-      if (retval != NULL)
-        val->d.string_data = NULL; /* don't delete the string we are returning */
-      else
-        retval = def ? g_strdup(def) : NULL;
-      
-      gconf_value_free(val);
-
-      return retval;
-    }
-  else
-    {
-      if (error != NULL)
-        handle_error(client, error, err);
-      return def ? g_strdup(def) : NULL;
-    }
-}
-
-
-gboolean
-gconf_client_get_bool  (GConfClient* client, const gchar* key,
-                        GError** err)
-{
-  static const gboolean def = FALSE;
-  GError* error = NULL;
-  GConfValue* val;
-
-  g_return_val_if_fail(err == NULL || *err == NULL, FALSE);
-
-  val = get(client, key, TRUE, NULL, NULL, &error);  
-
-  if (val != NULL)
-    {
-      gboolean retval = def;
-
-      g_assert(error == NULL);
-      
-      if (check_type(key, val, GCONF_VALUE_BOOL, &error))
-        retval = gconf_value_get_bool(val);
-      else
-        handle_error(client, error, err);
-
-      gconf_value_free(val);
-
-      return retval;
-    }
-  else
-    {
-      if (error != NULL)
-        handle_error(client, error, err);
-      return def;
-    }
-}
-
-GConfSchema*
-gconf_client_get_schema  (GConfClient* client,
-                          const gchar* key, GError** err)
-{
-  GError* error = NULL;
-  GConfValue* val;
-
-  g_return_val_if_fail(err == NULL || *err == NULL, NULL);
-
-  val = get(client, key, TRUE, NULL, NULL, &error);
-
-  if (val != NULL)
-    {
-      GConfSchema* retval = NULL;
-
-      g_assert(error == NULL);
-      
-      if (check_type(key, val, GCONF_VALUE_SCHEMA, &error))
-        retval = gconf_value_get_schema(val);
-      else
-        handle_error(client, error, err);
-
-      /* This is a cheat; don't copy */
-      if (retval != NULL)
-        val->d.schema_data = NULL; /* don't delete the schema */
-      
-      gconf_value_free(val);
-
-      return retval;
-    }
-  else
-    {
-      if (error != NULL)
-        handle_error(client, error, err);
-      return NULL;
-    }
-}
-
-GSList*
-gconf_client_get_list    (GConfClient* client, const gchar* key,
-                          GConfValueType list_type, GError** err)
-{
-  GError* error = NULL;
-  GConfValue* val;
-
-  g_return_val_if_fail(err == NULL || *err == NULL, NULL);
-
-  val = get(client, key, TRUE, NULL, NULL, &error);
-
-  if (val != NULL)
-    {
-      GSList* retval;
-
-      g_assert(error == NULL);
-
-      /* This function checks the type and destroys "val" */
-      retval = gconf_value_list_to_primitive_list_destructive(val, list_type, &error);
-
-      if (error != NULL)
-        {
-          g_assert(retval == NULL);
-          handle_error(client, error, err);
-          return NULL;
-        }
-      else
-        return retval;
-    }
-  else
-    {
-      if (error != NULL)
-        handle_error(client, error, err);
-      return NULL;
-    }
-}
-
-gboolean
-gconf_client_get_pair    (GConfClient* client, const gchar* key,
-                          GConfValueType car_type, GConfValueType cdr_type,
-                          gpointer car_retloc, gpointer cdr_retloc,
-                          GError** err)
-{
-  GError* error = NULL;
-  GConfValue* val;
-
-  g_return_val_if_fail(err == NULL || *err == NULL, FALSE);
-
-  val = get(client, key, TRUE, NULL, NULL, &error);  
-
-  if (val != NULL)
-    {
-      g_assert(error == NULL);
-
-      /* This function checks the type and destroys "val" */
-      if (gconf_value_pair_to_primitive_pair_destructive(val, car_type, cdr_type,
-                                                         car_retloc, cdr_retloc,
-                                                         &error))
-        {
-          g_assert(error == NULL);
-          return TRUE;
-        }
-      else
-        {
-          g_assert(error != NULL);
-          handle_error(client, error, err);
-          return FALSE;
-        }
-    }
-  else
-    {
-      if (error != NULL)
-        {
-          handle_error(client, error, err);
-          return FALSE;
-        }
-      else
-        return TRUE;
-    }
-
-}
-
-
-/*
- * For the set functions, we just set normally, and wait for the
- * notification to come back from the server before we update
- * our cache. This may be the wrong thing; maybe we should
- * update immediately?
- * Problem with delayed update: user calls set() then get(),
- *  results in weirdness
- * Problem with with regular update: get() before the notify
- *  is out of sync with the listening parts of the application
- * 
- * It is somewhat academic now anyway because the _set() call
- * won't return until all the notifications have happened, so the
- * notify signal will be emitted inside the set() call.
- */
-
-gboolean
-gconf_client_set_float   (GConfClient* client, const gchar* key,
-                          gdouble val, GError** err)
-{
-  GError* error = NULL;
-  
-  g_return_val_if_fail(client != NULL, FALSE);
-  g_return_val_if_fail(GCONF_IS_CLIENT(client), FALSE);  
-  g_return_val_if_fail(key != NULL, FALSE);
-  
-  if (gconf_engine_set_float(client->engine, key, val, &error))
-    return TRUE;
-  else
-    {
-      handle_error(client, error, err);
-      return FALSE;
-    }
-}
-
-gboolean
-gconf_client_set_int     (GConfClient* client, const gchar* key,
-                          gint val, GError** err)
-{
-  GError* error = NULL;
-  
-  g_return_val_if_fail(client != NULL, FALSE);
-  g_return_val_if_fail(GCONF_IS_CLIENT(client), FALSE);  
-  g_return_val_if_fail(key != NULL, FALSE);
-  
-  if (gconf_engine_set_int(client->engine, key, val, &error))
-    return TRUE;
-  else
-    {
-      handle_error(client, error, err);
-      return FALSE;
-    }
-}
-
-gboolean
-gconf_client_set_string  (GConfClient* client, const gchar* key,
-                          const gchar* val, GError** err)
-{
-  GError* error = NULL;
-  
-  g_return_val_if_fail(client != NULL, FALSE);
-  g_return_val_if_fail(GCONF_IS_CLIENT(client), FALSE);  
-  g_return_val_if_fail(key != NULL, FALSE);
-  g_return_val_if_fail(val != NULL, FALSE);
-  
-  if (gconf_engine_set_string(client->engine, key, val, &error))
-    return TRUE;
-  else
-    {
-      handle_error(client, error, err);
-      return FALSE;
-    }
-}
-
-gboolean
-gconf_client_set_bool    (GConfClient* client, const gchar* key,
-                          gboolean val, GError** err)
-{
-  GError* error = NULL;
-  
-  g_return_val_if_fail(client != NULL, FALSE);
-  g_return_val_if_fail(GCONF_IS_CLIENT(client), FALSE);  
-  g_return_val_if_fail(key != NULL, FALSE);
-  
-  if (gconf_engine_set_bool(client->engine, key, val, &error))
-    return TRUE;
-  else
-    {
-      handle_error(client, error, err);
-      return FALSE;
-    }
-}
-
-gboolean
-gconf_client_set_schema  (GConfClient* client, const gchar* key,
-                          GConfSchema* val, GError** err)
-{
-  GError* error = NULL;
-  
-  g_return_val_if_fail(client != NULL, FALSE);
-  g_return_val_if_fail(GCONF_IS_CLIENT(client), FALSE);  
-  g_return_val_if_fail(key != NULL, FALSE);
-  g_return_val_if_fail(val != NULL, FALSE);
-  
-  if (gconf_engine_set_schema(client->engine, key, val, &error))
-    return TRUE;
-  else
-    {
-      handle_error(client, error, err);
-      return FALSE;
-    }
-}
-
-gboolean
-gconf_client_set_list    (GConfClient* client, const gchar* key,
-                          GConfValueType list_type,
-                          GSList* list,
-                          GError** err)
-{
-  GError* error = NULL;
-  
-  g_return_val_if_fail(client != NULL, FALSE);
-  g_return_val_if_fail(GCONF_IS_CLIENT(client), FALSE);  
-  g_return_val_if_fail(key != NULL, FALSE);
-  
-  if (gconf_engine_set_list(client->engine, key, list_type, list, &error))
-    return TRUE;
-  else
-    {
-      handle_error(client, error, err);
-      return FALSE;
-    }
-}
-
-gboolean
-gconf_client_set_pair    (GConfClient* client, const gchar* key,
-                          GConfValueType car_type, GConfValueType cdr_type,
-                          gconstpointer address_of_car,
-                          gconstpointer address_of_cdr,
-                          GError** err)
-{
-  GError* error = NULL;
-  
-  g_return_val_if_fail(client != NULL, FALSE);
-  g_return_val_if_fail(GCONF_IS_CLIENT(client), FALSE);  
-  g_return_val_if_fail(key != NULL, FALSE);
-  
-  if (gconf_engine_set_pair(client->engine, key, car_type, cdr_type,
-                     address_of_car, address_of_cdr, &error))
-    return TRUE;
-  else
-    {
-      handle_error(client, error, err);
-      return FALSE;
-    }
-}
-
-
-/*
- * Functions to emit signals
- */
-
-void
-gconf_client_error                  (GConfClient* client, GError* error)
-{
-  g_return_if_fail(client != NULL);
-  g_return_if_fail(GCONF_IS_CLIENT(client));
-  
-  gtk_signal_emit(GTK_OBJECT(client), client_signals[ERROR], error);
-}
-
-void
-gconf_client_unreturned_error       (GConfClient* client, GError* error)
-{
-  g_return_if_fail(client != NULL);
-  g_return_if_fail(GCONF_IS_CLIENT(client));
-
-  gtk_signal_emit(GTK_OBJECT(client), client_signals[UNRETURNED_ERROR], error);
-}
-
-void
-gconf_client_value_changed          (GConfClient* client,
-                                     const gchar* key,
-                                     GConfValue* value)
-{
-  g_return_if_fail(client != NULL);
-  g_return_if_fail(GCONF_IS_CLIENT(client));
-  g_return_if_fail(key != NULL);
-  
-  gtk_signal_emit(GTK_OBJECT(client), client_signals[VALUE_CHANGED],
-                  key, value);
-}
-
-/*
- * Internal utility
- */
-
-static void
-gconf_client_cache (GConfClient* client,
-                    const gchar* key,
-                    gboolean is_default,
-                    gboolean is_writable,
-                    GConfValue* value)
-{
-  /* Remember: value may be NULL */
-  
-  gpointer oldkey = NULL, oldval = NULL;
-
-  if (g_hash_table_lookup_extended(client->cache_hash, key, &oldkey, &oldval))
-    {
-      /* Already have a value, update it */
-      CacheEntry* ce = oldval;
-
-      g_assert(ce != NULL);
-
-      if (ce->value != NULL)
-        gconf_value_free(ce->value);
-
-      ce->value = value;
-      ce->is_default = is_default;
-      ce->is_writable = is_writable;
-    }
-  else
-    {
-      /* Create a new entry */
-      CacheEntry* ce = cache_entry_new(value, is_default, is_writable);
-      g_hash_table_insert(client->cache_hash, g_strdup(key), ce);
-    }
-}
-
-static gboolean
-gconf_client_lookup         (GConfClient* client,
-                             const gchar* key,
-                             gboolean use_default,
-                             gboolean* is_default,
-                             gboolean* is_writable,
-                             GConfValue** valp)
-{
-  CacheEntry* ce;
-
-  g_return_val_if_fail(valp != NULL, FALSE);
-  g_return_val_if_fail(*valp == NULL, FALSE);
-  
-  ce = g_hash_table_lookup(client->cache_hash, key);
-
-  if (ce != NULL)
-    {
-      if (ce->is_default)
-        {
-          *is_default = TRUE;
-          
-          if (use_default)
-            *valp = ce->value;            
-          else
-            *valp = NULL;
-        }
-      else
-        {
-          *is_default = FALSE;
-
-          *valp = ce->value;
-        }
-
-      if (is_writable)
-        *is_writable = ce->is_writable;
-      
-      return TRUE;
-    }
-  else
-    return FALSE;
-}
-
-
-/*
- * CacheEntry
- */ 
-
-static CacheEntry*
-cache_entry_new(GConfValue* val,
-                gboolean is_default, gboolean is_writable)
-{
-  CacheEntry* ce;
-
-  ce = g_new(CacheEntry, 1);
-
-  /* val may be NULL */
-  ce->value = val;
-  ce->is_default = is_default;
-  ce->is_writable = is_writable;
-  
-  return ce;
-}
-
-static void
-cache_entry_destroy(CacheEntry* ce)
-{
-  g_return_if_fail(ce != NULL);
-  
-  if (ce->value != NULL)
-    gconf_value_free(ce->value);
-
-  g_free(ce);
-}
-
-/*
- * Dir
- */
-
-static Dir*
-dir_new(const gchar* name, guint notify_id)
-{
-  Dir* d;
-
-  d = g_new(Dir, 1);
-
-  d->name = g_strdup(name);
-  d->notify_id = notify_id;
-  d->add_count = 0;
-  
-  return d;
-}
-
-static void
-dir_destroy(Dir* d)
-{
-  g_return_if_fail(d != NULL);
-  g_return_if_fail(d->notify_id == 0);
-  
-  g_free(d->name);
-  g_free(d);
-}
-
-/*
- * Listener
- */
-
-static Listener* 
-listener_new(GConfClientNotifyFunc func,
-             GFreeFunc destroy_notify,
-             gpointer data)
-{
-  Listener* l;
-
-  l = g_new(Listener, 1);
-
-  l->func = func;
-  l->data = data;
-  l->destroy_notify = destroy_notify;
-  
-  return l;
-}
-
-static void
-listener_destroy(Listener* l)
-{
-  g_return_if_fail(l != NULL);
-
-  if (l->destroy_notify)
-    (* l->destroy_notify) (l->data);
-  
-  g_free(l);
-}
-
-/*
- * Change sets
- */
-
-
-struct CommitData {
-  GConfClient* client;
-  GError* error;
-  GSList* remove_list;
-  gboolean remove_committed;
-};
-
-static void
-commit_foreach (GConfChangeSet* cs,
-                const gchar* key,
-                GConfValue* value,
-                gpointer user_data)
-{
-  struct CommitData* cd = user_data;
-
-  g_assert(cd != NULL);
-
-  if (cd->error != NULL)
-    return;
-  
-  if (value)
-    gconf_client_set   (cd->client, key, value, &cd->error);
-  else
-    gconf_client_unset (cd->client, key, &cd->error);
-
-  if (cd->error == NULL && cd->remove_committed)
-    {
-      /* Bad bad bad; we keep the key reference, knowing that it's
-         valid until we modify the change set, to avoid string copies.  */
-      cd->remove_list = g_slist_prepend(cd->remove_list, (gchar*)key);
-    }
-}
-
-gboolean
-gconf_client_commit_change_set   (GConfClient* client,
-                                  GConfChangeSet* cs,
-                                  gboolean remove_committed,
-                                  GError** err)
-{
-  struct CommitData cd;
-  GSList* tmp;
-
-  g_return_val_if_fail(client != NULL, FALSE);
-  g_return_val_if_fail(GCONF_IS_CLIENT(client), FALSE);
-  g_return_val_if_fail(cs != NULL, FALSE);
-  g_return_val_if_fail(err == NULL || *err == NULL, FALSE);
-  
-  cd.client = client;
-  cd.error = NULL;
-  cd.remove_list = NULL;
-  cd.remove_committed = remove_committed;
-
-  /* Because the commit could have lots of side
-     effects, this makes it safer */
-  gconf_change_set_ref(cs);
-  gtk_object_ref(GTK_OBJECT(client));
-  
-  gconf_change_set_foreach(cs, commit_foreach, &cd);
-
-  tmp = cd.remove_list;
-  while (tmp != NULL)
-    {
-      const gchar* key = tmp->data;
-      
-      gconf_change_set_remove(cs, key);
-
-      /* key is now invalid due to our little evil trick */
-
-      tmp = g_slist_next(tmp);
-    }
-
-  g_slist_free(cd.remove_list);
-  
-  gconf_change_set_unref(cs);
-  gtk_object_unref(GTK_OBJECT(client));
-
-  if (cd.error != NULL)
-    {
-      if (err != NULL)
-        *err = cd.error;
-      else
-        g_error_free(cd.error);
-
-      return FALSE;
-    }
-  else
-    {
-      g_assert((!remove_committed) ||
-               (gconf_change_set_size(cs) == 0));
-      
-      return TRUE;
-    }
-}
-
-struct RevertData {
-  GConfClient* client;
-  GError* error;
-  GConfChangeSet* revert_set;
-};
-
-static void
-revert_foreach (GConfChangeSet* cs,
-                const gchar* key,
-                GConfValue* value,
-                gpointer user_data)
-{
-  struct RevertData* rd = user_data;
-  GConfValue* old_value;
-  GError* error = NULL;
-  
-  g_assert(rd != NULL);
-
-  if (rd->error != NULL)
-    return;
-
-  old_value = gconf_client_get_without_default(rd->client, key, &error);
-
-  if (error != NULL)
-    {
-      /* FIXME */
-      g_warning("error creating revert set: %s", error->message);
-      g_error_free(error);
-      error = NULL;
-    }
-  
-  if (old_value == NULL &&
-      value == NULL)
-    return; /* this commit will have no effect. */
-
-  if (old_value == NULL)
-    gconf_change_set_unset(rd->revert_set, key);
-  else
-    gconf_change_set_set_nocopy(rd->revert_set, key, old_value);
-}
-
-
-GConfChangeSet*
-gconf_client_reverse_change_set  (GConfClient* client,
-                                         GConfChangeSet* cs,
-                                         GError** err)
-{
-  struct RevertData rd;
-
-  rd.error = NULL;
-  rd.client = client;
-  rd.revert_set = gconf_change_set_new();
-
-  /* we're emitting signals and such, avoid
-     nasty side effects with these.
-  */
-  gtk_object_ref(GTK_OBJECT(rd.client));
-  gconf_change_set_ref(cs);
-  
-  gconf_change_set_foreach(cs, revert_foreach, &rd);
-
-  if (rd.error != NULL)
-    {
-      if (err != NULL)
-        *err = rd.error;
-      else
-        g_error_free(rd.error);
-    }
-
-  gtk_object_unref(GTK_OBJECT(rd.client));
-  gconf_change_set_unref(cs);
-  
-  return rd.revert_set;
-}
-
-
-GConfChangeSet*
-gconf_client_change_set_from_currentv (GConfClient* client,
-                                              const gchar** keys,
-                                              GError** err)
-{
-  GConfValue* old_value;
-  GConfChangeSet* new_set;
-  const gchar** keyp;
-  
-  g_return_val_if_fail(err == NULL || *err == NULL, NULL);
-
-  new_set = gconf_change_set_new();
-  
-  keyp = keys;
-
-  while (*keyp != NULL)
-    {
-      GError* error = NULL;
-      const gchar* key = *keyp;
-      
-      old_value = gconf_client_get_without_default(client, key, &error);
-
-      if (error != NULL)
-        {
-          /* FIXME */
-          g_warning("error creating change set from current keys: %s", error->message);
-          g_error_free(error);
-          error = NULL;
-        }
-      
-      if (old_value == NULL)
-        gconf_change_set_unset(new_set, key);
-      else
-        gconf_change_set_set_nocopy(new_set, key, old_value);
-
-      ++keyp;
-    }
-
-  return new_set;
-}
-
-GConfChangeSet*
-gconf_client_change_set_from_current (GConfClient* client,
-                                             GError** err,
-                                             const gchar* first_key,
-                                             ...)
-{
-  GSList* keys = NULL;
-  va_list args;
-  const gchar* arg;
-  const gchar** vec;
-  GConfChangeSet* retval;
-  GSList* tmp;
-  guint i;
-  
-  g_return_val_if_fail(err == NULL || *err == NULL, NULL);
-
-  va_start (args, first_key);
-
-  arg = first_key;
-
-  while (arg != NULL)
-    {
-      keys = g_slist_prepend(keys, (/*non-const*/gchar*)arg);
-
-      arg = va_arg (args, const gchar*);
-    }
-  
-  va_end (args);
-
-  vec = g_new0(const gchar*, g_slist_length(keys) + 1);
-
-  i = 0;
-  tmp = keys;
-
-  while (tmp != NULL)
-    {
-      vec[i] = tmp->data;
-      
-      ++i;
-      tmp = g_slist_next(tmp);
-    }
-
-  g_slist_free(keys);
-  
-  retval = gconf_client_change_set_from_currentv(client, vec, err);
-  
-  g_free(vec);
-
-  return retval;
-}
-
-static GHashTable * clients = NULL;
-
-static void
-register_client (GConfClient *client)
-{
-  if (clients == NULL)
-    clients = g_hash_table_new (NULL, NULL);
-
-  g_hash_table_insert (clients, client->engine, client);
-}
-
-static GConfClient *
-lookup_client (GConfEngine *engine)
-{
-  if (clients == NULL)
-    return NULL;
-  else
-    return g_hash_table_lookup (clients, engine);
-}
-
-static void
-unregister_client (GConfClient *client)
-{
-  g_return_if_fail (clients != NULL);
-
-  g_hash_table_remove (clients, client->engine);
-}
Index: wrappers/gtk/gconf-client.h
===================================================================
RCS file: gconf-client.h
diff -N gconf-client.h
--- /tmp/cvsGdUEJ7	Sun Mar 18 13:19:37 2001
+++ /dev/null	Tue May  5 16:32:27 1998
@@ -1,380 +0,0 @@
-/* -*- tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* GConf
- * Copyright (C) 1999, 2000 Red Hat Inc.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#ifndef GCONF_GCONF_CLIENT_H
-#define GCONF_GCONF_CLIENT_H
-
-#include <gtk/gtkobject.h>
-#include <gtk/gtkwidget.h>
-#include <gconf/gconf.h>
-#include <gconf/gconf-listeners.h>
-#include <gconf/gconf-changeset.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-/*
- * This is a wrapper for the client-side GConf API which provides several
- * convenient features.
- *
- *  - It (recursively) caches the contents of certain directories on
- *    the client side, such as your application's configuration
- *    directory
- *
- *  - It allows you to register per-key callbacks within these directories,
- *    without having to register multiple server-side callbacks
- *    (gconf_engine_notify_add() adds a request-for-notify to the server,
- *    this wrapper adds a notify to the server for the whole directory
- *    and keeps your per-key notify requests on the client side).
- *
- *  - It has some error-handling features
- *
- * This class is heavily specialized for per-user desktop applications -
- * even more so than GConf itself.
- */
-
-/*
- * IMPORTANT: you can't mix GConfClient with direct GConfEngine access,
- * or you will have a mess because the client won't know what you're doing
- * underneath it.
- */
-
-typedef enum {
-  GCONF_CLIENT_PRELOAD_NONE,     /* don't preload anything */
-  GCONF_CLIENT_PRELOAD_ONELEVEL, /* load entries directly under the directory. */
-  GCONF_CLIENT_PRELOAD_RECURSIVE /* recurse the directory tree; possibly quite expensive! */
-} GConfClientPreloadType;
-
-typedef enum {
-  GCONF_CLIENT_HANDLE_NONE,
-  GCONF_CLIENT_HANDLE_UNRETURNED,
-  GCONF_CLIENT_HANDLE_ALL
-} GConfClientErrorHandlingMode;
-
-
-typedef struct _GConfClient       GConfClient;
-typedef struct _GConfClientClass  GConfClientClass;
-
-
-typedef void (*GConfClientNotifyFunc)(GConfClient* client,
-                                      guint cnxn_id,
-                                      GConfEntry *entry,
-                                      gpointer user_data);
-
-typedef void (*GConfClientErrorHandlerFunc) (GConfClient* client,
-                                             GError* error);
-
-#define GCONF_TYPE_CLIENT                  (gconf_client_get_type ())
-#define GCONF_CLIENT(obj)                  (GTK_CHECK_CAST ((obj), GCONF_TYPE_CLIENT, GConfClient))
-#define GCONF_CLIENT_CLASS(klass)          (CONF_CHECK_CLASS_CAST ((klass), GCONF_TYPE_CLIENT, GConfClientClass))
-#define GCONF_IS_CLIENT(obj)               (GTK_CHECK_TYPE ((obj), GCONF_TYPE_CLIENT))
-#define GCONF_IS_CLIENT_CLASS(klass)       (CONF_CHECK_CLASS_TYPE ((klass), GCONF_TYPE_CLIENT))
-
-struct _GConfClient
-{
-  GtkObject object;
-
-  /*< private >*/
-
-  GConfEngine* engine;
-  GConfClientErrorHandlingMode error_mode;
-  GHashTable* dir_hash;
-  GHashTable* cache_hash;
-  GConfListeners* listeners;
-};
-
-struct _GConfClientClass
-{
-  GtkObjectClass parent_class;
-
-  /* emitted whenever a value changes. Often, you should use a notify
-     function instead; the problem with this signal is that you
-     probably have to do an expensive chain of strcmp() to
-     determine how to respond to it.
-  */
-
-  void (* value_changed) (GConfClient* client,
-                          const gchar* key,
-                          GConfValue* value);
-
-  /* General note about error handling: AVOID DIALOG DELUGES.
-     That is, if lots of errors could happen in a row you need
-     to collect those and put them in _one_ dialog, maybe using
-     an idle function. gconf_client_set_error_handling()
-     is provided and it does this using GnomeDialog.  */
-
-  /* emitted when you pass NULL for the error return location to a
-     GConfClient function and an error occurs. This allows you to
-     ignore errors when your generic handler will work, and handle
-     them specifically when you need to */
-  void (* unreturned_error) (GConfClient* client,
-                             GError* error);
-
-  /* emitted unconditionally anytime there's an error, whether you ask
-     for that error or not. Useful for creating an error log or
-     something. */
-  void (* error)            (GConfClient* client,
-                             GError* error);
-};
-
-
-GtkType           gconf_client_get_type        (void);
-
-/* use the default engine */
-GConfClient*      gconf_client_get_default             (void);
-
-/* refcount on engine is incremented, you still own your ref */
-GConfClient*      gconf_client_get_for_engine (GConfEngine* engine);
-
-/* Add a directory to monitor and emit the value_changed signal and
-   key notifications for.  Optionally pre-load the contents of this
-   directory, much faster if you plan to access most of the directory
-   contents. You can't add overlapping directories.
-*/
-
-void              gconf_client_add_dir     (GConfClient* client,
-                                            const gchar* dir,
-                                            GConfClientPreloadType preload,
-                                            GError** err);
-
-
-/* This removes any notifications associated with the dir */
-void              gconf_client_remove_dir  (GConfClient* client,
-                                            const gchar* dir,
-                                            GError** err);
-
-/*
- *  The notification facility allows you to attach a callback to a single
- *  key or directory, which is more convenient most of the time than
- *  the value_changed signal. The key you're monitoring must be inside one
- *  of the GConfClient's directories.
- */
-
-
-/* Returns ID of the notification */
-/* returns 0 on error, 0 is an invalid ID */
-guint        gconf_client_notify_add(GConfClient* client,
-                                     const gchar* namespace_section, /* dir or key to listen to */
-                                     GConfClientNotifyFunc func,
-                                     gpointer user_data,
-                                     GFreeFunc destroy_notify,
-                                     GError** err);
-
-void         gconf_client_notify_remove  (GConfClient* client,
-                                          guint cnxn);
-
-/*
- * Error handling convenience; if you don't want the default handler,
- * set the error handling to GCONF_CLIENT_HANDLE_NONE
- */
-
-/* 
- * Error handling happens in the default signal handler, so you can
- * selectively override the default handling by connecting to the error
- * signal and calling gtk_signal_emit_stop()
- */
-
-void              gconf_client_set_error_handling(GConfClient* client,
-                                                  GConfClientErrorHandlingMode mode);
-
-
-/* Intended for use by gnome-libs */
-void              gconf_client_set_global_default_error_handler(GConfClientErrorHandlerFunc func);
-
-/*
- * If you know you're done reading values for a while,
- * you can blow away the cache. Note that this nullifies the effect of
- * any preloading you may have done. However it frees some memory.
- */
-void              gconf_client_clear_cache(GConfClient* client);
-
-/*
- * Preload a directory; the directory must have been added already.
- * This is only useful as an optimization if you clear the cache,
- * then later want to do a lot of reads again. It's not useful
- * unless you clear the cache, because you can preload when you
- * call gconf_client_add_dir()
- */
-void              gconf_client_preload    (GConfClient* client,
-                                           const gchar* dirname,
-                                           GConfClientPreloadType type,
-                                           GError** err);
-
-/*
- * Basic key-manipulation facilities; these keys do _not_ have to be in the
- * client's directory list, but they won't be cached unless they are.
- */
-
-void              gconf_client_set             (GConfClient* client,
-                                                const gchar* key,
-                                                GConfValue* val,
-                                                GError** err);
-
-GConfValue*       gconf_client_get             (GConfClient* client,
-                                                const gchar* key,
-                                                GError** err);
-
-GConfValue*       gconf_client_get_without_default  (GConfClient* client,
-                                                     const gchar* key,
-                                                     GError** err);
-
-GConfEntry*       gconf_client_get_entry        (GConfClient* client,
-                                                 const gchar* key,
-                                                 const gchar* locale,
-                                                 gboolean use_schema_default,
-                                                 GError** err);
-
-GConfValue*       gconf_client_get_default_from_schema (GConfClient* client,
-                                                        const gchar* key,
-                                                        GError** err);
-
-gboolean     gconf_client_unset          (GConfClient* client,
-                                          const gchar* key, GError** err);
-
-GSList*      gconf_client_all_entries    (GConfClient* client,
-                                          const gchar* dir, GError** err);
-
-GSList*      gconf_client_all_dirs       (GConfClient* client,
-                                          const gchar* dir, GError** err);
-
-void         gconf_client_suggest_sync   (GConfClient* client,
-                                          GError** err);
-
-gboolean     gconf_client_dir_exists     (GConfClient* client,
-                                          const gchar* dir, GError** err);
-
-gboolean     gconf_client_key_is_writable(GConfClient* client,
-                                          const gchar* key,
-                                          GError**     err);
-
-/* Get/Set convenience wrappers */
-
-gdouble      gconf_client_get_float (GConfClient* client, const gchar* key,
-                                     GError** err);
-
-gint         gconf_client_get_int   (GConfClient* client, const gchar* key,
-                                     GError** err);
-
-/* free the retval, if non-NULL */
-gchar*       gconf_client_get_string(GConfClient* client, const gchar* key,
-                                     GError** err);
-
-gboolean     gconf_client_get_bool  (GConfClient* client, const gchar* key,
-                                     GError** err);
-
-/* this one has no default since it would be expensive and make little
-   sense; it returns NULL as a default, to indicate unset or error */
-/* free the retval */
-/* Note that this returns the schema stored at key, NOT
-   the schema that key conforms to. */
-GConfSchema* gconf_client_get_schema  (GConfClient* client,
-                                       const gchar* key, GError** err);
-
-GSList*      gconf_client_get_list    (GConfClient* client, const gchar* key,
-                                       GConfValueType list_type, GError** err);
-
-gboolean     gconf_client_get_pair    (GConfClient* client, const gchar* key,
-                                       GConfValueType car_type, GConfValueType cdr_type,
-                                       gpointer car_retloc, gpointer cdr_retloc,
-                                       GError** err);
-
-/* No convenience functions for lists or pairs, since there are too
-   many combinations of types possible
-*/
-
-/* setters return TRUE on success; note that you still should suggest a sync */
-
-gboolean     gconf_client_set_float   (GConfClient* client, const gchar* key,
-                                       gdouble val, GError** err);
-
-gboolean     gconf_client_set_int     (GConfClient* client, const gchar* key,
-                                       gint val, GError** err);
-
-gboolean     gconf_client_set_string  (GConfClient* client, const gchar* key,
-                                       const gchar* val, GError** err);
-
-gboolean     gconf_client_set_bool    (GConfClient* client, const gchar* key,
-                                       gboolean val, GError** err);
-
-gboolean     gconf_client_set_schema  (GConfClient* client, const gchar* key,
-                                       GConfSchema* val, GError** err);
-
-/* List should be the same as the one gconf_client_get_list() would return */
-gboolean     gconf_client_set_list    (GConfClient* client, const gchar* key,
-                                       GConfValueType list_type,
-                                       GSList* list,
-                                       GError** err);
-
-gboolean     gconf_client_set_pair    (GConfClient* client, const gchar* key,
-                                       GConfValueType car_type, GConfValueType cdr_type,
-                                       gconstpointer address_of_car,
-                                       gconstpointer address_of_cdr,
-                                       GError** err);
-
-/*
- * Functions to emit signals
- */
-
-/* these are useful to manually invoke the default error handlers */
-void         gconf_client_error                  (GConfClient* client, GError* error);
-void         gconf_client_unreturned_error       (GConfClient* client, GError* error);
-
-/* useful to force an update */
-void         gconf_client_value_changed          (GConfClient* client,
-                                                  const gchar* key,
-                                                  GConfValue* value);
-
-/*
- * Change set stuff
- */
-
-gboolean        gconf_client_commit_change_set   (GConfClient* client,
-                                                  GConfChangeSet* cs,
-                                                  /* remove all
-                                                     successfully
-                                                     committed changes
-                                                     from the set */
-                                                  gboolean remove_committed,
-                                                  GError** err);
-
-/* Create a change set that would revert the given change set
-   for the given GConfClient */
-GConfChangeSet* gconf_client_reverse_change_set  (GConfClient* client,
-                                                         GConfChangeSet* cs,
-                                                         GError** err);
-
-GConfChangeSet* gconf_client_change_set_from_currentv (GConfClient* client,
-                                                              const gchar** keys,
-                                                              GError** err);
-
-GConfChangeSet* gconf_client_change_set_from_current (GConfClient* client,
-                                                             GError** err,
-                                                             const gchar* first_key,
-                                                             ...);
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif
-
-
-
Index: wrappers/gtk/testgconfclient.c
===================================================================
RCS file: testgconfclient.c
diff -N testgconfclient.c
--- /tmp/cvsylMpGy	Sun Mar 18 13:19:37 2001
+++ /dev/null	Tue May  5 16:32:27 1998
@@ -1,322 +0,0 @@
-/* -*- tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* GConf
- * Copyright (C) 1999, 2000, 2000 Red Hat Inc.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#include "gconf-client.h"
-
-#include <gtk/gtk.h>
-
-static void create_controls(GConfClient* client);
-
-int
-main(int argc, char** argv)
-{
-  GError* error = NULL;
-  GConfClient* client = NULL;
-
-  gtk_init(&argc, &argv);
-  
-  if (!gconf_init(argc, argv, &error))
-    {
-      g_assert(error != NULL);
-      g_warning("GConf init failed:\n  %s", error->message);
-      return 1;
-    }
-
-  g_assert(error == NULL);
-
-  client = gconf_client_get_default();
-
-  gconf_client_add_dir(client, "/apps/gnome/testgconfclient", GCONF_CLIENT_PRELOAD_NONE, NULL);
-
-  create_controls(client);
-  
-  gtk_main();
-
-  gtk_object_unref(GTK_OBJECT(client));
-  
-  return 0;
-}
-
-static void
-entry_notify_func(GConfClient* client, guint cnxn_id,
-                  GConfEntry *gconf_entry,
-                  gpointer user_data)
-{
-  GtkWidget* entry = user_data;
-  
-  g_return_if_fail(GTK_IS_ENTRY(entry));
-
-  gtk_signal_handler_block_by_data(GTK_OBJECT(entry), client);
-  gtk_entry_set_text(GTK_ENTRY(entry),
-                     gconf_value_get_string(gconf_entry->value));
-  gtk_signal_handler_unblock_by_data(GTK_OBJECT(entry), client);
-}
-
-static void
-entry_destroyed_callback(GtkWidget* entry, gpointer data)
-{
-  GConfClient* client = data;
-
-  guint notify_id = GPOINTER_TO_UINT(gtk_object_get_data(GTK_OBJECT(entry),
-                                                         "notify_id"));
-
-  gconf_client_notify_remove(client, notify_id);
-}
-
-static void
-entry_changed_callback(GtkWidget* entry, gpointer data)
-{
-  GConfClient* client = data;
-  const gchar* key;
-  gchar* text;
-
-  text = gtk_editable_get_chars(GTK_EDITABLE(entry), 0, -1);
-  key = gtk_object_get_data(GTK_OBJECT(entry), "key");
-  
-  gconf_client_set_string(client, key, text, NULL);
-
-  g_free(text);
-}
-
-static GtkWidget*
-entry_attached_to(GConfClient* client, const gchar* key)
-{
-  GtkWidget* entry;
-  GtkWidget* hbox;
-  GtkWidget* label;
-  gchar* val;
-  guint notify_id;
-  
-  entry = gtk_entry_new();
-
-  gtk_object_set_data_full(GTK_OBJECT(entry), "key",
-                           g_strdup(key), g_free);
-
-
-  val = gconf_client_get_string(client, key, NULL);
-
-  gtk_entry_set_text(GTK_ENTRY(entry), val ? val : "");
-
-  g_free(val);
-  
-  notify_id = gconf_client_notify_add(client, key, entry_notify_func, entry, NULL, NULL);
-
-  gtk_object_set_data(GTK_OBJECT(entry), "notify_id",
-                      GUINT_TO_POINTER(notify_id));
-  
-  gtk_signal_connect(GTK_OBJECT(entry), "changed",
-                     GTK_SIGNAL_FUNC(entry_changed_callback),
-                     client);
-
-  gtk_signal_connect(GTK_OBJECT(entry), "destroy",
-                     GTK_SIGNAL_FUNC(entry_destroyed_callback),
-                     client);
-  
-  hbox = gtk_hbox_new(FALSE, 10);
-
-  label = gtk_label_new(key);
-
-  gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
-  gtk_box_pack_end(GTK_BOX(hbox), entry, FALSE, FALSE, 0);
-
-  /* Set sensitive according to whether the key is writable or not. */
-  gtk_widget_set_sensitive (entry,
-                            gconf_client_key_is_writable (client,
-                                                          key, NULL));
-  
-  return hbox;
-}
-
-static void
-destroy_callback(GtkWidget* win, gpointer data)
-{
-  GConfClient* client = data;
-
-  gtk_object_unref(GTK_OBJECT(client));
-}
-
-static void
-quit_callback(GtkWidget* button, gpointer data)
-{
-  GtkWidget* win = data;
-
-  gtk_widget_destroy(win);
-
-  gtk_main_quit();
-}
-
-static void
-addsub_callback(GtkWidget* button, gpointer data)
-{
-  GtkWidget* win = data;
-  GConfClient* client = gtk_object_get_data(GTK_OBJECT(win), "client");
-  GtkWidget* label = gtk_object_get_data(GTK_OBJECT(win), "label");
-  int subdir = GPOINTER_TO_INT(gtk_object_get_data(GTK_OBJECT(win), "subdir"));
-  int maindir = GPOINTER_TO_INT(gtk_object_get_data(GTK_OBJECT(win), "maindir"));
-  char *s;
-
-  subdir++;
-
-  gtk_object_set_data(GTK_OBJECT(win), "subdir", GINT_TO_POINTER(subdir));
-
-  gconf_client_add_dir(client, "/apps/gnome/testgconfclient/subdir", GCONF_CLIENT_PRELOAD_NONE, NULL);
-
-  s = g_strdup_printf("Maindir added %d times\nSubdir added %d times", maindir, subdir);
-  gtk_label_set(GTK_LABEL(label), s);
-  g_free(s);
-}
-
-static void
-removesub_callback(GtkWidget* button, gpointer data)
-{
-  GtkWidget* win = data;
-  GConfClient* client = gtk_object_get_data(GTK_OBJECT(win), "client");
-  GtkWidget* label = gtk_object_get_data(GTK_OBJECT(win), "label");
-  int subdir = GPOINTER_TO_INT(gtk_object_get_data(GTK_OBJECT(win), "subdir"));
-  int maindir = GPOINTER_TO_INT(gtk_object_get_data(GTK_OBJECT(win), "maindir"));
-  char *s;
-
-  subdir--;
-
-  gtk_object_set_data(GTK_OBJECT(win), "subdir", GINT_TO_POINTER(subdir));
-
-  gconf_client_remove_dir(client, "/apps/gnome/testgconfclient/subdir", NULL);
-
-  s = g_strdup_printf("Maindir added %d times\nSubdir added %d times", maindir, subdir);
-  gtk_label_set(GTK_LABEL(label), s);
-  g_free(s);
-}
-
-static void
-addmain_callback(GtkWidget* button, gpointer data)
-{
-  GtkWidget* win = data;
-  GConfClient* client = gtk_object_get_data(GTK_OBJECT(win), "client");
-  GtkWidget* label = gtk_object_get_data(GTK_OBJECT(win), "label");
-  int subdir = GPOINTER_TO_INT(gtk_object_get_data(GTK_OBJECT(win), "subdir"));
-  int maindir = GPOINTER_TO_INT(gtk_object_get_data(GTK_OBJECT(win), "maindir"));
-  char *s;
-
-  maindir++;
-
-  gtk_object_set_data(GTK_OBJECT(win), "maindir", GINT_TO_POINTER(maindir));
-
-  gconf_client_add_dir(client, "/apps/gnome/testgconfclient", GCONF_CLIENT_PRELOAD_NONE, NULL);
-
-  s = g_strdup_printf("Maindir added %d times\nSubdir added %d times", maindir, subdir);
-  gtk_label_set(GTK_LABEL(label), s);
-  g_free(s);
-}
-  
-static void
-removemain_callback(GtkWidget* button, gpointer data)
-{
-  GtkWidget* win = data;
-  GConfClient* client = gtk_object_get_data(GTK_OBJECT(win), "client");
-  GtkWidget* label = gtk_object_get_data(GTK_OBJECT(win), "label");
-  int subdir = GPOINTER_TO_INT(gtk_object_get_data(GTK_OBJECT(win), "subdir"));
-  int maindir = GPOINTER_TO_INT(gtk_object_get_data(GTK_OBJECT(win), "maindir"));
-  char *s;
-
-  maindir--;
-
-  gtk_object_set_data(GTK_OBJECT(win), "maindir", GINT_TO_POINTER(maindir));
-
-  gconf_client_remove_dir(client, "/apps/gnome/testgconfclient", NULL);
-
-  s = g_strdup_printf("Maindir added %d times\nSubdir added %d times", maindir, subdir);
-  gtk_label_set(GTK_LABEL(label), s);
-  g_free(s);
-}
-
-static void
-create_controls(GConfClient* client)
-{
-  GtkWidget* win;
-  GtkWidget* label;
-  GtkWidget* vbox;
-  GtkWidget* button;
-  GtkWidget* entry;
-  
-  /* Reference held by the window */
-
-  gtk_object_ref(GTK_OBJECT(client));
-
-  win = gtk_window_new(GTK_WINDOW_TOPLEVEL);
-  
-  gtk_object_set_data(GTK_OBJECT(win), "client", client);
-
-  gtk_signal_connect(GTK_OBJECT(win), "destroy",
-                     GTK_SIGNAL_FUNC(destroy_callback), client);
-
-  vbox = gtk_vbox_new(FALSE, 10);
-
-  gtk_container_add(GTK_CONTAINER(win), vbox);
-
-  label = gtk_label_new("Maindir added 1 times\nSubdir added 0 times");
-  gtk_box_pack_end(GTK_BOX(vbox), label, FALSE, FALSE, 0);
-  gtk_object_set_data(GTK_OBJECT(win), "label", label);
-  gtk_object_set_data(GTK_OBJECT(win), "subdir", GINT_TO_POINTER(0));
-  gtk_object_set_data(GTK_OBJECT(win), "maindir", GINT_TO_POINTER(1));
-
-  button = gtk_button_new_with_label("Quit");
-  gtk_signal_connect(GTK_OBJECT(button), "clicked",
-                     GTK_SIGNAL_FUNC(quit_callback), win);
-  gtk_box_pack_end(GTK_BOX(vbox), button, FALSE, FALSE, 0);
-  
-  button = gtk_button_new_with_label("Remove subdir");
-  gtk_signal_connect(GTK_OBJECT(button), "clicked",
-                     GTK_SIGNAL_FUNC(removesub_callback), win);
-  gtk_box_pack_end(GTK_BOX(vbox), button, FALSE, FALSE, 0);
-
-  button = gtk_button_new_with_label("Add subdir");
-  gtk_signal_connect(GTK_OBJECT(button), "clicked",
-                     GTK_SIGNAL_FUNC(addsub_callback), win);
-  gtk_box_pack_end(GTK_BOX(vbox), button, FALSE, FALSE, 0);
-
-  button = gtk_button_new_with_label("Remove maindir");
-  gtk_signal_connect(GTK_OBJECT(button), "clicked",
-                     GTK_SIGNAL_FUNC(removemain_callback), win);
-  gtk_box_pack_end(GTK_BOX(vbox), button, FALSE, FALSE, 0);
-
-  button = gtk_button_new_with_label("Add maindir");
-  gtk_signal_connect(GTK_OBJECT(button), "clicked",
-                     GTK_SIGNAL_FUNC(addmain_callback), win);
-  gtk_box_pack_end(GTK_BOX(vbox), button, FALSE, FALSE, 0);
-
-  entry = entry_attached_to(client, "/apps/gnome/testgconfclient/blah");
-  gtk_box_pack_start(GTK_BOX(vbox), entry, FALSE, FALSE, 0);
-
-  entry = entry_attached_to(client, "/apps/gnome/testgconfclient/foo");
-  gtk_box_pack_start(GTK_BOX(vbox), entry, FALSE, FALSE, 0);
-
-  entry = entry_attached_to(client, "/apps/gnome/testgconfclient/bar");
-  gtk_box_pack_start(GTK_BOX(vbox), entry, FALSE, FALSE, 0);
-
-  entry = entry_attached_to(client, "/apps/gnome/testgconfclient/subdir/testsub1");
-  gtk_box_pack_start(GTK_BOX(vbox), entry, FALSE, FALSE, 0);
-
-  entry = entry_attached_to(client, "/apps/gnome/testgconfclient/subdir/testsub2");
-  gtk_box_pack_start(GTK_BOX(vbox), entry, FALSE, FALSE, 0);
-  
-  gtk_widget_show_all(win);
-}
-
-
