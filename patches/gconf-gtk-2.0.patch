Index: .cvsignore
===================================================================
RCS file: /cvs/gnome/gconf/.cvsignore,v
retrieving revision 1.6
diff -u -u -d -p -b -B -r1.6 .cvsignore
--- .cvsignore	2000/08/29 21:16:59	1.6
+++ .cvsignore	2000/12/05 14:56:45
@@ -18,5 +18,7 @@ ABOUT-NLS
 intl
 config.h.in
 gconf-config
+gconf-2.0.pc
+gconfgtk-2.0.pc
 gconf.spec
 gconf.m4
Index: Makefile.am
===================================================================
RCS file: /cvs/gnome/gconf/Makefile.am,v
retrieving revision 1.19
diff -u -u -d -p -b -B -r1.19 Makefile.am
--- Makefile.am	2000/10/03 19:14:23	1.19
+++ Makefile.am	2000/12/05 14:56:46
@@ -2,7 +2,8 @@
 SUBDIRS = gconf backends wrappers po doc examples standard-schemas
 DIST_SUBDIRS=tests $(SUBDIRS)
 
-EXTRA_DIST=gconf-config.in gconf.m4.in gconf.spec.in gconf.spec TODO
+EXTRA_DIST=gconf-config.in gconf.m4.in gconf.spec.in gconf.spec TODO \
+	   gconf-2.0.pc.in gconfgtk-2.0.pc.in
 
 WARNING_MESSAGE="If this is your first install of GConf, you may need to move $(prefix)/etc/gconf/$(MAJOR_VERSION)/path.example to $(prefix)/etc/gconf/$(MAJOR_VERSION)/path, so that the default configuration is sane. If you are already using GConf, you may need to move your old configuration into place if $(MAJOR_VERSION) is not the same as your old version."
 
@@ -24,6 +25,9 @@ install-data-local:
 	echo "**** NOTE ****" && \
 	echo $(WARNING_MESSAGE) && \
 	echo "**************"
+
+pkgconfigdir = $(libdir)/pkgconfig
+pkgconfig_DATA = gconf-2.0.pc gconfgtk-2.0.pc
 
 install-schemas:
 	(cd standard-schemas && $(MAKE) $(AM_MAKEFLAGS) install-schemas)
Index: autogen.sh
===================================================================
RCS file: /cvs/gnome/gconf/autogen.sh,v
retrieving revision 1.5
diff -u -u -d -p -b -B -r1.5 autogen.sh
--- autogen.sh	1999/11/19 17:38:12	1.5
+++ autogen.sh	2000/12/05 14:56:46
@@ -4,132 +4,11 @@
 srcdir=`dirname $0`
 test -z "$srcdir" && srcdir=.
 
-ORIGDIR=`pwd`
-cd $srcdir
 PROJECT=GConf
-TEST_TYPE=-f
-FILE=gconf/gconf.h
-
-DIE=0
-
-(autoconf --version) < /dev/null > /dev/null 2>&1 || {
-	echo
-	echo "You must have autoconf installed to compile $PROJECT."
-	echo "Download the appropriate package for your distribution,"
-	echo "or get the source tarball at ftp://ftp.gnu.org/pub/gnu/"
-	DIE=1
-}
-
-(automake --version) < /dev/null > /dev/null 2>&1 || {
-	echo
-	echo "You must have automake installed to compile $PROJECT."
-	echo "Get ftp://sourceware.cygnus.com/pub/automake/automake-1.4.tar.gz"
-	echo "(or a newer version if it is available)"
-	DIE=1
-}
-
-(grep "^AM_PROG_LIBTOOL" configure.in >/dev/null) && {
-  (libtool --version) < /dev/null > /dev/null 2>&1 || {
-    echo
-    echo "**Error**: You must have \`libtool' installed to compile $PROJECT."
-    echo "Get ftp://ftp.gnu.org/pub/gnu/libtool-1.2d.tar.gz"
-    echo "(or a newer version if it is available)"
-    DIE=1
-  }
-}
 
-grep "^AM_GNU_GETTEXT" configure.in >/dev/null && {
-  grep "sed.*POTFILES" $srcdir/configure.in >/dev/null || \
-  (gettext --version) < /dev/null > /dev/null 2>&1 || {
-    echo
-    echo "**Error**: You must have \`gettext' installed to compile $PROJECT."
-    echo "Get ftp://alpha.gnu.org/gnu/gettext-0.10.35.tar.gz"
-    echo "(or a newer version if it is available)"
-    DIE=1
-  }
-}
-
-if test "$DIE" -eq 1; then
-	exit 1
-fi
-
-test $TEST_TYPE $FILE || {
+(test -f gconf/gconf.h) || {
 	echo "You must run this script in the top-level $PROJECT directory"
 	exit 1
 }
-
-if test -z "$*"; then
-	echo "I am going to run ./configure with no arguments - if you wish "
-        echo "to pass any to it, please specify them on the $0 command line."
-fi
 
-case $CC in
-*xlc | *xlc\ * | *lcc | *lcc\ *) am_opt=--include-deps;;
-esac
-
-for coin in `find . -name configure.in -print`
-do 
-  dr=`dirname $coin`
-  if test -f $dr/NO-AUTO-GEN; then
-    echo skipping $dr -- flagged as no auto-gen
-  else
-    echo processing $dr
-    macrodirs=`sed -n -e 's,AM_ACLOCAL_INCLUDE(\(.*\)),\1,gp' < $coin`
-    ( cd $dr
-      aclocalinclude="$ACLOCAL_FLAGS"
-      for k in $macrodirs; do
-  	if test -d $k; then
-          aclocalinclude="$aclocalinclude -I $k"
-  	##else 
-	##  echo "**Warning**: No such directory \`$k'.  Ignored."
-        fi
-      done
-      if grep "^AM_GNU_GETTEXT" configure.in >/dev/null; then
-	if grep "sed.*POTFILES" configure.in >/dev/null; then
-	  : do nothing -- we still have an old unmodified configure.in
-	else
-	  echo "Creating $dr/aclocal.m4 ..."
-	  test -r $dr/aclocal.m4 || touch $dr/aclocal.m4
-	  echo "Running gettextize...  Ignore non-fatal messages."
-	  echo "no" | gettextize --force --copy
-	  echo "Making $dr/aclocal.m4 writable ..."
-	  test -r $dr/aclocal.m4 && chmod u+w $dr/aclocal.m4
-        fi
-      fi
-      if grep "^AM_GNOME_GETTEXT" configure.in >/dev/null; then
-	echo "Creating $dr/aclocal.m4 ..."
-	test -r $dr/aclocal.m4 || touch $dr/aclocal.m4
-	echo "Running gettextize...  Ignore non-fatal messages."
-	echo "no" | gettextize --force --copy
-	echo "Making $dr/aclocal.m4 writable ..."
-	test -r $dr/aclocal.m4 && chmod u+w $dr/aclocal.m4
-      fi
-      if grep "^AM_PROG_LIBTOOL" configure.in >/dev/null; then
-	echo "Running libtoolize..."
-	libtoolize --force --copy
-      fi
-      echo "Running aclocal $aclocalinclude ..."
-      aclocal $aclocalinclude
-      if grep "^AM_CONFIG_HEADER" configure.in >/dev/null; then
-	echo "Running autoheader..."
-	autoheader
-      fi
-      echo "Running automake --gnu $am_opt ..."
-      automake --add-missing --gnu $am_opt
-      echo "Running autoconf ..."
-      autoconf
-    )
-  fi
-done
-
-conf_flags="--enable-maintainer-mode --enable-compile-warnings" #--enable-iso-c
-
-cd "$ORIGDIR"
-
-if test x$NOCONFIGURE = x; then
-  echo Running $srcdir/configure $conf_flags "$@" ...
-  $srcdir/configure $conf_flags "$@" \
-  && echo Now type \`make\' to compile $PROJECT  || exit 1
-else
-  echo Skipping configure process.
-fi
+USE_GNOME2_MACROS=1 . gnome-autogen.sh
Index: configure.in
===================================================================
RCS file: /cvs/gnome/gconf/configure.in,v
retrieving revision 1.63
diff -u -u -d -p -b -B -r1.63 configure.in
--- configure.in	2000/10/31 19:15:39	1.63
+++ configure.in	2000/12/05 14:56:46
@@ -137,24 +137,34 @@ if test "x$docs_only" = "xyes"; then
         AC_FYI("Only building documentation")
 else
 
-AM_PATH_GLIB(1.2.0,,AC_MSG_ERROR(glib not found or too old),gmodule)
-AM_PATH_OAF(0.2.0,,AC_MSG_ERROR([OAF not found or too old]))
-AM_PATH_GTK(1.2.0,,HAVE_GTK=no)
-
-AM_CONDITIONAL(GTK, test x$HAVE_GTK != xno)
+GNOME_COMMON_INIT
+GNOME_PLATFORM_GNOME_2(no)
 
-AC_PATH_PROG(XML_CONFIG,xml-config,no)
-if test x$XML_CONFIG = xno; then
-  AC_MSG_ERROR(Couldn't find xml-config need to install libxml)
-fi
-XML_LIBS=`$XML_CONFIG --libs`
-XML_CFLAGS=`$XML_CONFIG --cflags`
-if test "x$XML_LIBS" = x; then
-  AC_MSG_ERROR(Failed to get link flags for libxml)
+if test $platform_gnome_2 = yes ; then
+  GNOME_PKGCONFIG_CHECK_MODULES(GLIB, gmodule-2.0:1.3.1)
+  GNOME_PKGCONFIG_CHECK_MODULES(OAF, oaf-2.0)
+  GNOME_PKGCONFIG_CHECK_OPTIONAL_MODULES(GTK, gtk+-2.0:1.3.1)
+  GNOME_PKGCONFIG_CHECK_MODULES(XML, libxml-2.0:2.2.8)
+else
+  GNOME_PKGCONFIG_CHECK_MODULES(GLIB, gmodule:1.2.6)
+  GNOME_PKGCONFIG_CHECK_MODULES(OAF, oaf:0.2.0)
+  GNOME_PKGCONFIG_CHECK_OPTIONAL_MODULES(GTK, gtk+:1.2.6)
+  GNOME_PKGCONFIG_CHECK_MODULES(XML, libxml:1.8.8)
 fi
+AC_PATH_PROG(OAF_CONFIG, oaf-config)
+AC_SUBST(OAF_CONFIG)
+AC_SUBST(GLIB_LIBS)
+AC_SUBST(GLIB_CFLAGS)
+AC_SUBST(OAF_LIBS)
+AC_SUBST(OAF_CFLAGS)
+AC_SUBST(GTK_LIBS)
+AC_SUBST(GTK_CFLAGS)
 AC_SUBST(XML_LIBS)
 AC_SUBST(XML_CFLAGS)
 
+AM_CONDITIONAL(GTK, test x$HAVE_GTK != xno)
+
+
 BDB_LIBS=
 BDB_CFLAGS=
 
@@ -212,7 +222,7 @@ fi # docs_only
 
 ALL_LINGUAS="ca cs da de el fi fr ga ja ko nl no pt_BR ru sv tr uk"
 
-AM_GCONF_GNU_GETTEXT
+AM_GNOME2_GETTEXT
 
 # AM_GNU_GETTEXT above substs $DATADIRNAME
 # this is the directory where the *.{mo,gmo} files are installed
@@ -244,6 +254,8 @@ doc/gconf/Makefile
 examples/Makefile
 tests/Makefile
 standard-schemas/Makefile
+gconf-2.0.pc
+gconfgtk-2.0.pc
 ],
 chmod +x gconf-config)
 
Index: gconf-2.0.pc.in
===================================================================
RCS file: gconf-2.0.pc.in
diff -N gconf-2.0.pc.in
--- /dev/null	Tue May  5 16:32:27 1998
+++ gconf-2.0.pc.in	Tue Dec  5 09:56:46 2000
@@ -0,0 +1,12 @@
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+libdir=@libdir@
+includedir=@includedir@
+
+
+Name: gconf
+Description: GNOME Config System.
+Version: @VERSION@
+Requires: oaf-2.0
+Libs: -L${libdir} -lgconf-@MAJOR_VERSION@
+Cflags: -I${includedir}/gconf/@MAJOR_VERSION@
Index: gconfgtk-2.0.pc.in
===================================================================
RCS file: gconfgtk-2.0.pc.in
diff -N gconfgtk-2.0.pc.in
--- /dev/null	Tue May  5 16:32:27 1998
+++ gconfgtk-2.0.pc.in	Tue Dec  5 09:56:46 2000
@@ -0,0 +1,12 @@
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+libdir=@libdir@
+includedir=@includedir@
+
+
+Name: gconfgtk
+Description: GTK+ wrappers for the GNOME Config System.
+Version: @VERSION@
+Requires: gconf-2.0,gtk+-2.0
+Libs: -lgconf-gtk-@MAJOR_VERSION@
+Cflags: 
Index: backends/gthreadpool.c
===================================================================
RCS file: gthreadpool.c
diff -N gthreadpool.c
--- backends/gthreadpool.c	Tue Dec  5 09:56:57 2000
+++ /dev/null	Tue May  5 16:32:27 1998
@@ -1,435 +0,0 @@
-/* GConf
- * Copyright (C) 1999, 2000 Red Hat Inc.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-
-#include "gthreadpool.h"
-#include <pthread.h>
-
-typedef struct _Task Task;
-
-struct _Task {
-  GWorkerFunc work_func;
-  GWorkFinishedNotifyFunc notify_func;
-  gpointer data;
-  gpointer result;
-}
-
-typedef struct _GThreadPoolPrivate GThreadPoolPrivate;
-
-typedef struct _WorkerThread WorkerThread;
-
-struct _WorkerThread {
-  Task* task;
-  pthread_t thread;
-  GThreadPoolPrivate* pool;
-  gboolean destroyed;
-};
-
-struct _GThreadPoolPrivate {
-  guint max_threads;
-  guint thread_count;
-  GSList* threads;
-
-  pthread_mutex_t worker_mutex;
-  pthread_cond_t worker_cond;
-  pthread_cond_t empty_incoming_cond;
-  guint incoming_task_count;
-  GSList* incoming_tasks;
-  guint busy_task_count;
-  GSList* busy_tasks;
-  guint finished_task_count;
-  GSList* finished_tasks;
-
-  guint notify_pipe_io_watcher_id;
-  int notify_pipe[2];
-  GIOChannel* notify_channel;
-}
-
-static void*
-do_worker_thread(void* _wt)
-{
-  WorkerThread* wt = (WorkerThread*)_wt;
-
-  while (TRUE)
-    {
-      /* Wait until there are incoming tasks or we should
-         exit */
-      pthread_mutex_lock(&(wt->pool->worker_mutex));
-
-      while (wt->pool->incoming_task_count == 0 &&
-             (!wt->destroyed))
-        {
-          pthread_cond_wait(&(wt->pool->worker_cond),
-                            &(wt->pool->worker_mutex));
-        }
-
-      /* Exit if requested */
-      if (wt->destroyed)
-        {
-          pthread_mutex_unlock(&(wt->pool->worker_mutex));
-          pthread_exit(NULL);
-          return NULL; /* not reached */
-        }
-
-      /* Otherwise, take the first incoming task */
-      
-      g_assert(wt->pool->incoming_task_count > 0);
-
-      wt->pool->incoming_task_count -= 1;
-      wt->task = wt->pool->incoming_tasks->data;
-      wt->pool->incoming_tasks = g_slist_remove(wt->pool->incoming_tasks,
-                                                wt->task);
-
-      g_assert(wt->task != NULL);
-
-      wt->pool->busy_task_count += 1;
-      wt->pool->busy_tasks = g_slist_prepend(wt->pool->busy_tasks,
-                                             wt->task);
-
-      pthread_mutex_unlock(&(wt->pool->worker_mutex));
-
-      /* Perform the task; we release the lock,
-       * so other threads can get started or stopped, and also
-       * so conceivably the task can add more tasks to the pool
-       * (however that sounds like it could be a bad idea...)
-       */
-      
-      wt->task->result = (*wt->task->work_func)(wt->task->data);
-
-      /* Move the task onto the finished list */
-      
-      pthread_mutex_lock(&(wt->pool->worker_mutex));
-
-      g_assert(wt->pool->busy_task_count > 0);
-      
-      wt->pool->busy_task_count -= 1;
-      wt->pool->busy_tasks = g_slist_remove(wt->pool->busy_tasks,
-                                            wt->task);
-
-      wt->pool->finished_task_count += 1;
-      wt->pool->finished_tasks = g_slist_prepend(wt->pool->finished_tasks,
-                                                 wt->task);
-
-      /* Forget about our task */
-      wt->task = NULL;
-
-      /* Notify the glib main loop (via an input handler on this pipe)
-       * that there are finished tasks
-       */
-
-    try_again:
-      if (write(wt->pool->notify_pipe[1], "g", 1) < 0)
-        {
-          if (errno == EINTR)
-            goto try_again;
-          else
-            g_warning("Write failure with pipe notification: %s", strerror(errno)); /* shouldn't happen */
-        }
-      
-      /* Notify main thread (g_thread_pool_destroy()) if
-       * we emptied the queue
-       */
-
-      if (wt->pool->incoming_task_count == 0)
-        pthread_cond_signal(&(wt->pool->empty_incoming_cond));
-      
-      pthread_mutex_unlock(&(wt->pool->worker_mutex));
-
-      /* Continue forever */
-    }
-}
-
-/* These should be called from the main thread */
-
-static WorkerThread*
-worker_thread_new(void)
-{
-  int rtn;
-  WorkerThread* wt;
-
-  wt = g_new0(WorkerThread, 1);
-
-  wt->task = NULL;
-  wt->destroyed = FALSE;
-  
-  rtn = pthread_create(&wt->thread, NULL, do_worker_thread, wt);
-
-  if (rtn != 0)
-    {
-      fprintf(stderr, "Failed to create thread: %s\n", strerror(rtn));
-      g_free(wt);
-      return NULL;
-    }
-
-  return wt;
-}
-
-static void
-worker_thread_destroy(WorkerThread* wt)
-{
-  pthread_join(wt->thread, NULL);
-  g_free(wt);
-}
-
-/* note that this function doesn't do locking */
-static void
-g_thread_pool_notify(GThreadPool* pool)
-{
-  GThreadPoolPrivate* priv = (GThreadPoolPrivate*)pool;
-  GSList* tmp;
-  
-  tmp = priv->finished_tasks;
-  while (tmp != NULL)
-    {
-      Task* task = tmp->data;
-
-      (*task->notify_func)(task->result);
-
-      g_free(task);
-      
-      tmp = g_slist_next(tmp);
-    }
-
-  g_slist_free(priv->finished_tasks);
-  priv->finished_task_count = 0;
-  priv->finished_tasks = NULL;
-}
-
-gboolean
-notify_callback (GIOChannel *source,
-                 GIOCondition condition,
-                 gpointer data)
-{
-  GThreadPoolPrivate* priv = data;
-  guint count;
-  gchar* buf;
-  
-  pthread_mutex_lock(&(wt->pool->worker_mutex));
-
-  count = priv->finished_task_count;
-
-  if (count == 0)
-    {
-      g_warning("Strange, we got a notify callback with no finished tasks");
-      pthread_mutex_unlock(&(wt->pool->worker_mutex));
-      return;
-    }
-  
-  g_thread_pool_notify((GThreadPool*)priv);
-
-  g_assert(priv->finished_task_count == 0 &&
-           priv->finished_tasks == NULL);
-
-  /* read notify bytes from the pipe */
-
-  buf = g_malloc(count);
- again:
-  if (read(priv->notify_pipe[0], buf, count) < 0)
-    {
-      if (errno == EINTR)
-        goto again;
-      else
-        {
-          /* shouldn't happen */
-          g_warning("Read failed from notify pipe: %s", strerror(errno));
-        }
-    }
-  /* discard the bytes */
-  g_free(buf);
-  
-  pthread_mutex_unlock(&(wt->pool->worker_mutex));
-}
-
-GThreadPool*
-g_thread_pool_new      (guint max_threads)
-{
-  GThreadPoolPrivate* priv;
-  int ret;
-
-  g_return_val_if_fail(max_threads > 0, NULL);
-  
-  priv = g_new0(GThreadPoolPrivate, 1);
-
-  priv->max_threads = max_threads;
-
-  if (pipe(priv->notify_pipe) < 0)
-    {
-      g_free(priv);
-      return NULL;
-    }
-  
-  ret = pthread_cond_init(&(priv->worker_cond));
-  if (ret != 0)
-    {
-      fprintf(stderr, "Failed to init pthread_cond: %s",
-              strerror(ret));
-      exit(1);
-    }
-
-  ret = pthread_cond_init(&(priv->empty_incoming_cond));
-  if (ret != 0)
-    {
-      fprintf(stderr, "Failed to init pthread_cond: %s",
-              strerror(ret));
-      exit(1);
-    }
-  
-  ret = pthread_mutex_init(&(priv->worker_mutex));
-  if (ret != 0)
-    {
-      fprintf(stderr, "Failed to init pthread_mutex: %s",
-              strerror(ret));
-      exit(1);
-    }
-
-  priv->notify_channel = g_io_channel_unix_new(priv->notify_pipe[0]);
-  
-  priv->notify_pipe_io_watcher_id = g_io_add_watch(priv->notify_channel,
-                                                   G_IO_IN,
-                                                   notify_callback,
-                                                   priv);
-  
-  return (GThreadPool*)priv;
-}
-
-void
-g_thread_pool_destroy  (GThreadPool* pool)
-{
-  GThreadPoolPrivate* priv = (GThreadPoolPrivate*)pool;
-  GSList* tmp;
-  
-  pthread_mutex_lock(&(priv->worker_mutex));
-
-  /* Remove the notify event source */
-  g_source_remove(priv->work_notify_source_id);
-
-  /* close the pipe */
-  close(priv->notify_pipe[0]);
-  close(priv->notify_pipe[1]);
-  
-  /* Clear the queue */
-  while (priv->incoming_task_count != 0)
-    {
-      g_assert(priv->thread_count > 0);
-
-      pthread_cond_wait(&(priv->empty_incoming_cond),
-                        &(priv->worker_mutex));
-    }
-
-  g_assert(priv->incoming_task_count == 0);
-
-  /* Now do notification if any tasks were just finished */
-
-  g_thread_pool_notify(pool);
-  
-  /* Mark all worker threads destroyed */
-
-  tmp = priv->threads;
-  while (tmp != NULL)
-    {
-      WorkerThread* wt = tmp->data;
-
-      g_assert(wt->task == NULL);
-      
-      wt->destroyed = TRUE;
-
-      tmp = g_slist_next(tmp);
-    }
-
-  /* Wake up all threads so they notice they are destroyed and exit */
-  pthread_cond_broadcast(&(priv->worker_cond));
-  pthread_mutex_unlock(&(priv->worker_mutex));
-  
-  /* Now delete all the threads */
-  tmp = priv->threads;
-  while (tmp != NULL)
-    {
-      WorkerThread* wt = tmp->data;
-
-      worker_thread_destroy(wt);
-      
-      tmp = g_slist_next(tmp);
-    }
-
-  g_slist_free(priv->threads);
-  priv->threads = NULL;
-  priv->thread_count = 0;
-
-  g_free(priv);
-}
-
-void
-g_thread_pool_finish_all   (GThreadPool* pool)
-{
-  GThreadPoolPrivate* priv = (GThreadPoolPrivate*)pool;
-  
-  pthread_mutex_lock(&(priv->worker_mutex));
-  
-  /* Clear the queue */
-  while (priv->incoming_task_count != 0)
-    {
-      g_assert(priv->thread_count > 0);
-
-      pthread_cond_wait(&(priv->empty_incoming_cond),
-                        &(priv->worker_mutex));
-    }
-
-  g_assert(priv->incoming_task_count == 0);
-
-  pthread_mutex_unlock(&(priv->worker_mutex));
-}
-
-void
-g_thread_pool_do_work  (GThreadPool* pool,
-                        GWorkerFunc work_func,
-                        gpointer data)
-{
-  GThreadPoolPrivate* priv = (GThreadPoolPrivate*)pool;
-  Task* task;
-
-  task = g_new0(Task, 1);
-
-  task->work_func = work_func;
-  task->notify_func = notify_func;
-  task->data = data;
-
-  pthread_mutex_lock(&(priv->worker_mutex));
-
-  priv->incoming_task_count += 1;
-  priv->incoming_tasks = g_slist_prepend(priv->incoming_tasks,
-                                         task);
-
-  if ((priv->thread_count < priv->max_threads) && 
-      ((priv->busy_task_count + priv->incoming_task_count) > priv->thread_count))
-    {
-      /* Add another worker thread */
-      WorkerThread* wt = worker_thread_new();
-
-      priv->threads = g_slist_prepend(priv->threads, wt);
-      priv->thread_count += 1;
-    }
-
-  /* Wake up one of the waiting threads */
-  pthread_cond_signal(&(priv->worker_cond));
-  
-  pthread_mutex_unlock(&(priv->worker_mutex));
-}
-
-
-
Index: backends/gthreadpool.h
===================================================================
RCS file: gthreadpool.h
diff -N gthreadpool.h
--- backends/gthreadpool.h	Tue Dec  5 09:56:57 2000
+++ /dev/null	Tue May  5 16:32:27 1998
@@ -1,66 +0,0 @@
-/* GConf
- * Copyright (C) 1999, 2000 Red Hat Inc.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#ifndef GCONF_GTHREADPOOL_H
-#define GCONF_GTHREADPOOL_H
-
-#include <glib.h>
-/*
-  #ifdef __cplusplus
-  extern "C" {
-  #endif
-*/
-
-typedef struct _GThreadPool GThreadPool;
-
-struct _GThreadPool {
-  gpointer dummy;
-}
-
-/* this can return NULL on failure and sets errno */
-GThreadPool* g_thread_pool_new          (guint max_threads);
-/* block until all tasks are finished, then return. */
-void         g_thread_pool_finish_all   (GThreadPool* pool);
-void         g_thread_pool_destroy      (GThreadPool* pool);
-
-typedef gpointer (*GWorkerFunc)             (gpointer data);
-typedef void     (*GWorkFinishedNotifyFunc) (gpointer result);
-
-/* Your work func should obviously be thread safe :-) */
-/* The return value of the worker func invocation is passed to the
- * GWorkFinishedNotifyFunc to tell you there are results.
- * GWorkFinishedNotifyFunc is a called from a glib main loop source,
- * so you need to be using the glib main loop to use GThreadPool
- */
-   
-void         g_thread_pool_do_work  (GThreadPool* pool,
-                                     GWorkerFunc work_func,
-                                     GWorkFinishedNotifyFunc notify_func,
-                                     gpointer data);
-
-/*
-  #ifdef __cplusplus
-  }
-  #endif
-*/
-
-#endif
-
-
-
Index: backends/xml-backend.c
===================================================================
RCS file: /cvs/gnome/gconf/backends/xml-backend.c,v
retrieving revision 1.73
diff -u -u -d -p -b -B -r1.73 xml-backend.c
--- backends/xml-backend.c	2000/09/25 03:10:15	1.73
+++ backends/xml-backend.c	2000/12/05 14:56:49
@@ -26,8 +26,8 @@
 #include "xml-cache.h"
 
 
-#include <gnome-xml/tree.h>
-#include <gnome-xml/parser.h>
+#include <libxml/tree.h>
+#include <libxml/parser.h>
 
 #include <stdio.h>
 #include <time.h>
@@ -678,6 +678,9 @@ G_MODULE_EXPORT const gchar*
 g_module_check_init (GModule *module)
 {
   gconf_log(GCL_INFO, _("Initializing XML backend module"));
+
+  LIBXML_TEST_VERSION;
+  xmlKeepBlanksDefault(1);
 
   return NULL;
 }
Index: backends/xml-cache.h
===================================================================
RCS file: /cvs/gnome/gconf/backends/xml-cache.h,v
retrieving revision 1.5
diff -u -u -d -p -b -B -r1.5 xml-cache.h
--- backends/xml-cache.h	2000/08/31 21:25:04	1.5
+++ backends/xml-cache.h	2000/12/05 14:56:49
@@ -21,7 +21,7 @@
 #define GCONF_XML_CACHE_H
 
 #include <gconf/gconf.h>
-#include <gnome-xml/tree.h>
+#include <libxml/tree.h>
 #include "xml-dir.h"
 
 typedef struct _Cache Cache;
Index: backends/xml-dir.c
===================================================================
RCS file: /cvs/gnome/gconf/backends/xml-dir.c,v
retrieving revision 1.17
diff -u -u -d -p -b -B -r1.17 xml-dir.c
--- backends/xml-dir.c	2000/09/25 03:10:15	1.17
+++ backends/xml-dir.c	2000/12/05 14:56:50
@@ -20,7 +20,7 @@
 #include "xml-dir.h"
 #include "xml-entry.h"
 
-#include <gnome-xml/parser.h>
+#include <libxml/parser.h>
 
 #include <stdio.h>
 #include <time.h>
@@ -822,16 +822,16 @@ dir_load_doc(Dir* d, GError** err)
       d->doc = xmlNewDoc("1.0");
     }
   
-  if (d->doc->root == NULL)
+  if (d->doc->xmlRootNode == NULL)
     {
       /* fill it in */
-      d->doc->root = xmlNewDocNode(d->doc, NULL, "gconf", NULL);
+      d->doc->xmlRootNode = xmlNewDocNode(d->doc, NULL, "gconf", NULL);
     }
-  else if (strcmp(d->doc->root->name, "gconf") != 0)
+  else if (strcmp(d->doc->xmlRootNode->name, "gconf") != 0)
     {
       xmlFreeDoc(d->doc);
       d->doc = xmlNewDoc("1.0");
-      d->doc->root = xmlNewDocNode(d->doc, NULL, "gconf", NULL);
+      d->doc->xmlRootNode = xmlNewDocNode(d->doc, NULL, "gconf", NULL);
       need_backup = TRUE; /* save broken stuff */
     }
   else
@@ -864,7 +864,7 @@ dir_load_doc(Dir* d, GError** err)
     }
   
   g_assert(d->doc != NULL);
-  g_assert(d->doc->root != NULL);
+  g_assert(d->doc->xmlRootNode != NULL);
 }
 
 static Entry*
@@ -873,11 +873,11 @@ dir_make_new_entry(Dir* d, const gchar* 
   Entry* e;
 
   g_return_val_if_fail(d->doc != NULL, NULL);
-  g_return_val_if_fail(d->doc->root != NULL, NULL);
+  g_return_val_if_fail(d->doc->xmlRootNode != NULL, NULL);
   
   e = entry_new(relative_key);
 
-  entry_set_node(e, xmlNewChild(d->doc->root, NULL, "entry", NULL));
+  entry_set_node(e, xmlNewChild(d->doc->xmlRootNode, NULL, "entry", NULL));
   
   safe_g_hash_table_insert(d->entry_cache, (gchar*)entry_get_name(e), e);
   
@@ -910,14 +910,14 @@ dir_fill_cache_from_doc(Dir* d)
   xmlNodePtr node;
   
   if (d->doc == NULL ||
-      d->doc->root == NULL ||
-      d->doc->root->childs == NULL)
+      d->doc->xmlRootNode == NULL ||
+      d->doc->xmlRootNode->xmlChildrenNode == NULL)
     {
       /* Empty document - just return. */
       return;
     }
 
-  node = d->doc->root->childs;
+  node = d->doc->xmlRootNode->xmlChildrenNode;
 
   while (node != NULL)
     {
Index: backends/xml-dir.h
===================================================================
RCS file: /cvs/gnome/gconf/backends/xml-dir.h,v
retrieving revision 1.6
diff -u -u -d -p -b -B -r1.6 xml-dir.h
--- backends/xml-dir.h	2000/08/31 21:25:04	1.6
+++ backends/xml-dir.h	2000/12/05 14:56:50
@@ -21,7 +21,7 @@
 #define GCONF_XML_DIR_H
 
 #include <gconf/gconf.h>
-#include <gnome-xml/tree.h>
+#include <libxml/tree.h>
 
 /* Dir stores the information about a given directory */
 
Index: backends/xml-entry.c
===================================================================
RCS file: /cvs/gnome/gconf/backends/xml-entry.c,v
retrieving revision 1.19
diff -u -u -d -p -b -B -r1.19 xml-entry.c
--- backends/xml-entry.c	2000/09/13 17:49:40	1.19
+++ backends/xml-entry.c	2000/12/05 14:56:51
@@ -20,7 +20,7 @@
 #include "xml-entry.h"
 #include <gconf/gconf-internals.h>
 #include <stdlib.h>
-#include <gnome-xml/entities.h>
+#include <libxml/entities.h>
 
 static void
 entry_sync_if_needed(Entry* e, GConfValue* val);
@@ -383,9 +383,9 @@ free_childs(xmlNodePtr node)
 {
   g_return_if_fail(node != NULL);
   
-  if (node->childs)
-    xmlFreeNodeList(node->childs);
-  node->childs = NULL;
+  if (node->xmlChildrenNode)
+    xmlFreeNodeList(node->xmlChildrenNode);
+  node->xmlChildrenNode = NULL;
   node->last = NULL;
 }
 
@@ -604,7 +604,7 @@ find_schema_subnode_by_locale(xmlNodePtr
   xmlNodePtr iter;
   xmlNodePtr found = NULL;
     
-  iter = node->childs;
+  iter = node->xmlChildrenNode;
       
   while (iter != NULL)
     {
@@ -698,12 +698,12 @@ schema_subnode_extract_data(xmlNodePtr n
   else
     gconf_log(GCL_WARNING, _("found <local_schema> with no locale setting"));
   
-  if (node->childs != NULL)
+  if (node->xmlChildrenNode != NULL)
     {
       GConfValue* default_value = NULL;
       gchar* ld_str = NULL;
       GSList* bad_nodes = NULL;
-      xmlNodePtr iter = node->childs;
+      xmlNodePtr iter = node->xmlChildrenNode;
 
       while (iter != NULL)
         {
@@ -841,7 +841,7 @@ schema_node_extract_value(xmlNodePtr nod
       localized_nodes = g_new0(xmlNodePtr, i+2);
       
       /* Find the node for each possible locale */
-      iter = node->childs;
+      iter = node->xmlChildrenNode;
       
       while (iter != NULL)
         {
@@ -892,7 +892,7 @@ schema_node_extract_value(xmlNodePtr nod
 
   /* If no locale matched, try picking the first node */
   if (best == NULL)
-    best = node->childs;
+    best = node->xmlChildrenNode;
   
   /* Extract info from the best locale node */
   if (best != NULL)
@@ -976,7 +976,7 @@ node_extract_value(xmlNodePtr node, cons
       {
         xmlNodePtr iter;
         
-        iter = node->childs;
+        iter = node->xmlChildrenNode;
 
         while (iter != NULL)
           {
@@ -1045,7 +1045,7 @@ node_extract_value(xmlNodePtr node, cons
             break;
           }
         
-        iter = node->childs;
+        iter = node->xmlChildrenNode;
 
         while (iter != NULL)
           {
@@ -1107,7 +1107,7 @@ node_extract_value(xmlNodePtr node, cons
         GConfValue* cdr = NULL;
         xmlNodePtr iter;
         
-        iter = node->childs;
+        iter = node->xmlChildrenNode;
 
         while (iter != NULL)
           {
Index: backends/xml-entry.h
===================================================================
RCS file: /cvs/gnome/gconf/backends/xml-entry.h,v
retrieving revision 1.5
diff -u -u -d -p -b -B -r1.5 xml-entry.h
--- backends/xml-entry.h	2000/08/31 21:25:04	1.5
+++ backends/xml-entry.h	2000/12/05 14:56:51
@@ -21,7 +21,7 @@
 #define GCONF_XML_ENTRY_H
 
 #include <gconf/gconf.h>
-#include <gnome-xml/tree.h>
+#include <libxml/tree.h>
 
 /* Entry stores all the information about a given key */
 
Index: gconf/Makefile.am
===================================================================
RCS file: /cvs/gnome/gconf/gconf/Makefile.am,v
retrieving revision 1.52
diff -u -u -d -p -b -B -r1.52 Makefile.am
--- gconf/Makefile.am	2000/09/11 21:58:47	1.52
+++ gconf/Makefile.am	2000/12/05 14:56:51
@@ -31,7 +31,6 @@ gconfincludedir = $(includedir)/gconf/$(
 gconfinclude_HEADERS =     \
 	gconf.h            \
 	gconf-changeset.h	\
-	gconf-glib-public.h	\
 	gconf-listeners.h  \
 	gconf-schema.h 	   \
 	gconf-value.h	   \
@@ -69,8 +68,6 @@ libgconf_1_la_SOURCES = \
 	gconf-backend.c		\
 	gconf-changeset.c	\
 	gconf-error.c		\
-	gconf-glib.c		\
-	gconf-glib-private.h	\
 	gconf-listeners.c	\
 	gconf-locale.h  	\
 	gconf-locale.c  	\
Index: gconf/gconf-database.h
===================================================================
RCS file: /cvs/gnome/gconf/gconf/gconf-database.h,v
retrieving revision 1.6
diff -u -u -d -p -b -B -r1.6 gconf-database.h
--- gconf/gconf-database.h	2000/10/08 19:51:32	1.6
+++ gconf/gconf-database.h	2000/12/05 14:56:52
@@ -31,7 +31,6 @@ extern "C" {
 #include "gconf-listeners.h"
 #include "gconf-sources.h"
 #include "gconf-internals.h"
-#include "gconf-glib-private.h"
 
 typedef struct _GConfDatabase GConfDatabase;
 
Index: gconf/gconf-error.h
===================================================================
RCS file: /cvs/gnome/gconf/gconf/gconf-error.h,v
retrieving revision 1.15
diff -u -u -d -p -b -B -r1.15 gconf-error.h
--- gconf/gconf-error.h	2000/10/07 01:31:18	1.15
+++ gconf/gconf-error.h	2000/12/05 14:56:52
@@ -22,8 +22,6 @@
 
 #include <glib.h>
 
-#include <gconf/gconf-glib-public.h>
-
 #ifdef __cplusplus
 extern "C" {
 #endif /* __cplusplus */
Index: gconf/gconfd.c
===================================================================
RCS file: /cvs/gnome/gconf/gconf/gconfd.c,v
retrieving revision 1.95
diff -u -u -d -p -b -B -r1.95 gconfd.c
--- gconf/gconfd.c	2000/11/05 18:09:48	1.95
+++ gconf/gconfd.c	2000/12/05 14:56:53
@@ -32,7 +32,6 @@
 #include "gconf-listeners.h"
 #include "gconf-locale.h"
 #include "gconf-schema.h"
-#include "gconf-glib-private.h"
 #include "gconf.h"
 #include "gconfd.h"
 #include "gconf-database.h"
Index: gconf/gconftool.c
===================================================================
RCS file: /cvs/gnome/gconf/gconf/gconftool.c,v
retrieving revision 1.51
diff -u -u -d -p -b -B -r1.51 gconftool.c
--- gconf/gconftool.c	2000/10/10 04:30:18	1.51
+++ gconf/gconftool.c	2000/12/05 14:56:55
@@ -22,8 +22,8 @@
 #include <stdio.h>
 #include <unistd.h>
 #include <popt.h>
-#include <gnome-xml/tree.h>
-#include <gnome-xml/parser.h>
+#include <libxml/tree.h>
+#include <libxml/parser.h>
 #include <stdlib.h>
 #include <errno.h>
 
@@ -314,6 +314,9 @@ main (int argc, char** argv)
   gint nextopt;
   GError* err = NULL;
   
+  LIBXML_TEST_VERSION;
+  xmlKeepBlanksDefault(1);
+  
   ctx = poptGetContext("gconftool", argc, argv, options, 0);
 
   poptReadDefaultConfig(ctx, TRUE);
@@ -1460,7 +1463,7 @@ extract_global_info(xmlNodePtr node,
   xmlNodePtr iter;
   char* default_value = NULL;
       
-  iter = node->childs;
+  iter = node->xmlChildrenNode;
 
   while (iter != NULL)
     {
@@ -1665,7 +1668,7 @@ process_locale_info(xmlNodePtr node, Sch
 
 
   /* Locale-specific info */
-  iter = node->childs;
+  iter = node->xmlChildrenNode;
   
   while (iter != NULL)
     {
@@ -1819,7 +1822,7 @@ process_schema(GConfEngine* conf, xmlNod
       return 1;
     }
   
-  iter = node->childs;
+  iter = node->xmlChildrenNode;
 
   while (iter != NULL)
     {
@@ -1881,7 +1884,7 @@ process_schema_list(GConfEngine* conf, x
 {
   xmlNodePtr iter;
 
-  iter = node->childs;
+  iter = node->xmlChildrenNode;
 
   while (iter != NULL)
     {
@@ -1915,14 +1918,14 @@ do_load_schema_file(GConfEngine* conf, c
       return 1;
     }
 
-  if (doc->root == NULL)
+  if (doc->xmlRootNode == NULL)
     {
       fprintf(stderr, _("Document `%s' is empty?\n"),
               file);
       return 1;
     }
 
-  iter = doc->root;
+  iter = doc->xmlRootNode;
   while (iter != NULL) 
     {
       if (iter->type == XML_ELEMENT_NODE)
@@ -1947,7 +1950,7 @@ do_load_schema_file(GConfEngine* conf, c
       return 1;
     }
 
-  iter = iter->childs;
+  iter = iter->xmlChildrenNode;
 
   while (iter != NULL)
     {
Index: wrappers/gtk/gconf-client.c
===================================================================
RCS file: /cvs/gnome/gconf/wrappers/gtk/gconf-client.c,v
retrieving revision 1.38
diff -u -u -d -p -b -B -r1.38 gconf-client.c
--- wrappers/gtk/gconf-client.c	2000/10/26 02:03:03	1.38
+++ wrappers/gtk/gconf-client.c	2000/12/05 14:56:57
@@ -110,7 +110,8 @@ static void gconf_client_class_init (GCo
 static void gconf_client_init       (GConfClient      *client);
 static void gconf_client_real_unreturned_error (GConfClient* client, GError* error);
 static void gconf_client_real_error            (GConfClient* client, GError* error);
-static void gconf_client_finalize              (GtkObject* object); 
+static void gconf_client_destroy               (GtkObject* object); 
+static void gconf_client_finalize              (GObject* object); 
 
 static void gconf_client_cache                 (GConfClient* client,
                                                 const gchar* key,
@@ -159,7 +160,7 @@ gconf_client_get_type (void)
         (GtkClassInitFunc) NULL,
       };
 
-      client_type = gtk_type_unique (GTK_TYPE_OBJECT, &client_info);
+      client_type = gtk_type_unique (gtk_object_get_type (), &client_info);
     }
 
   return client_type;
@@ -169,15 +170,17 @@ static void
 gconf_client_class_init (GConfClientClass *class)
 {
   GtkObjectClass *object_class;
+  GObjectClass *gobject_class;
 
   object_class = (GtkObjectClass*) class;
+  gobject_class = (GObjectClass*) class;
 
   parent_class = gtk_type_class (gtk_object_get_type ());
   
   client_signals[VALUE_CHANGED] =
     gtk_signal_new ("value_changed",
                     GTK_RUN_LAST,
-                    object_class->type,
+                    GTK_CLASS_TYPE (object_class),
                     GTK_SIGNAL_OFFSET (GConfClientClass, value_changed),
                     gtk_marshal_NONE__POINTER_POINTER,
                     GTK_TYPE_NONE, 2, GTK_TYPE_POINTER, GTK_TYPE_POINTER);
@@ -185,7 +188,7 @@ gconf_client_class_init (GConfClientClas
   client_signals[UNRETURNED_ERROR] =
     gtk_signal_new ("unreturned_error",
                     GTK_RUN_LAST,
-                    object_class->type,
+                    GTK_CLASS_TYPE (object_class),
                     GTK_SIGNAL_OFFSET (GConfClientClass, unreturned_error),
                     gtk_marshal_NONE__POINTER,
                     GTK_TYPE_NONE, 1, GTK_TYPE_POINTER);
@@ -193,7 +196,7 @@ gconf_client_class_init (GConfClientClas
   client_signals[ERROR] =
     gtk_signal_new ("error",
                     GTK_RUN_LAST,
-                    object_class->type,
+                    GTK_CLASS_TYPE (object_class),
                     GTK_SIGNAL_OFFSET (GConfClientClass, error),
                     gtk_marshal_NONE__POINTER,
                     GTK_TYPE_NONE, 1, GTK_TYPE_POINTER);
@@ -204,7 +207,8 @@ gconf_client_class_init (GConfClientClas
   class->unreturned_error = gconf_client_real_unreturned_error;
   class->error            = gconf_client_real_error;
   
-  object_class->finalize  = gconf_client_finalize;
+  object_class->destroy   = gconf_client_destroy;
+  gobject_class->finalize  = gconf_client_finalize;
 }
 
 static void
@@ -236,7 +240,7 @@ destroy_dir_foreach_remove(gpointer key,
 }
 
 static void
-gconf_client_finalize (GtkObject* object)
+gconf_client_destroy (GtkObject* object)
 {
   GConfClient* client = GCONF_CLIENT(object);
 
@@ -245,6 +249,15 @@ gconf_client_finalize (GtkObject* object
   
   gconf_client_clear_cache(client);
   
+  if (parent_class->destroy)
+    (*parent_class->destroy)(object);
+}
+
+static void
+gconf_client_finalize (GObject* object)
+{
+  GConfClient* client = GCONF_CLIENT(object);
+  
   if (client->listeners != NULL)
     {
       gconf_listeners_free(client->listeners);
@@ -265,8 +278,8 @@ gconf_client_finalize (GtkObject* object
       client->engine = NULL;
     }
 
-  if (parent_class->finalize)
-    (*parent_class->finalize)(object);
+  if (G_OBJECT_CLASS (parent_class)->finalize)
+    (* G_OBJECT_CLASS (parent_class)->finalize) (object);
 }
 
 /*
