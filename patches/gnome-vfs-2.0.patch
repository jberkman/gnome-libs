? gnome-vfs-0.4.2.0.tar.gz
Index: .cvsignore
===================================================================
RCS file: /cvs/gnome/gnome-vfs/.cvsignore,v
retrieving revision 1.4
diff -u -u -r1.4 .cvsignore
--- .cvsignore	2000/08/31 11:32:38	1.4
+++ .cvsignore	2000/12/13 11:24:07
@@ -28,3 +28,4 @@
 vfscorbaConf.sh
 vfspthreadConf.sh
 gnome-vfs-config
+gnomevfs-2.0.pc
Index: Makefile.am
===================================================================
RCS file: /cvs/gnome/gnome-vfs/Makefile.am,v
retrieving revision 1.16
diff -u -u -r1.16 Makefile.am
--- Makefile.am	2000/10/11 17:36:39	1.16
+++ Makefile.am	2000/12/13 11:24:08
@@ -31,7 +31,8 @@
 	vfsConf.sh.in				\
 	vfscorbaConf.sh.in			\
 	vfspthreadConf.sh.in			\
-	gnome-vfs-config.in
+	gnome-vfs-config.in			\
+	gnomevfs-2.0.pc
 
 bin_SCRIPTS = $(top_builddir)/gnome-vfs-config
 
@@ -82,4 +83,6 @@
 	  && mv gnome-vfs-config.tmp gnome-vfs-config && \
 		chmod 755 gnome-vfs-config
 
+pkgconfigdir = $(libdir)/pkgconfig
+pkgconfig_DATA = gnomevfs-2.0.pc
 
Index: autogen.sh
===================================================================
RCS file: /cvs/gnome/gnome-vfs/autogen.sh,v
retrieving revision 1.1.1.1
diff -u -u -r1.1.1.1 autogen.sh
--- autogen.sh	1999/08/25 00:15:45	1.1.1.1
+++ autogen.sh	2000/12/13 11:24:08
@@ -14,4 +14,4 @@
     exit 1
 }
 
-. $srcdir/macros/autogen.sh
+USE_GNOME2_MACROS=1 . gnome-autogen.sh
Index: configure.in
===================================================================
RCS file: /cvs/gnome/gnome-vfs/configure.in,v
retrieving revision 1.91
diff -u -u -r1.91 configure.in
--- configure.in	2000/11/07 07:31:55	1.91
+++ configure.in	2000/12/13 11:24:08
@@ -1,12 +1,13 @@
 AC_INIT(libgnomevfs/gnome-vfs.h)
 AM_CONFIG_HEADER(config.h)
 AM_INIT_AUTOMAKE(gnome-vfs, 0.4.2.0)
-AM_ACLOCAL_INCLUDE(macros)
+GNOME_COMMON_INIT
 
 AM_MAINTAINER_MODE
 
 AC_ISC_POSIX
 AC_PROG_CC
+AC_PROG_CPP
 AC_PROG_AWK
 AM_PROG_LIBTOOL
 
@@ -33,14 +34,37 @@
 dnl = Profiling support
 dnl ====================================
 
-dnl Version of the GNOME Platform (1002000 for GNOME 1.2.x)
-GNOME_PLATFORM_VERSION=1002000
-AC_DEFINE_UNQUOTED(GNOME_PLATFORM_VERSION, $GNOME_PLATFORM_VERSION)
-AM_CONDITIONAL(PLATFORM_GNOME_2, test $GNOME_PLATFORM_VERSION -ge 1095000)
-
-dnl Init GNOME for the GNOME 1.2 platform
-if test $GNOME_PLATFORM_VERSION -lt 1095000 ; then
-  GNOME_INIT
+GNOME_PLATFORM_GNOME_2(no)
+
+if test $platform_gnome_2 = yes ; then
+  GNOME_PKGCONFIG_CHECK_MODULES(GLIB, glib-2.0:1.3.1)
+  GNOME_PKGCONFIG_CHECK_MODULES(GTK,  gtk+-2.0:1.3.1)
+  GNOME_PKGCONFIG_CHECK_MODULES(GMODULE, gmodule-2.0:1.3.1)
+  GNOME_PKGCONFIG_CHECK_MODULES(GTHREAD, gthread-2.0:1.3.1)
+  GNOME_PKGCONFIG_CHECK_MODULES(ORBIT, ORBit-2.0:0.5.3)
+  GNOME_PKGCONFIG_CHECK_OPTIONAL_MODULES(OAF, oaf-2.0:0.6.1)
+  GNOME_PKGCONFIG_CHECK_MODULES(XML, libxml-2.0:2.2.8)
+  GNOME_PKGCONFIG_CHECK_MODULES(GCONF, gconfgtk-2.0:0.11.0)
+
+  VFS_GNOME_CFLAGS="$GLIB_CFLAGS"
+  VFS_GNOMEUI_CFLAGS="$GLIB_CFLAGS"
+  VFS_CAPPLET_CFLAGS=
+  VFS_GNOME_LIBS="$GLIB_LIBS"
+  VFS_GNOMEUI_LIBS="GLIB_LIBS"
+  VFS_CAPPLET_LIBS=
+  VFS_GLIB_CONFIG="glib-config-2.0"
+
+  AC_DEFINE(GNOME_PLATFORM_VERSION, 1095000)
+else
+  GNOME_PKGCONFIG_CHECK_MODULES(GLIB, glib:1.2.6)
+  GNOME_PKGCONFIG_CHECK_MODULES(GTK,  gtk+:1.2.6)
+  GNOME_PKGCONFIG_CHECK_MODULES(GMODULE, glib:1.2.6)
+  GNOME_PKGCONFIG_CHECK_MODULES(GTHREAD, gthread:1.2.6)
+  GNOME_PKGCONFIG_CHECK_MODULES(ORBIT, ORBit:0.5.1)
+  GNOME_PKGCONFIG_CHECK_OPTIONAL_MODULES(OAF, oaf:0.6.0)
+  GNOME_PKGCONFIG_CHECK_MODULES(XML, libxml:1.8.8)
+  GNOME_PKGCONFIG_CHECK_MODULES(GCONF, gconfgtk:0.9.0)
+
   VFS_GNOME_CFLAGS="`gnome-config --cflags gnome`"
   VFS_GNOMEUI_CFLAGS="`gnome-config --cflags gnome gnomeui`"
   VFS_CAPPLET_CFLAGS="`gnome-config --cflags gnome gnomeui capplet`"
@@ -48,14 +72,8 @@
   VFS_GNOMEUI_LIBS="`gnome-config --libs gnome gnomeui`"
   VFS_CAPPLET_LIBS="`gnome-config --libs gnome gnomeui capplet`"
   VFS_GLIB_CONFIG="glib-config"
-else
-  VFS_GNOME_CFLAGS="`glib-config-2.0 --cflags`"
-  VFS_GNOMEUI_CFLAGS="`glib-config-2.0 --cflags`"
-  VFS_CAPPLET_CFLAGS=
-  VFS_GNOME_LIBS="`glib-config-2.0 --libs`"
-  VFS_GNOMEUI_LIBS="`glib-config-2.0 --libs`"
-  VFS_CAPPLET_LIBS=
-  VFS_GLIB_CONFIG="glib-config-2.0"
+
+  AC_DEFINE(GNOME_PLATFORM_VERSION, 1002000)
 fi
 AC_SUBST(VFS_GNOME_CFLAGS)
 AC_SUBST(VFS_GNOMEUI_CFLAGS)
@@ -64,30 +82,35 @@
 AC_SUBST(VFS_GNOMEUI_LIBS)
 AC_SUBST(VFS_CAPPLET_LIBS)
 
+AC_SUBST(GLIB_LIBS)
+AC_SUBST(GLIB_CFLAGS)
+AC_SUBST(GMODULE_LIBS)
+AC_SUBST(GMODULE_CFLAGS)
+AC_SUBST(GTHREAD_LIBS)
+AC_SUBST(GTHREAD_CFLAGS)
+AC_SUBST(GTK_LIBS)
+AC_SUBST(GTK_CFLAGS)
+AC_SUBST(ORBIT_LIBS)
+AC_SUBST(ORBIT_CFLAGS)
+AC_SUBST(XML_LIBS)
+AC_SUBST(XML_CFLAGS)
+AC_SUBST(GCONF_LIBS)
+AC_SUBST(GCONF_CFLAGS)
 
-AC_CHECK_PROG(GTKDOC, gtkdoc-mkdb, true, false)
-AM_CONDITIONAL(HAVE_GTK_DOC, $GTKDOC)
-AC_SUBST(HAVE_GTK_DOC)
-
-dnl Let people disable the gtk-doc stuff.
-AC_ARG_ENABLE(gtk-doc, [  --enable-gtk-doc  Use gtk-doc to build documentation [default=auto]], enable_gtk_doc="$enableval", enable_gtk_doc=auto)
-
-if test x$enable_gtk_doc = xauto ; then
-  if test x$GTKDOC = xtrue ; then
-    enable_gtk_doc=yes
-  else
-    enable_gtk_doc=no
-  fi
+AC_SUBST(GNOME_LIBS)
+AC_SUBST(GNOME_LIBDIR)
+AC_SUBST(GNOMEUI_LIBS)
+AC_SUBST(GNOMEGNORBA_LIBS)
+
+AM_CONDITIONAL(USING_OAF, test x"$HAVE_OAF" = "xyes")
+if test x"$HAVE_OAF" = "xyes" ; then
+  AC_DEFINE(USING_OAF)
 fi
+AC_SUBST(OAF_LIBS)
+AC_SUBST(OAF_CFLAGS)
+
+GNOME_GTKDOC_CHECK
 
-dnl NOTE: We need to use a separate automake conditional for this
-dnl       to make this work with the tarballs.
-AM_CONDITIONAL(ENABLE_GTK_DOC, test x$enable_gtk_doc = xyes)
-dnl end documentation support
-
-AC_ARG_ENABLE(gconf,
-              [  --enable-gconf          Enable GConf access backend],
-              gconf_enabled="yes")
 AC_ARG_ENABLE(libefs,
               [  --disable-libefs={yes|no}       Disable libefs access backend],
               libefs_disabled="yes")
@@ -95,25 +118,11 @@
 	      [  --with-default-backend=(corba|pthread)		    ],
 	      default_backend="$withval")
 
-AM_PATH_GLIB(1.2.0,,
-  AC_MSG_ERROR([
-*** GLIB 1.2.0 or better is required. The latest version of GLIB
-*** is always available from ftp://ftp.gtk.org/.]),
-    gmodule gthread)
-
-AM_PATH_GTK(1.2.0,,
-  AC_MSG_ERROR([
-*** Gtk+ 1.2.0 or better is required. The latest version of Gtk+
-*** is always available from ftp://ftp.gtk.org/.]),
-    gmodule gthread)
-
 cflags_set=yes
 GNOME_COMPILE_WARNINGS
 VFS_CFLAGS="$warnCFLAGS $complCFLAGS"
 
-if test $GNOME_PLATFORM_VERSION -lt 1095000 ; then
-  GNOME_SUPPORT_CHECKS
-fi
+GNOME_PKGCONFIG_CHECK_MODULES(GNOMESUPPORT, gnome-support-2.0:1.2.1)
 GNOME_PTHREAD_CHECK
 
 dnl Don't blindly #define them if they're typedef'ed in <sys/types.h>
@@ -121,7 +130,7 @@
 AM_GNOME_OFF_T
 
 ALL_LINGUAS="ca da de el fi fr ga gl hu it ja ko lt nl no pl pt_BR ru sk sl sv tr uk"
-AM_GNOME_GETTEXT
+AM_GNOME2_GETTEXT
 
 AC_FUNC_ALLOCA
 AC_CHECK_FUNCS(getdtablesize open64 lseek64 statvfs)
@@ -218,31 +227,6 @@
 AC_SUBST(WERROR)
 AC_SUBST(VFS_CFLAGS)
 
-using_oaf=no
-AC_PATH_PROG(OAF_CONFIG,oaf-config,no)
-if test x$OAF_CONFIG = xno; then
-	AC_MSG_RESULT("The program oaf-config was not found")
-	OAF_LIBS=""
-	OAF_CFLAGS=""
-else
-	AC_MSG_CHECKING(for Oaf >= 0.3.0)
-	vers=`$OAF_CONFIG --version | \
-		awk 'BEGIN { FS = "."; } { printf "%d", $1 * 1000 + $2;}'`
-	if test "$vers" -ge 3; then
-		using_oaf=yes
-	        OAF_LIBS=`$OAF_CONFIG --libs`
-        	OAF_CFLAGS=`$OAF_CONFIG --cflags`
-		AC_MSG_RESULT(found)
-		AC_DEFINE(USING_OAF)
-	else
-		AC_MSG_RESULT(not found)	
-		AC_MSG_ERROR(Please upgrade the oaf and oaf-devel packages)
-	fi
-fi
-AM_CONDITIONAL(USING_OAF, test x"$using_oaf" = "xyes")
-AC_SUBST(OAF_LIBS)
-AC_SUBST(OAF_CFLAGS)
-
 dnl
 dnl gnome vfs Documentation
 dnl 
@@ -294,29 +278,6 @@
 AC_SUBST(CAPPLET_LIBS)
 
 dnl
-dnl gnome-xml libraries - for WebDAV support in modules/http-method.c
-dnl
-
-AC_PATH_PROG(XML_CONFIG,xml-config,no)
-if test x$XML_CONFIG = "xno"; then
-  AC_MSG_ERROR(Couldn't find xml-config please install the gnome-xml package)
-fi
-XML_LIBS=`$XML_CONFIG --libs`
-XML_CFLAGS=`$XML_CONFIG --cflags`
-AC_SUBST(XML_LIBS)
-AC_SUBST(XML_CFLAGS)
-
-dnl
-dnl gconf
-dnl
-
-AM_PATH_GCONF(0.9.0,,,gconf gconf-gtk)
-AC_SUBST(GCONF_LIBS)
-AC_SUBST(GCONF_CFLAGS)
-AC_SUBST(GTK_LIBS)
-AC_SUBST(GTK_CFLAGS)
-
-dnl
 dnl efs-method.c
 dnl
 
@@ -440,6 +401,7 @@
 test/Makefile
 test/gnome-file-selection/Makefile
 test/vfs-run
+gnomevfs-2.0.pc
 ])
 
 chmod u+x test/vfs-run
Index: gnomevfs-2.0.pc.in
===================================================================
RCS file: gnomevfs-2.0.pc.in
diff -N gnomevfs-2.0.pc.in
--- /dev/null	Tue May  5 16:32:27 1998
+++ gnomevfs-2.0.pc.in	Wed Dec 13 06:24:08 2000
@@ -0,0 +1,12 @@
+prefix=/gnome/head/INSTALL
+exec_prefix=${prefix}
+libdir=${exec_prefix}/lib
+includedir=${prefix}/include
+
+
+Name: gnome-vfs
+Description: The GNOME virtual file-system libraries
+Version: @VERSION@
+Requires: oaf-2.0,gthread-2.0,gmodule-2.0
+Libs: -L${libdir} -lgnomevfs
+Cflags: -I${includedir} -I${libdir}/vfs/include
Index: libgnomevfs/Makefile.am
===================================================================
RCS file: /cvs/gnome/gnome-vfs/libgnomevfs/Makefile.am,v
retrieving revision 1.53
diff -u -u -r1.53 Makefile.am
--- libgnomevfs/Makefile.am	2000/12/11 22:54:51	1.53
+++ libgnomevfs/Makefile.am	2000/12/13 11:24:08
@@ -24,7 +24,8 @@
 lib_LTLIBRARIES = libgnomevfs.la
 
 EXTRA_DIST =					\
-	getdelim.c
+	getdelim.c				\
+	gi18n.c
 
 libgnomevfs_la_LIBADD =				\
 	$(GNOME_LIBDIR)				\
Index: libgnomevfs/gi18n.c
===================================================================
RCS file: gi18n.c
diff -N gi18n.c
--- /dev/null	Tue May  5 16:32:27 1998
+++ gi18n.c	Wed Dec 13 06:24:09 2000
@@ -0,0 +1,320 @@
+/*
+ * Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation
+ * All rights reserved.
+ *
+ * This file is part of the Gnome Library.
+ *
+ * The Gnome Library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Gnome Library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with the Gnome Library; see the file COPYING.LIB.  If not,
+ * write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+static GHashTable *alias_table = NULL;
+static GHashTable *category_table = NULL;
+
+/*read an alias file for the locales*/
+static void
+read_aliases (char *file)
+{
+  FILE *fp;
+  char buf[256];
+
+  if (!alias_table)
+    alias_table = g_hash_table_new (g_str_hash, g_str_equal);
+  fp = fopen (file,"r");
+  if (!fp)
+    return;
+  while (fgets (buf, 256, fp))
+    {
+      char *p, *q, *r;
+
+      g_strstrip (buf);
+      if ((buf[0] == '#') || (buf[0] == '\0'))
+        continue;
+      for (p = buf, q = NULL; *p; p++)
+	if ((*p == '\t') || (*p == ' ')) {
+	  *p = '\0'; q = p;
+	  break;
+	}
+      if (!q)
+	continue;
+      for (p = q, r = NULL; *p; p++)
+	if ((*p == '\t') || (*p == ' ')) {
+	  *p = '\0'; r = p;
+	  break;
+	}
+      if(!r)
+	continue;
+      if (!g_hash_table_lookup (alias_table, buf))
+	g_hash_table_insert (alias_table, g_strdup (buf), g_strdup (r));
+    }
+  fclose (fp);
+}
+
+static char *
+unalias_lang (char *lang)
+{
+  char *p;
+  int i;
+
+  if (!alias_table)
+    {
+      read_aliases ("/usr/share/locale/locale.alias");
+      read_aliases ("/usr/local/share/locale/locale.alias");
+      read_aliases ("/usr/lib/X11/locale/locale.alias");
+      read_aliases ("/usr/openwin/lib/locale/locale.alias");
+    }
+  i = 0;
+  while ((p = g_hash_table_lookup (alias_table, lang)) && (strcmp (p, lang) != 0))
+    {
+      lang = p;
+      if (i++ == 30)
+        {
+          static gboolean said_before = FALSE;
+	  if (!said_before)
+            g_warning ("Too many alias levels for a locale, "
+		       "may indicate a loop");
+	  said_before = TRUE;
+	  return lang;
+	}
+    }
+  return lang;
+}
+
+/* Mask for components of locale spec. The ordering here is from
+ * least significant to most significant
+ */
+enum
+{
+  COMPONENT_CODESET =   1 << 0,
+  COMPONENT_TERRITORY = 1 << 1,
+  COMPONENT_MODIFIER =  1 << 2
+};
+
+/* Break an X/Open style locale specification into components
+ */
+static guint
+explode_locale (const gchar *locale,
+		gchar **language, 
+		gchar **territory, 
+		gchar **codeset, 
+		gchar **modifier)
+{
+  const gchar *uscore_pos;
+  const gchar *at_pos;
+  const gchar *dot_pos;
+
+  guint mask = 0;
+
+  uscore_pos = strchr (locale, '_');
+  dot_pos = strchr (uscore_pos ? uscore_pos : locale, '.');
+  at_pos = strchr (dot_pos ? dot_pos : (uscore_pos ? uscore_pos : locale), '@');
+
+  if (at_pos)
+    {
+      mask |= COMPONENT_MODIFIER;
+      *modifier = g_strdup (at_pos);
+    }
+  else
+    at_pos = locale + strlen (locale);
+
+  if (dot_pos)
+    {
+      mask |= COMPONENT_CODESET;
+      *codeset = g_strndup (dot_pos, at_pos - dot_pos);
+    }
+  else
+    dot_pos = at_pos;
+
+  if (uscore_pos)
+    {
+      mask |= COMPONENT_TERRITORY;
+      *territory = g_strndup (uscore_pos, dot_pos - uscore_pos);
+    }
+  else
+    uscore_pos = dot_pos;
+
+  *language = g_strndup (locale, uscore_pos - locale);
+
+  return mask;
+}
+
+/*
+ * Compute all interesting variants for a given locale name -
+ * by stripping off different components of the value.
+ *
+ * For simplicity, we assume that the locale is in
+ * X/Open format: language[_territory][.codeset][@modifier]
+ *
+ * TODO: Extend this to handle the CEN format (see the GNUlibc docs)
+ *       as well. We could just copy the code from glibc wholesale
+ *       but it is big, ugly, and complicated, so I'm reluctant
+ *       to do so when this should handle 99% of the time...
+ */
+static GList *
+compute_locale_variants (const gchar *locale)
+{
+  GList *retval = NULL;
+
+  gchar *language;
+  gchar *territory;
+  gchar *codeset;
+  gchar *modifier;
+
+  guint mask;
+  guint i;
+
+  g_return_val_if_fail (locale != NULL, NULL);
+
+  mask = explode_locale (locale, &language, &territory, &codeset, &modifier);
+
+  /* Iterate through all possible combinations, from least attractive
+   * to most attractive.
+   */
+  for (i = 0; i <= mask; i++)
+    if ((i & ~mask) == 0)
+      {
+	gchar *val = g_strconcat (language,
+				  (i & COMPONENT_TERRITORY) ? territory : "",
+				  (i & COMPONENT_CODESET) ? codeset : "",
+				  (i & COMPONENT_MODIFIER) ? modifier : "",
+				  NULL);
+	retval = g_list_prepend (retval, val);
+      }
+
+  g_free (language);
+  if (mask & COMPONENT_CODESET)
+    g_free (codeset);
+  if (mask & COMPONENT_TERRITORY)
+    g_free (territory);
+  if (mask & COMPONENT_MODIFIER)
+    g_free (modifier);
+
+  return retval;
+}
+
+/* The following is (partly) taken from the gettext package.
+   Copyright (C) 1995, 1996, 1997, 1998 Free Software Foundation, Inc.  */
+
+static const gchar *
+g_i18n_guess_category_value (const gchar *categoryname)
+{
+  const gchar *retval;
+
+  /* The highest priority value is the `LANGUAGE' environment
+     variable.  This is a GNU extension.  */
+  retval = g_getenv ("LANGUAGE");
+  if ((retval != NULL) && (retval[0] != '\0'))
+    return retval;
+
+  /* `LANGUAGE' is not set.  So we have to proceed with the POSIX
+     methods of looking to `LC_ALL', `LC_xxx', and `LANG'.  On some
+     systems this can be done by the `setlocale' function itself.  */
+
+  /* Setting of LC_ALL overwrites all other.  */
+  retval = g_getenv ("LC_ALL");  
+  if ((retval != NULL) && (retval[0] != '\0'))
+    return retval;
+
+  /* Next comes the name of the desired category.  */
+  retval = g_getenv (categoryname);
+  if ((retval != NULL) && (retval[0] != '\0'))
+    return retval;
+
+  /* Last possibility is the LANG environment variable.  */
+  retval = g_getenv ("LANG");
+  if ((retval != NULL) && (retval[0] != '\0'))
+    return retval;
+
+  return NULL;
+}
+
+/**
+ * g_i18n_get_language_list:
+ * @category_name: Name of category to look up, e.g. "LC_MESSAGES".
+ * 
+ * This computes a list of language strings.  It searches in the
+ * standard environment variables to find the list, which is sorted
+ * in order from most desirable to least desirable.  The `C' locale
+ * is appended to the list if it does not already appear (other routines depend on this behaviour).
+ * If @category_name is %NULL, then LC_ALL is assumed.
+ * 
+ * Return value: a copy of the list of languages.
+ **/
+static GList *
+g_i18n_get_language_list (const gchar *category_name)
+{
+  GList *list;
+
+  if (!category_name)
+    category_name = "LC_ALL";
+
+  if (category_table)
+    {
+      list = g_hash_table_lookup (category_table, (const gpointer) category_name);
+    }
+  else
+    {
+      category_table = g_hash_table_new (g_str_hash, g_str_equal);
+      list = NULL;
+    }
+
+  if (!list)
+    {
+      gint c_locale_defined = FALSE;
+  
+      const gchar *category_value;
+      gchar *category_memory, *orig_category_memory;
+
+      category_value = g_i18n_guess_category_value (category_name);
+      if (!category_value)
+	category_value = "C";
+      orig_category_memory = category_memory =
+	g_malloc (strlen (category_value)+1);
+      
+      while (category_value[0] != '\0')
+	{
+	  while ((category_value[0] != '\0') && (category_value[0] == ':'))
+	    ++category_value;
+	  
+	  if (category_value[0] != '\0')
+	    {
+	      char *cp = category_memory;
+	      
+	      while ((category_value[0] != '\0') && (category_value[0] != ':'))
+		*category_memory++ = *category_value++;
+	      
+	      category_memory[0] = '\0'; 
+	      category_memory++;
+	      
+	      cp = unalias_lang (cp);
+	      
+	      if (strcmp (cp, "C") == 0)
+		c_locale_defined = TRUE;
+	      
+	      list = g_list_concat (list, compute_locale_variants (cp));
+	    }
+	}
+
+      g_free (orig_category_memory);
+      
+      if (!c_locale_defined)
+	list= g_list_append (list, "C");
+
+      g_hash_table_insert (category_table, (gpointer) category_name, list);
+    }
+
+  return g_list_reverse (g_list_copy (list));
+}
+
Index: libgnomevfs/gnome-i18n.c
===================================================================
RCS file: gnome-i18n.c
diff -N gnome-i18n.c
--- /dev/null	Tue May  5 16:32:27 1998
+++ gnome-i18n.c	Wed Dec 13 06:24:09 2000
@@ -0,0 +1,369 @@
+#include <config.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <glib.h>
+
+#include "gnome-vfs.h"
+#include "gnome-vfs-private.h"
+
+/* Name of config key we use when looking up preferred language. */
+#define LANGKEY "/Gnome/i18n/LANG"
+
+static GHashTable *alias_table = NULL;
+
+/*read an alias file for the locales*/
+static void
+read_aliases (char *file)
+{
+  FILE *fp;
+  char buf[256];
+  if (!alias_table)
+    alias_table = g_hash_table_new (g_str_hash, g_str_equal);
+  fp = fopen (file,"r");
+  if (!fp)
+    return;
+  while (fgets (buf,256,fp))
+    {
+      char *p;
+      g_strstrip(buf);
+      if (buf[0]=='#' || buf[0]=='\0')
+        continue;
+      p = strtok (buf,"\t ");
+      if (!p)
+	continue;
+      p = strtok (NULL,"\t ");
+      if(!p)
+	continue;
+      if (!g_hash_table_lookup (alias_table, buf))
+	g_hash_table_insert (alias_table, g_strdup(buf), g_strdup(p));
+    }
+  fclose (fp);
+}
+
+/*return the un-aliased language as a newly allocated string*/
+static char *
+unalias_lang (char *lang)
+{
+  char *p;
+  if (!alias_table)
+    {
+      read_aliases ("/usr/share/locale/locale.alias");
+      read_aliases ("/usr/local/share/locale/locale.alias");
+      read_aliases ("/usr/lib/X11/locale/locale.alias");
+      read_aliases ("/usr/openwin/lib/locale/locale.alias");
+    }
+  while ((p=g_hash_table_lookup(alias_table,lang)) && strcmp(p, lang))
+      lang = p;
+  return lang;
+}
+
+/**
+ * gnome_i18n_get_language:
+ * 
+ * Returns current language (contents of "LANG" environment variable).
+ * 
+ * Return value: 
+ **/
+const char *
+gnome_i18n_get_language(void)
+{
+  return getenv("LANG");
+}
+
+/* Mask for components of locale spec. The ordering here is from
+ * least significant to most significant
+ */
+enum
+{
+  COMPONENT_CODESET =   1 << 0,
+  COMPONENT_TERRITORY = 1 << 1,
+  COMPONENT_MODIFIER =  1 << 2
+};
+
+/* Break an X/Open style locale specification into components
+ */
+static guint
+explode_locale (const gchar *locale,
+		gchar **language, 
+		gchar **territory, 
+		gchar **codeset, 
+		gchar **modifier)
+{
+  const gchar *uscore_pos;
+  const gchar *at_pos;
+  const gchar *dot_pos;
+
+  guint mask = 0;
+
+  uscore_pos = strchr (locale, '_');
+  dot_pos = strchr (uscore_pos ? uscore_pos : locale, '.');
+  at_pos = strchr (dot_pos ? dot_pos : (uscore_pos ? uscore_pos : locale), '@');
+
+  if (at_pos)
+    {
+      mask |= COMPONENT_MODIFIER;
+      *modifier = g_strdup (at_pos);
+    }
+  else
+    at_pos = locale + strlen (locale);
+
+  if (dot_pos)
+    {
+      mask |= COMPONENT_CODESET;
+      *codeset = g_new (gchar, 1 + at_pos - dot_pos);
+      strncpy (*codeset, dot_pos, at_pos - dot_pos);
+      (*codeset)[at_pos - dot_pos] = '\0';
+    }
+  else
+    dot_pos = at_pos;
+
+  if (uscore_pos)
+    {
+      mask |= COMPONENT_TERRITORY;
+      *territory = g_new (gchar, 1 + dot_pos - uscore_pos);
+      strncpy (*territory, uscore_pos, dot_pos - uscore_pos);
+      (*territory)[dot_pos - uscore_pos] = '\0';
+    }
+  else
+    uscore_pos = dot_pos;
+
+  *language = g_new (gchar, 1 + uscore_pos - locale);
+  strncpy (*language, locale, uscore_pos - locale);
+  (*language)[uscore_pos - locale] = '\0';
+
+  return mask;
+}
+
+/*
+ * Compute all interesting variants for a given locale name -
+ * by stripping off different components of the value.
+ *
+ * For simplicity, we assume that the locale is in
+ * X/Open format: language[_territory][.codeset][@modifier]
+ *
+ * TODO: Extend this to handle the CEN format (see the GNUlibc docs)
+ *       as well. We could just copy the code from glibc wholesale
+ *       but it is big, ugly, and complicated, so I'm reluctant
+ *       to do so when this should handle 99% of the time...
+ */
+static GList *
+compute_locale_variants (const gchar *locale)
+{
+  GList *retval = NULL;
+
+  gchar *language;
+  gchar *territory;
+  gchar *codeset;
+  gchar *modifier;
+
+  guint mask;
+  guint i;
+
+  g_return_val_if_fail (locale != NULL, NULL);
+
+  mask = explode_locale (locale, &language, &territory, &codeset, &modifier);
+
+  /* Iterate through all possible combinations, from least attractive
+   * to most attractive.
+   */
+  for (i=0; i<=mask; i++)
+    if ((i & ~mask) == 0)
+      {
+	gchar *val = g_strconcat(language,
+				 (i & COMPONENT_TERRITORY) ? territory : "",
+				 (i & COMPONENT_CODESET) ? codeset : "",
+				 (i & COMPONENT_MODIFIER) ? modifier : "",
+				 NULL);
+	retval = g_list_prepend (retval, val);
+      }
+
+  g_free (language);
+  if (mask & COMPONENT_CODESET)
+    g_free (codeset);
+  if (mask & COMPONENT_TERRITORY)
+    g_free (territory);
+  if (mask & COMPONENT_MODIFIER)
+    g_free (modifier);
+
+  return retval;
+}
+
+/* The following is (partly) taken from the gettext package.
+   Copyright (C) 1995, 1996, 1997, 1998 Free Software Foundation, Inc.  */
+
+static const gchar *
+guess_category_value (const gchar *categoryname)
+{
+  const gchar *retval;
+
+  /* The highest priority value is the `LANGUAGE' environment
+     variable.  This is a GNU extension.  */
+  retval = getenv ("LANGUAGE");
+  if (retval != NULL && retval[0] != '\0')
+    return retval;
+
+  /* `LANGUAGE' is not set.  So we have to proceed with the POSIX
+     methods of looking to `LC_ALL', `LC_xxx', and `LANG'.  On some
+     systems this can be done by the `setlocale' function itself.  */
+
+  /* Setting of LC_ALL overwrites all other.  */
+  retval = getenv ("LC_ALL");  
+  if (retval != NULL && retval[0] != '\0')
+    return retval;
+
+  /* Next comes the name of the desired category.  */
+  retval = getenv (categoryname);
+  if (retval != NULL && retval[0] != '\0')
+    return retval;
+
+  /* Last possibility is the LANG environment variable.  */
+  retval = getenv ("LANG");
+  if (retval != NULL && retval[0] != '\0')
+    return retval;
+
+  return NULL;
+}
+
+
+static GHashTable *category_table= NULL;
+
+
+/**
+ * gnome_i18n_get_language_list:
+ * @category_name: Name of category to look up, e.g. "LC_MESSAGES".
+ * 
+ * This computes a list of language strings.  It searches in the
+ * standard environment variables to find the list, which is sorted
+ * in order from most desirable to least desirable.  The `C' locale
+ * is appended to the list if it does not already appear.
+ * If @category_name is %NULL, then LC_ALL is assumed.
+ * 
+ * Return value: the list of languages
+ **/
+GList *
+gnome_i18n_get_language_list (const gchar *category_name)
+{
+  GList *list;
+
+  if (!category_name)
+    category_name= "LC_ALL";
+
+  if (category_table)
+    {
+      list= g_hash_table_lookup (category_table, (const gpointer) category_name);
+    }
+  else
+    {
+      category_table= g_hash_table_new (g_str_hash, g_str_equal);
+      list= NULL;
+    }
+
+  if (!list)
+    {
+      gint c_locale_defined= FALSE;
+  
+      const gchar *category_value;
+      gchar *category_memory, *orig_category_memory;
+
+      category_value = guess_category_value (category_name);
+      if (! category_value)
+	category_value = "C";
+      orig_category_memory = category_memory =
+	g_malloc (strlen (category_value)+1);
+      
+      while (category_value[0] != '\0')
+	{
+	  while (category_value[0] != '\0' && category_value[0] == ':')
+	    ++category_value;
+	  
+	  if (category_value[0] != '\0')
+	    {
+	      char *cp= category_memory;
+	      
+	      while (category_value[0] != '\0' && category_value[0] != ':')
+		*category_memory++= *category_value++;
+	      
+	      category_memory[0]= '\0'; 
+	      category_memory++;
+	      
+	      cp = unalias_lang(cp);
+	      
+	      if (strcmp (cp, "C") == 0)
+		c_locale_defined= TRUE;
+	      
+	      list= g_list_concat (list, compute_locale_variants (cp));
+	    }
+	}
+
+      g_free (orig_category_memory);
+      
+      if (!c_locale_defined)
+	list= g_list_append (list, "C");
+
+      g_hash_table_insert (category_table, (gpointer) category_name, list);
+    }
+  
+  return list;
+}
+
+/**
+ * gnome_i18n_set_preferred_language:
+ * @val: Preferred language
+ * 
+ * This sets the user's preferred language in the Gnome config
+ * database.  This value can always be overridden by the standard
+ * environment variables.  It exists so that a config applet which
+ * chooses the preferred language has a standard place to put the
+ * resulting information.
+ **/
+void
+gnome_i18n_set_preferred_language (const char *val)
+{
+  gnome_config_set_string (LANGKEY, val);
+}
+
+/**
+ * gnome_i18n_init:
+ * 
+ * Initialize the i18n environment variables (if not already set) from
+ * the Gnome config database.  Ordinarily this should not be called by
+ * user code.
+ **/
+void
+gnome_i18n_init (void)
+{
+  const gchar *val = guess_category_value ("LC_ALL");
+
+  if (val == NULL)
+    {
+      /* No value in environment.  So we might set up environment
+	 according to what is in the config database.  We do this so
+	 that the user can override the config db using the
+	 environment.  */
+      val = gnome_config_get_string (LANGKEY);
+      if (val != NULL) 
+        {
+#ifdef HAVE_SETENV      
+	  setenv ("LC_ALL", val, 1);
+#else
+#ifdef HAVE_PUTENV
+	  /* It is not safe to free the value passed to putenv.  */
+	  putenv (g_strconcat ("LC_ALL=", val, NULL));
+#endif
+#endif
+	}
+    }
+}
+
+/**
+ * gnome_i18n_get_preferred_language:
+ * 
+ * Return value: the preferred language as set in the Gnome config database.
+ **/
+const char *
+gnome_i18n_get_preferred_language (void)
+{
+  return gnome_config_get_string (LANGKEY);
+}
Index: libgnomevfs/gnome-vfs-private-utils.c
===================================================================
RCS file: /cvs/gnome/gnome-vfs/libgnomevfs/gnome-vfs-private-utils.c,v
retrieving revision 1.11
diff -u -u -r1.11 gnome-vfs-private-utils.c
--- libgnomevfs/gnome-vfs-private-utils.c	2000/10/18 08:04:23	1.11
+++ libgnomevfs/gnome-vfs-private-utils.c	2000/12/13 11:24:10
@@ -513,6 +513,9 @@
 	return FALSE;
 }
 
+#if GNOME_PLATFORM_VERSION >= 1095000
+#include "gi18n.c"
+#endif
 
 /**
  * gnome_vfs_i18n_get_language_list:
Index: modules/http-method.c
===================================================================
RCS file: /cvs/gnome/gnome-vfs/modules/http-method.c,v
retrieving revision 1.109
diff -u -u -r1.109 http-method.c
--- modules/http-method.c	2000/12/12 04:19:23	1.109
+++ modules/http-method.c	2000/12/13 11:24:13
@@ -42,9 +42,9 @@
 
 #include <stdlib.h> /* for atoi */
 
-#include <gnome-xml/parser.h>
-#include <gnome-xml/tree.h>
-#include <gnome-xml/xmlmemory.h>
+#include <libxml/parser.h>
+#include <libxml/tree.h>
+#include <libxml/xmlmemory.h>
 #include <sys/time.h>
 
 
Index: modules/test-method.c
===================================================================
RCS file: /cvs/gnome/gnome-vfs/modules/test-method.c,v
retrieving revision 1.6
diff -u -u -r1.6 test-method.c
--- modules/test-method.c	2000/11/12 05:03:47	1.6
+++ modules/test-method.c	2000/12/13 11:24:13
@@ -36,13 +36,17 @@
 
 #include <stdio.h>
 #include <unistd.h>
+#if GNOME_PLATFORM_VERSION < 1095000
 #include <libgnome/gnome-defs.h>
 #include <libgnome/gnome-util.h>
+#else
+#include <glib.h>
+#endif
 #include <libgnomevfs/gnome-vfs.h>
 #include <libgnomevfs/gnome-vfs-private.h>
 #include <string.h>
-#include <gnome-xml/tree.h>
-#include <gnome-xml/parser.h>
+#include <libxml/tree.h>
+#include <libxml/parser.h>
 #include "gnome-vfs-uri.h"
 
 typedef struct {
