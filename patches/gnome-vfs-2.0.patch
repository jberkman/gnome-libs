? gnome-vfs-0.4.2.0.tar.gz
? gnome-vfs-0.4.2.0-martin.tar.gz
Index: .cvsignore
===================================================================
RCS file: /cvs/gnome/gnome-vfs/.cvsignore,v
retrieving revision 1.6
diff -u -u -p -r1.6 .cvsignore
--- .cvsignore	2001/02/06 10:56:48	1.6
+++ .cvsignore	2001/03/18 18:40:51
@@ -28,6 +28,8 @@ stamp-h.in
 vfsConf.sh
 vfscorbaConf.sh
 vfspthreadConf.sh
+gnome-vfs-config
+gnomevfs-2.0.pc
 xml-i18n-extract
 xml-i18n-extract.in
 xml-i18n-merge
Index: Makefile.am
===================================================================
RCS file: /cvs/gnome/gnome-vfs/Makefile.am,v
retrieving revision 1.20
diff -u -u -p -r1.20 Makefile.am
--- Makefile.am	2001/03/07 22:07:25	1.20
+++ Makefile.am	2001/03/18 18:40:51
@@ -20,8 +20,7 @@ SUBDIRS =					\
 	man					\
 	devel-docs				\
 	$(SUBDIRS_GNOME)			\
-	po					\
-	macros
+	po
 
 
 EXTRA_DIST =					\
@@ -32,10 +31,11 @@ EXTRA_DIST =					\
 	vfsConf.sh.in				\
 	vfscorbaConf.sh.in			\
 	vfspthreadConf.sh.in			\
+	gnome-vfs-config.in			\
+	gnomevfs-2.0.pc				\
 	xml-i18n-extract.in			\
 	xml-i18n-merge.in			\
-	xml-i18n-update.in			\
-	gnome-vfs-config.in
+	xml-i18n-update.in
 
 bin_SCRIPTS = $(top_builddir)/gnome-vfs-config
 
@@ -86,4 +86,6 @@ gnome-vfs-config: gnome-vfs-config.in Ma
 	  && mv gnome-vfs-config.tmp gnome-vfs-config && \
 		chmod 755 gnome-vfs-config
 
+pkgconfigdir = $(libdir)/pkgconfig
+pkgconfig_DATA = gnomevfs-2.0.pc
 
Index: autogen.sh
===================================================================
RCS file: /cvs/gnome/gnome-vfs/autogen.sh,v
retrieving revision 1.1.1.1
diff -u -u -p -r1.1.1.1 autogen.sh
--- autogen.sh	1999/08/25 00:15:45	1.1.1.1
+++ autogen.sh	2001/03/18 18:40:51
@@ -14,4 +14,4 @@ PKG_NAME="GNOME VFS"
     exit 1
 }
 
-. $srcdir/macros/autogen.sh
+USE_GNOME2_MACROS=1 . gnome-autogen.sh
Index: configure.in
===================================================================
RCS file: /cvs/gnome/gnome-vfs/configure.in,v
retrieving revision 1.103
diff -u -u -p -r1.103 configure.in
--- configure.in	2001/03/17 04:27:25	1.103
+++ configure.in	2001/03/18 18:40:53
@@ -1,7 +1,7 @@
 AC_INIT(libgnomevfs/gnome-vfs.h)
 AM_CONFIG_HEADER(config.h)
 AM_INIT_AUTOMAKE(gnome-vfs, 1.1)
-AM_ACLOCAL_INCLUDE(macros)
+GNOME_COMMON_INIT
 
 AM_MAINTAINER_MODE
 
@@ -9,6 +9,7 @@ AM_PROG_XML_I18N_TOOLS
 
 AC_ISC_POSIX
 AC_PROG_CC
+AC_PROG_CPP
 AC_PROG_AWK
 AM_PROG_LIBTOOL
 
@@ -112,30 +113,26 @@ dnl ====================================
 dnl = Profiling support
 dnl ====================================
 
-dnl Version of the GNOME Platform (1002000 for GNOME 1.2.x)
-GNOME_PLATFORM_VERSION=1002000
-AC_DEFINE_UNQUOTED(GNOME_PLATFORM_VERSION, $GNOME_PLATFORM_VERSION)
-AM_CONDITIONAL(PLATFORM_GNOME_2, test $GNOME_PLATFORM_VERSION -ge 1095000)
-
-dnl Init GNOME for the GNOME 1.2 platform
-if test $GNOME_PLATFORM_VERSION -lt 1095000 ; then
-  GNOME_INIT
-  VFS_GNOME_CFLAGS="`gnome-config --cflags gnome`"
-  VFS_GNOMEUI_CFLAGS="`gnome-config --cflags gnome gnomeui`"
-  VFS_CAPPLET_CFLAGS="`gnome-config --cflags gnome gnomeui capplet`"
-  VFS_GNOME_LIBS="`gnome-config --libs gnome`"
-  VFS_GNOMEUI_LIBS="`gnome-config --libs gnome gnomeui`"
-  VFS_CAPPLET_LIBS="`gnome-config --libs gnome gnomeui capplet`"
-  VFS_GLIB_CONFIG="glib-config"
-else
-  VFS_GNOME_CFLAGS="`glib-config-2.0 --cflags`"
-  VFS_GNOMEUI_CFLAGS="`glib-config-2.0 --cflags`"
-  VFS_CAPPLET_CFLAGS=
-  VFS_GNOME_LIBS="`glib-config-2.0 --libs`"
-  VFS_GNOMEUI_LIBS="`glib-config-2.0 --libs`"
-  VFS_CAPPLET_LIBS=
-  VFS_GLIB_CONFIG="glib-config-2.0"
-fi
+GNOME_PLATFORM_GNOME_2(yes, force)
+
+GNOME_PKGCONFIG_CHECK_MODULES(GLIB, glib-2.0:1.3.1)
+GNOME_PKGCONFIG_CHECK_MODULES(GTK,  gtk+-2.0:1.3.1)
+GNOME_PKGCONFIG_CHECK_MODULES(GMODULE, gmodule-2.0:1.3.1)
+GNOME_PKGCONFIG_CHECK_MODULES(GTHREAD, gthread-2.0:1.3.1)
+GNOME_PKGCONFIG_CHECK_MODULES(ORBIT, ORBit-2.0:0.5.3)
+GNOME_PKGCONFIG_CHECK_OPTIONAL_MODULES(OAF, oaf-2.0:0.6.1)
+GNOME_PKGCONFIG_CHECK_MODULES(XML, libxml-2.0:2.2.8)
+GNOME_PKGCONFIG_CHECK_MODULES(GCONF, gconf-2.0:0.11.0)
+
+VFS_GNOME_CFLAGS="$GLIB_CFLAGS"
+VFS_GNOMEUI_CFLAGS="$GLIB_CFLAGS"
+VFS_CAPPLET_CFLAGS=
+VFS_GNOME_LIBS="$GLIB_LIBS"
+VFS_GNOMEUI_LIBS="GLIB_LIBS"
+VFS_CAPPLET_LIBS=
+VFS_GLIB_CONFIG="glib-config-2.0"
+
+AC_DEFINE(GNOME_PLATFORM_VERSION, 1095000)
 AC_SUBST(VFS_GNOME_CFLAGS)
 AC_SUBST(VFS_GNOMEUI_CFLAGS)
 AC_SUBST(VFS_CAPPLET_CFLAGS)
@@ -143,30 +140,35 @@ AC_SUBST(VFS_GNOME_LIBS)
 AC_SUBST(VFS_GNOMEUI_LIBS)
 AC_SUBST(VFS_CAPPLET_LIBS)
 
+AC_SUBST(GLIB_LIBS)
+AC_SUBST(GLIB_CFLAGS)
+AC_SUBST(GMODULE_LIBS)
+AC_SUBST(GMODULE_CFLAGS)
+AC_SUBST(GTHREAD_LIBS)
+AC_SUBST(GTHREAD_CFLAGS)
+AC_SUBST(GTK_LIBS)
+AC_SUBST(GTK_CFLAGS)
+AC_SUBST(ORBIT_LIBS)
+AC_SUBST(ORBIT_CFLAGS)
+AC_SUBST(XML_LIBS)
+AC_SUBST(XML_CFLAGS)
+AC_SUBST(GCONF_LIBS)
+AC_SUBST(GCONF_CFLAGS)
 
-AC_CHECK_PROG(GTKDOC, gtkdoc-mkdb, true, false)
-AM_CONDITIONAL(HAVE_GTK_DOC, $GTKDOC)
-AC_SUBST(HAVE_GTK_DOC)
-
-dnl Let people disable the gtk-doc stuff.
-AC_ARG_ENABLE(gtk-doc, [  --enable-gtk-doc  Use gtk-doc to build documentation [default=auto]], enable_gtk_doc="$enableval", enable_gtk_doc=auto)
-
-if test x$enable_gtk_doc = xauto ; then
-  if test x$GTKDOC = xtrue ; then
-    enable_gtk_doc=yes
-  else
-    enable_gtk_doc=no
-  fi
+AC_SUBST(GNOME_LIBS)
+AC_SUBST(GNOME_LIBDIR)
+AC_SUBST(GNOMEUI_LIBS)
+AC_SUBST(GNOMEGNORBA_LIBS)
+
+AM_CONDITIONAL(USING_OAF, test x"$HAVE_OAF" = "xyes")
+if test x"$HAVE_OAF" = "xyes" ; then
+  AC_DEFINE(USING_OAF)
 fi
+AC_SUBST(OAF_LIBS)
+AC_SUBST(OAF_CFLAGS)
+
+GNOME_GTKDOC_CHECK
 
-dnl NOTE: We need to use a separate automake conditional for this
-dnl       to make this work with the tarballs.
-AM_CONDITIONAL(ENABLE_GTK_DOC, test x$enable_gtk_doc = xyes)
-dnl end documentation support
-
-AC_ARG_ENABLE(gconf,
-              [  --enable-gconf          Enable GConf access backend],
-              gconf_enabled="yes")
 AC_ARG_ENABLE(libefs,
               [  --disable-libefs={yes|no}       Disable libefs access backend],
               libefs_disabled="yes")
@@ -174,25 +176,11 @@ AC_ARG_WITH(default-backend,
 	      [  --with-default-backend=(corba|pthread)		    ],
 	      default_backend="$withval")
 
-AM_PATH_GLIB($GLIB_REQUIRED,,
-  AC_MSG_ERROR([
-*** GLIB 1.2.0 or better is required. The latest version of GLIB
-*** is always available from ftp://ftp.gtk.org/.]),
-    gmodule gthread)
-
-AM_PATH_GTK(1.2.0,,
-  AC_MSG_ERROR([
-*** Gtk+ 1.2.0 or better is required. The latest version of Gtk+
-*** is always available from ftp://ftp.gtk.org/.]),
-    gmodule gthread)
-
 cflags_set=yes
 GNOME_COMPILE_WARNINGS
 VFS_CFLAGS="$warnCFLAGS $complCFLAGS"
 
-if test $GNOME_PLATFORM_VERSION -lt 1095000 ; then
-  GNOME_SUPPORT_CHECKS
-fi
+GNOME_PKGCONFIG_CHECK_MODULES(GNOMESUPPORT, gnome-support-2.0:1.2.1)
 GNOME_PTHREAD_CHECK
 
 dnl Don't blindly #define them if they're typedef'ed in <sys/types.h>
@@ -200,7 +188,7 @@ AM_GNOME_SIZE_T
 AM_GNOME_OFF_T
 
 ALL_LINGUAS="az ca da de el es fi fr ga gl hu it ja ko lt nl nn no pl pt_BR ro ru sk sl sv tr uk wa"
-AM_GNOME_GETTEXT
+AM_GNOME2_GETTEXT
 
 AC_FUNC_ALLOCA
 AC_CHECK_FUNCS(getdtablesize open64 lseek64 statvfs)
@@ -297,23 +285,6 @@ fi
 AC_SUBST(WERROR)
 AC_SUBST(VFS_CFLAGS)
 
-using_oaf=no
-AC_PATH_PROG(OAF_CONFIG,oaf-config,no)
-if test x$OAF_CONFIG = xno; then
-	AC_MSG_RESULT("The program oaf-config was not found")
-	OAF_LIBS=""
-	OAF_CFLAGS=""
-else
-	EAZEL_VERSION_INSIST(oaf, $OAF_CONFIG --version, >=, OAF_REQUIRED)
-	using_oaf=yes
-	AC_DEFINE(USING_OAF)
-	OAF_LIBS=`$OAF_CONFIG --libs`
-	OAF_CFLAGS=`$OAF_CONFIG --cflags`
-fi
-AM_CONDITIONAL(USING_OAF, test x"$using_oaf" = "xyes")
-AC_SUBST(OAF_LIBS)
-AC_SUBST(OAF_CFLAGS)
-
 dnl
 dnl gnome vfs Documentation
 dnl 
@@ -353,29 +324,16 @@ AC_SUBST(VFS_LIBDIR)
 AC_SUBST(VFS_INCLUDEDIR)
 AC_SUBST(VFS_LIBS)
 
-
-dnl
-dnl gnome-xml libraries - for WebDAV support in modules/http-method.c
-dnl
-
-AC_PATH_PROG(XML_CONFIG,xml-config,no)
-if test x$XML_CONFIG = "xno"; then
-  AC_MSG_ERROR(Couldn't find xml-config please install the gnome-xml package)
-fi
-XML_LIBS=`$XML_CONFIG --libs`
-XML_CFLAGS=`$XML_CONFIG --cflags`
-AC_SUBST(XML_LIBS)
-AC_SUBST(XML_CFLAGS)
-
 dnl
-dnl gconf
+dnl Flags needed to build the mime-type capplet
 dnl
-
-AM_PATH_GCONF($GCONF_REQUIRED,,,gconf gconf-gtk)
-AC_SUBST(GCONF_LIBS)
-AC_SUBST(GCONF_CFLAGS)
-AC_SUBST(GTK_LIBS)
-AC_SUBST(GTK_CFLAGS)
+CAPPLET_LIBDIR='-L${libdir}'
+CAPPLET_INCLUDEDIR='-I${includedir} -I${libdir}/vfs/include'
+CAPPLET_INCLUDEDIR="$CAPPLET_INCLUDEDIR $VFS_CAPPLET_CFLAGS"
+CAPPLET_LIBS="$VFS_CAPPLET_LIBS"
+AC_SUBST(CAPPLET_LIBDIR)
+AC_SUBST(CAPPLET_INCLUDEDIR)
+AC_SUBST(CAPPLET_LIBS)
 
 dnl
 dnl efs-method.c
@@ -509,7 +467,7 @@ po/Makefile.in
 test/Makefile
 test/gnome-file-selection/Makefile
 test/vfs-run
-macros/Makefile
+gnomevfs-2.0.pc
 ])
 
 chmod u+x test/vfs-run
Index: gnomevfs-2.0.pc.in
===================================================================
RCS file: gnomevfs-2.0.pc.in
diff -N gnomevfs-2.0.pc.in
--- /dev/null	Tue May  5 16:32:27 1998
+++ gnomevfs-2.0.pc.in	Sun Mar 18 13:40:53 2001
@@ -0,0 +1,12 @@
+prefix=/gnome/head/INSTALL
+exec_prefix=${prefix}
+libdir=${exec_prefix}/lib
+includedir=${prefix}/include
+
+
+Name: gnome-vfs
+Description: The GNOME virtual file-system libraries
+Version: @VERSION@
+Requires: oaf-2.0,gthread-2.0,gmodule-2.0
+Libs: -L${libdir} -lgnomevfs-2
+Cflags: -I${includedir} -I${libdir}/vfs/include
Index: libgnomevfs/Makefile.am
===================================================================
RCS file: /cvs/gnome/gnome-vfs/libgnomevfs/Makefile.am,v
retrieving revision 1.56
diff -u -u -p -r1.56 Makefile.am
--- libgnomevfs/Makefile.am	2001/03/06 23:33:15	1.56
+++ libgnomevfs/Makefile.am	2001/03/18 18:40:53
@@ -21,12 +21,13 @@ INCLUDES =					\
 	-DG_LOG_DOMAIN=\"GnomeVFS\"		\
 	$(NULL)
 
-lib_LTLIBRARIES = libgnomevfs.la
+lib_LTLIBRARIES = libgnomevfs-2.la
 
 EXTRA_DIST =					\
-	getdelim.c
+	getdelim.c				\
+	gi18n.c
 
-libgnomevfs_la_LIBADD =				\
+libgnomevfs_2_la_LIBADD =			\
 	$(GNOME_LIBDIR)				\
 	$(GNOME_LIBS)				\
 	$(OAF_LIBS)	                        \
@@ -34,7 +35,7 @@ libgnomevfs_la_LIBADD =				\
 	$(GLIB_LIBS)				\
 	$(NULL)
 
-libgnomevfs_la_CFLAGS =				\
+libgnomevfs_2_la_CFLAGS =			\
 	$(GNOME_CFLAGS)				\
 	$(OAF_CFLAGS)	                        \
 	$(GCONF_CFLAGS)	                        \
@@ -87,7 +88,7 @@ libgnomevfsinclude_HEADERS =			\
 	gnome-vfs-seekable.h			\
 	gnome-vfs-shellpattern-filter.h
 
-libgnomevfs_la_SOURCES =			\
+libgnomevfs_2_la_SOURCES =			\
 	fnmatch.h				\
 	gnome-vfs-backend.c			\
 	gnome-vfs-cancellation.c		\
Index: libgnomevfs/gi18n.c
===================================================================
RCS file: gi18n.c
diff -N gi18n.c
--- /dev/null	Tue May  5 16:32:27 1998
+++ gi18n.c	Sun Mar 18 13:40:53 2001
@@ -0,0 +1,320 @@
+/*
+ * Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation
+ * All rights reserved.
+ *
+ * This file is part of the Gnome Library.
+ *
+ * The Gnome Library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Gnome Library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with the Gnome Library; see the file COPYING.LIB.  If not,
+ * write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+static GHashTable *alias_table = NULL;
+static GHashTable *category_table = NULL;
+
+/*read an alias file for the locales*/
+static void
+read_aliases (char *file)
+{
+  FILE *fp;
+  char buf[256];
+
+  if (!alias_table)
+    alias_table = g_hash_table_new (g_str_hash, g_str_equal);
+  fp = fopen (file,"r");
+  if (!fp)
+    return;
+  while (fgets (buf, 256, fp))
+    {
+      char *p, *q, *r;
+
+      g_strstrip (buf);
+      if ((buf[0] == '#') || (buf[0] == '\0'))
+        continue;
+      for (p = buf, q = NULL; *p; p++)
+	if ((*p == '\t') || (*p == ' ')) {
+	  *p = '\0'; q = p;
+	  break;
+	}
+      if (!q)
+	continue;
+      for (p = q, r = NULL; *p; p++)
+	if ((*p == '\t') || (*p == ' ')) {
+	  *p = '\0'; r = p;
+	  break;
+	}
+      if(!r)
+	continue;
+      if (!g_hash_table_lookup (alias_table, buf))
+	g_hash_table_insert (alias_table, g_strdup (buf), g_strdup (r));
+    }
+  fclose (fp);
+}
+
+static char *
+unalias_lang (char *lang)
+{
+  char *p;
+  int i;
+
+  if (!alias_table)
+    {
+      read_aliases ("/usr/share/locale/locale.alias");
+      read_aliases ("/usr/local/share/locale/locale.alias");
+      read_aliases ("/usr/lib/X11/locale/locale.alias");
+      read_aliases ("/usr/openwin/lib/locale/locale.alias");
+    }
+  i = 0;
+  while ((p = g_hash_table_lookup (alias_table, lang)) && (strcmp (p, lang) != 0))
+    {
+      lang = p;
+      if (i++ == 30)
+        {
+          static gboolean said_before = FALSE;
+	  if (!said_before)
+            g_warning ("Too many alias levels for a locale, "
+		       "may indicate a loop");
+	  said_before = TRUE;
+	  return lang;
+	}
+    }
+  return lang;
+}
+
+/* Mask for components of locale spec. The ordering here is from
+ * least significant to most significant
+ */
+enum
+{
+  COMPONENT_CODESET =   1 << 0,
+  COMPONENT_TERRITORY = 1 << 1,
+  COMPONENT_MODIFIER =  1 << 2
+};
+
+/* Break an X/Open style locale specification into components
+ */
+static guint
+explode_locale (const gchar *locale,
+		gchar **language, 
+		gchar **territory, 
+		gchar **codeset, 
+		gchar **modifier)
+{
+  const gchar *uscore_pos;
+  const gchar *at_pos;
+  const gchar *dot_pos;
+
+  guint mask = 0;
+
+  uscore_pos = strchr (locale, '_');
+  dot_pos = strchr (uscore_pos ? uscore_pos : locale, '.');
+  at_pos = strchr (dot_pos ? dot_pos : (uscore_pos ? uscore_pos : locale), '@');
+
+  if (at_pos)
+    {
+      mask |= COMPONENT_MODIFIER;
+      *modifier = g_strdup (at_pos);
+    }
+  else
+    at_pos = locale + strlen (locale);
+
+  if (dot_pos)
+    {
+      mask |= COMPONENT_CODESET;
+      *codeset = g_strndup (dot_pos, at_pos - dot_pos);
+    }
+  else
+    dot_pos = at_pos;
+
+  if (uscore_pos)
+    {
+      mask |= COMPONENT_TERRITORY;
+      *territory = g_strndup (uscore_pos, dot_pos - uscore_pos);
+    }
+  else
+    uscore_pos = dot_pos;
+
+  *language = g_strndup (locale, uscore_pos - locale);
+
+  return mask;
+}
+
+/*
+ * Compute all interesting variants for a given locale name -
+ * by stripping off different components of the value.
+ *
+ * For simplicity, we assume that the locale is in
+ * X/Open format: language[_territory][.codeset][@modifier]
+ *
+ * TODO: Extend this to handle the CEN format (see the GNUlibc docs)
+ *       as well. We could just copy the code from glibc wholesale
+ *       but it is big, ugly, and complicated, so I'm reluctant
+ *       to do so when this should handle 99% of the time...
+ */
+static GList *
+compute_locale_variants (const gchar *locale)
+{
+  GList *retval = NULL;
+
+  gchar *language;
+  gchar *territory;
+  gchar *codeset;
+  gchar *modifier;
+
+  guint mask;
+  guint i;
+
+  g_return_val_if_fail (locale != NULL, NULL);
+
+  mask = explode_locale (locale, &language, &territory, &codeset, &modifier);
+
+  /* Iterate through all possible combinations, from least attractive
+   * to most attractive.
+   */
+  for (i = 0; i <= mask; i++)
+    if ((i & ~mask) == 0)
+      {
+	gchar *val = g_strconcat (language,
+				  (i & COMPONENT_TERRITORY) ? territory : "",
+				  (i & COMPONENT_CODESET) ? codeset : "",
+				  (i & COMPONENT_MODIFIER) ? modifier : "",
+				  NULL);
+	retval = g_list_prepend (retval, val);
+      }
+
+  g_free (language);
+  if (mask & COMPONENT_CODESET)
+    g_free (codeset);
+  if (mask & COMPONENT_TERRITORY)
+    g_free (territory);
+  if (mask & COMPONENT_MODIFIER)
+    g_free (modifier);
+
+  return retval;
+}
+
+/* The following is (partly) taken from the gettext package.
+   Copyright (C) 1995, 1996, 1997, 1998 Free Software Foundation, Inc.  */
+
+static const gchar *
+g_i18n_guess_category_value (const gchar *categoryname)
+{
+  const gchar *retval;
+
+  /* The highest priority value is the `LANGUAGE' environment
+     variable.  This is a GNU extension.  */
+  retval = g_getenv ("LANGUAGE");
+  if ((retval != NULL) && (retval[0] != '\0'))
+    return retval;
+
+  /* `LANGUAGE' is not set.  So we have to proceed with the POSIX
+     methods of looking to `LC_ALL', `LC_xxx', and `LANG'.  On some
+     systems this can be done by the `setlocale' function itself.  */
+
+  /* Setting of LC_ALL overwrites all other.  */
+  retval = g_getenv ("LC_ALL");  
+  if ((retval != NULL) && (retval[0] != '\0'))
+    return retval;
+
+  /* Next comes the name of the desired category.  */
+  retval = g_getenv (categoryname);
+  if ((retval != NULL) && (retval[0] != '\0'))
+    return retval;
+
+  /* Last possibility is the LANG environment variable.  */
+  retval = g_getenv ("LANG");
+  if ((retval != NULL) && (retval[0] != '\0'))
+    return retval;
+
+  return NULL;
+}
+
+/**
+ * g_i18n_get_language_list:
+ * @category_name: Name of category to look up, e.g. "LC_MESSAGES".
+ * 
+ * This computes a list of language strings.  It searches in the
+ * standard environment variables to find the list, which is sorted
+ * in order from most desirable to least desirable.  The `C' locale
+ * is appended to the list if it does not already appear (other routines depend on this behaviour).
+ * If @category_name is %NULL, then LC_ALL is assumed.
+ * 
+ * Return value: a copy of the list of languages.
+ **/
+static GList *
+g_i18n_get_language_list (const gchar *category_name)
+{
+  GList *list;
+
+  if (!category_name)
+    category_name = "LC_ALL";
+
+  if (category_table)
+    {
+      list = g_hash_table_lookup (category_table, (const gpointer) category_name);
+    }
+  else
+    {
+      category_table = g_hash_table_new (g_str_hash, g_str_equal);
+      list = NULL;
+    }
+
+  if (!list)
+    {
+      gint c_locale_defined = FALSE;
+  
+      const gchar *category_value;
+      gchar *category_memory, *orig_category_memory;
+
+      category_value = g_i18n_guess_category_value (category_name);
+      if (!category_value)
+	category_value = "C";
+      orig_category_memory = category_memory =
+	g_malloc (strlen (category_value)+1);
+      
+      while (category_value[0] != '\0')
+	{
+	  while ((category_value[0] != '\0') && (category_value[0] == ':'))
+	    ++category_value;
+	  
+	  if (category_value[0] != '\0')
+	    {
+	      char *cp = category_memory;
+	      
+	      while ((category_value[0] != '\0') && (category_value[0] != ':'))
+		*category_memory++ = *category_value++;
+	      
+	      category_memory[0] = '\0'; 
+	      category_memory++;
+	      
+	      cp = unalias_lang (cp);
+	      
+	      if (strcmp (cp, "C") == 0)
+		c_locale_defined = TRUE;
+	      
+	      list = g_list_concat (list, compute_locale_variants (cp));
+	    }
+	}
+
+      g_free (orig_category_memory);
+      
+      if (!c_locale_defined)
+	list= g_list_append (list, "C");
+
+      g_hash_table_insert (category_table, (gpointer) category_name, list);
+    }
+
+  return g_list_reverse (g_list_copy (list));
+}
+
Index: libgnomevfs/gnome-i18n.c
===================================================================
RCS file: gnome-i18n.c
diff -N gnome-i18n.c
--- /dev/null	Tue May  5 16:32:27 1998
+++ gnome-i18n.c	Sun Mar 18 13:40:53 2001
@@ -0,0 +1,369 @@
+#include <config.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <glib.h>
+
+#include "gnome-vfs.h"
+#include "gnome-vfs-private.h"
+
+/* Name of config key we use when looking up preferred language. */
+#define LANGKEY "/Gnome/i18n/LANG"
+
+static GHashTable *alias_table = NULL;
+
+/*read an alias file for the locales*/
+static void
+read_aliases (char *file)
+{
+  FILE *fp;
+  char buf[256];
+  if (!alias_table)
+    alias_table = g_hash_table_new (g_str_hash, g_str_equal);
+  fp = fopen (file,"r");
+  if (!fp)
+    return;
+  while (fgets (buf,256,fp))
+    {
+      char *p;
+      g_strstrip(buf);
+      if (buf[0]=='#' || buf[0]=='\0')
+        continue;
+      p = strtok (buf,"\t ");
+      if (!p)
+	continue;
+      p = strtok (NULL,"\t ");
+      if(!p)
+	continue;
+      if (!g_hash_table_lookup (alias_table, buf))
+	g_hash_table_insert (alias_table, g_strdup(buf), g_strdup(p));
+    }
+  fclose (fp);
+}
+
+/*return the un-aliased language as a newly allocated string*/
+static char *
+unalias_lang (char *lang)
+{
+  char *p;
+  if (!alias_table)
+    {
+      read_aliases ("/usr/share/locale/locale.alias");
+      read_aliases ("/usr/local/share/locale/locale.alias");
+      read_aliases ("/usr/lib/X11/locale/locale.alias");
+      read_aliases ("/usr/openwin/lib/locale/locale.alias");
+    }
+  while ((p=g_hash_table_lookup(alias_table,lang)) && strcmp(p, lang))
+      lang = p;
+  return lang;
+}
+
+/**
+ * gnome_i18n_get_language:
+ * 
+ * Returns current language (contents of "LANG" environment variable).
+ * 
+ * Return value: 
+ **/
+const char *
+gnome_i18n_get_language(void)
+{
+  return getenv("LANG");
+}
+
+/* Mask for components of locale spec. The ordering here is from
+ * least significant to most significant
+ */
+enum
+{
+  COMPONENT_CODESET =   1 << 0,
+  COMPONENT_TERRITORY = 1 << 1,
+  COMPONENT_MODIFIER =  1 << 2
+};
+
+/* Break an X/Open style locale specification into components
+ */
+static guint
+explode_locale (const gchar *locale,
+		gchar **language, 
+		gchar **territory, 
+		gchar **codeset, 
+		gchar **modifier)
+{
+  const gchar *uscore_pos;
+  const gchar *at_pos;
+  const gchar *dot_pos;
+
+  guint mask = 0;
+
+  uscore_pos = strchr (locale, '_');
+  dot_pos = strchr (uscore_pos ? uscore_pos : locale, '.');
+  at_pos = strchr (dot_pos ? dot_pos : (uscore_pos ? uscore_pos : locale), '@');
+
+  if (at_pos)
+    {
+      mask |= COMPONENT_MODIFIER;
+      *modifier = g_strdup (at_pos);
+    }
+  else
+    at_pos = locale + strlen (locale);
+
+  if (dot_pos)
+    {
+      mask |= COMPONENT_CODESET;
+      *codeset = g_new (gchar, 1 + at_pos - dot_pos);
+      strncpy (*codeset, dot_pos, at_pos - dot_pos);
+      (*codeset)[at_pos - dot_pos] = '\0';
+    }
+  else
+    dot_pos = at_pos;
+
+  if (uscore_pos)
+    {
+      mask |= COMPONENT_TERRITORY;
+      *territory = g_new (gchar, 1 + dot_pos - uscore_pos);
+      strncpy (*territory, uscore_pos, dot_pos - uscore_pos);
+      (*territory)[dot_pos - uscore_pos] = '\0';
+    }
+  else
+    uscore_pos = dot_pos;
+
+  *language = g_new (gchar, 1 + uscore_pos - locale);
+  strncpy (*language, locale, uscore_pos - locale);
+  (*language)[uscore_pos - locale] = '\0';
+
+  return mask;
+}
+
+/*
+ * Compute all interesting variants for a given locale name -
+ * by stripping off different components of the value.
+ *
+ * For simplicity, we assume that the locale is in
+ * X/Open format: language[_territory][.codeset][@modifier]
+ *
+ * TODO: Extend this to handle the CEN format (see the GNUlibc docs)
+ *       as well. We could just copy the code from glibc wholesale
+ *       but it is big, ugly, and complicated, so I'm reluctant
+ *       to do so when this should handle 99% of the time...
+ */
+static GList *
+compute_locale_variants (const gchar *locale)
+{
+  GList *retval = NULL;
+
+  gchar *language;
+  gchar *territory;
+  gchar *codeset;
+  gchar *modifier;
+
+  guint mask;
+  guint i;
+
+  g_return_val_if_fail (locale != NULL, NULL);
+
+  mask = explode_locale (locale, &language, &territory, &codeset, &modifier);
+
+  /* Iterate through all possible combinations, from least attractive
+   * to most attractive.
+   */
+  for (i=0; i<=mask; i++)
+    if ((i & ~mask) == 0)
+      {
+	gchar *val = g_strconcat(language,
+				 (i & COMPONENT_TERRITORY) ? territory : "",
+				 (i & COMPONENT_CODESET) ? codeset : "",
+				 (i & COMPONENT_MODIFIER) ? modifier : "",
+				 NULL);
+	retval = g_list_prepend (retval, val);
+      }
+
+  g_free (language);
+  if (mask & COMPONENT_CODESET)
+    g_free (codeset);
+  if (mask & COMPONENT_TERRITORY)
+    g_free (territory);
+  if (mask & COMPONENT_MODIFIER)
+    g_free (modifier);
+
+  return retval;
+}
+
+/* The following is (partly) taken from the gettext package.
+   Copyright (C) 1995, 1996, 1997, 1998 Free Software Foundation, Inc.  */
+
+static const gchar *
+guess_category_value (const gchar *categoryname)
+{
+  const gchar *retval;
+
+  /* The highest priority value is the `LANGUAGE' environment
+     variable.  This is a GNU extension.  */
+  retval = getenv ("LANGUAGE");
+  if (retval != NULL && retval[0] != '\0')
+    return retval;
+
+  /* `LANGUAGE' is not set.  So we have to proceed with the POSIX
+     methods of looking to `LC_ALL', `LC_xxx', and `LANG'.  On some
+     systems this can be done by the `setlocale' function itself.  */
+
+  /* Setting of LC_ALL overwrites all other.  */
+  retval = getenv ("LC_ALL");  
+  if (retval != NULL && retval[0] != '\0')
+    return retval;
+
+  /* Next comes the name of the desired category.  */
+  retval = getenv (categoryname);
+  if (retval != NULL && retval[0] != '\0')
+    return retval;
+
+  /* Last possibility is the LANG environment variable.  */
+  retval = getenv ("LANG");
+  if (retval != NULL && retval[0] != '\0')
+    return retval;
+
+  return NULL;
+}
+
+
+static GHashTable *category_table= NULL;
+
+
+/**
+ * gnome_i18n_get_language_list:
+ * @category_name: Name of category to look up, e.g. "LC_MESSAGES".
+ * 
+ * This computes a list of language strings.  It searches in the
+ * standard environment variables to find the list, which is sorted
+ * in order from most desirable to least desirable.  The `C' locale
+ * is appended to the list if it does not already appear.
+ * If @category_name is %NULL, then LC_ALL is assumed.
+ * 
+ * Return value: the list of languages
+ **/
+GList *
+gnome_i18n_get_language_list (const gchar *category_name)
+{
+  GList *list;
+
+  if (!category_name)
+    category_name= "LC_ALL";
+
+  if (category_table)
+    {
+      list= g_hash_table_lookup (category_table, (const gpointer) category_name);
+    }
+  else
+    {
+      category_table= g_hash_table_new (g_str_hash, g_str_equal);
+      list= NULL;
+    }
+
+  if (!list)
+    {
+      gint c_locale_defined= FALSE;
+  
+      const gchar *category_value;
+      gchar *category_memory, *orig_category_memory;
+
+      category_value = guess_category_value (category_name);
+      if (! category_value)
+	category_value = "C";
+      orig_category_memory = category_memory =
+	g_malloc (strlen (category_value)+1);
+      
+      while (category_value[0] != '\0')
+	{
+	  while (category_value[0] != '\0' && category_value[0] == ':')
+	    ++category_value;
+	  
+	  if (category_value[0] != '\0')
+	    {
+	      char *cp= category_memory;
+	      
+	      while (category_value[0] != '\0' && category_value[0] != ':')
+		*category_memory++= *category_value++;
+	      
+	      category_memory[0]= '\0'; 
+	      category_memory++;
+	      
+	      cp = unalias_lang(cp);
+	      
+	      if (strcmp (cp, "C") == 0)
+		c_locale_defined= TRUE;
+	      
+	      list= g_list_concat (list, compute_locale_variants (cp));
+	    }
+	}
+
+      g_free (orig_category_memory);
+      
+      if (!c_locale_defined)
+	list= g_list_append (list, "C");
+
+      g_hash_table_insert (category_table, (gpointer) category_name, list);
+    }
+  
+  return list;
+}
+
+/**
+ * gnome_i18n_set_preferred_language:
+ * @val: Preferred language
+ * 
+ * This sets the user's preferred language in the Gnome config
+ * database.  This value can always be overridden by the standard
+ * environment variables.  It exists so that a config applet which
+ * chooses the preferred language has a standard place to put the
+ * resulting information.
+ **/
+void
+gnome_i18n_set_preferred_language (const char *val)
+{
+  gnome_config_set_string (LANGKEY, val);
+}
+
+/**
+ * gnome_i18n_init:
+ * 
+ * Initialize the i18n environment variables (if not already set) from
+ * the Gnome config database.  Ordinarily this should not be called by
+ * user code.
+ **/
+void
+gnome_i18n_init (void)
+{
+  const gchar *val = guess_category_value ("LC_ALL");
+
+  if (val == NULL)
+    {
+      /* No value in environment.  So we might set up environment
+	 according to what is in the config database.  We do this so
+	 that the user can override the config db using the
+	 environment.  */
+      val = gnome_config_get_string (LANGKEY);
+      if (val != NULL) 
+        {
+#ifdef HAVE_SETENV      
+	  setenv ("LC_ALL", val, 1);
+#else
+#ifdef HAVE_PUTENV
+	  /* It is not safe to free the value passed to putenv.  */
+	  putenv (g_strconcat ("LC_ALL=", val, NULL));
+#endif
+#endif
+	}
+    }
+}
+
+/**
+ * gnome_i18n_get_preferred_language:
+ * 
+ * Return value: the preferred language as set in the Gnome config database.
+ **/
+const char *
+gnome_i18n_get_preferred_language (void)
+{
+  return gnome_config_get_string (LANGKEY);
+}
Index: libgnomevfs/gnome-vfs-mime-info.c
===================================================================
RCS file: /cvs/gnome/gnome-vfs/libgnomevfs/gnome-vfs-mime-info.c,v
retrieving revision 1.48
diff -u -u -p -r1.48 gnome-vfs-mime-info.c
--- libgnomevfs/gnome-vfs-mime-info.c	2001/03/06 23:33:15	1.48
+++ libgnomevfs/gnome-vfs-mime-info.c	2001/03/18 18:40:54
@@ -35,7 +35,6 @@
 #include "gnome-vfs-result.h"
 #include "gnome-vfs-private.h"
 
-#include <gtk/gtkmain.h>
 #include <stdio.h>
 #include <ctype.h>
 #include <string.h>
Index: libgnomevfs/gnome-vfs-mime-monitor.c
===================================================================
RCS file: /cvs/gnome/gnome-vfs/libgnomevfs/gnome-vfs-mime-monitor.c,v
retrieving revision 1.4
diff -u -u -p -r1.4 gnome-vfs-mime-monitor.c
--- libgnomevfs/gnome-vfs-mime-monitor.c	2001/01/05 19:58:59	1.4
+++ libgnomevfs/gnome-vfs-mime-monitor.c	2001/03/18 18:40:54
@@ -27,13 +27,16 @@
 
 #include "gnome-vfs-mime-private.h"
 
-#include <gtk/gtksignal.h>
+#include <gobject/gobject.h>
+#include <gobject/gsignal.h>
 
 #define GNOME_VFS_MIME_MONITOR(obj) \
-	GTK_CHECK_CAST (obj, gnome_vfs_mime_monitor_get_type (), GnomeVFSMIMEMonitor)
+	G_TYPE_CHECK_INSTANCE_CAST (obj, gnome_vfs_mime_monitor_get_type (), GnomeVFSMIMEMonitor)
 
 typedef struct {
-	GtkObjectClass parent_class;
+	GObjectClass parent_class;
+
+	void (*data_changed);
 } GnomeVFSMIMEMonitorClass;
 
 enum {
@@ -42,33 +45,34 @@ enum {
 };
 static guint signals[LAST_SIGNAL];
 
-static GtkType    gnome_vfs_mime_monitor_get_type         (void);
+static GType      gnome_vfs_mime_monitor_get_type         (void);
 static void       gnome_vfs_mime_monitor_initialize_class (GnomeVFSMIMEMonitorClass *class);
 static void       gnome_vfs_mime_monitor_initialize       (GnomeVFSMIMEMonitor      *monitor);
 
-static gpointer parent_class;
+static gpointer parent_class = NULL;
 
-static GtkType
+static GType
 gnome_vfs_mime_monitor_get_type (void)
 {
-	GtkType parent_type;
-	static GtkType type;
+	static GType type;
 
 	if (type == 0) {
-		static GtkTypeInfo info = {
-			"GnomeVFSMIMEMonitor",
-			sizeof (GnomeVFSMIMEMonitor),
+		static const GTypeInfo info = {
 			sizeof (GnomeVFSMIMEMonitorClass),
-			(GtkClassInitFunc)gnome_vfs_mime_monitor_initialize_class,
-			(GtkObjectInitFunc)gnome_vfs_mime_monitor_initialize,
-			NULL,
-			NULL,
-			NULL
+			(GBaseInitFunc) NULL,
+			(GBaseFinalizeFunc) NULL,
+			(GClassInitFunc)gnome_vfs_mime_monitor_initialize_class,
+			NULL,           /* class_finalize */
+			NULL,           /* class_data */
+			sizeof (GnomeVFSMIMEMonitor),
+			0,              /* n_preallocs */
+			(GInstanceInitFunc)gnome_vfs_mime_monitor_initialize
 		};
 
-		parent_type = GTK_TYPE_OBJECT;
-		type = gtk_type_unique (parent_type, &info);
-		parent_class = gtk_type_class (parent_type);
+		type = g_type_register_static (G_TYPE_OBJECT,
+					       "GnomeVFSMIMEMonitor",
+					       &info,
+					       0);
 	}
 
 	return type;
@@ -82,7 +86,7 @@ gnome_vfs_mime_monitor_get (void)
 {
         if (global_mime_monitor == NULL) {
 		global_mime_monitor = GNOME_VFS_MIME_MONITOR
-			(gtk_object_new (gnome_vfs_mime_monitor_get_type (), NULL));
+			(g_object_new (gnome_vfs_mime_monitor_get_type (), NULL));
         }
         return global_mime_monitor;
 }
@@ -95,24 +99,24 @@ gnome_vfs_mime_monitor_initialize (Gnome
 static void
 gnome_vfs_mime_monitor_initialize_class (GnomeVFSMIMEMonitorClass *class)
 {
-	GtkObjectClass *object_class;
+	GObjectClass *object_class;
 
-	object_class = GTK_OBJECT_CLASS (class);
+	object_class = (GObjectClass*) class;
 
-	signals[DATA_CHANGED]
-		= gtk_signal_new ("data_changed",
-				  GTK_RUN_LAST,
-				  object_class->type,
-				  0,
-				  gtk_marshal_NONE__NONE,
-				  GTK_TYPE_NONE, 0);
+	parent_class = g_type_class_peek_parent (class);
 
-	gtk_object_class_add_signals (object_class, signals, LAST_SIGNAL);
+	signals[DATA_CHANGED] =
+		g_signal_newc ("data_changed",
+			       G_TYPE_FROM_CLASS (object_class),
+			       G_SIGNAL_RUN_LAST,
+			       G_STRUCT_OFFSET (GnomeVFSMIMEMonitorClass, data_changed),
+			       NULL, NULL,
+			       g_cclosure_marshal_VOID__VOID,
+			       G_TYPE_NONE, 0);
 }
 
 void
 gnome_vfs_mime_monitor_emit_data_changed (GnomeVFSMIMEMonitor *monitor)
 {
-	gtk_signal_emit (GTK_OBJECT (monitor),
-			 signals[DATA_CHANGED]);	
+	g_signal_emit (G_OBJECT (monitor), signals[DATA_CHANGED], 0);
 }
Index: libgnomevfs/gnome-vfs-mime-monitor.h
===================================================================
RCS file: /cvs/gnome/gnome-vfs/libgnomevfs/gnome-vfs-mime-monitor.h,v
retrieving revision 1.1
diff -u -u -p -r1.1 gnome-vfs-mime-monitor.h
--- libgnomevfs/gnome-vfs-mime-monitor.h	2000/12/22 19:51:28	1.1
+++ libgnomevfs/gnome-vfs-mime-monitor.h	2001/03/18 18:40:54
@@ -25,10 +25,10 @@
 #ifndef GNOME_VFS_MIME_MONITOR_H
 #define GNOME_VFS_MIME_MONITOR_H
 
-#include <gtk/gtkobject.h>
+#include <gobject/gobject.h>
 
 typedef struct {
-	GtkObject object;
+	GObject object;
 } GnomeVFSMIMEMonitor;
 
 /* Instead of a class declaration here, I will just document
Index: libgnomevfs/gnome-vfs-private-utils.c
===================================================================
RCS file: /cvs/gnome/gnome-vfs/libgnomevfs/gnome-vfs-private-utils.c,v
retrieving revision 1.12
diff -u -u -p -r1.12 gnome-vfs-private-utils.c
--- libgnomevfs/gnome-vfs-private-utils.c	2001/03/06 23:33:15	1.12
+++ libgnomevfs/gnome-vfs-private-utils.c	2001/03/18 18:40:55
@@ -491,6 +491,9 @@ gnome_vfs_atotm (const gchar *time_strin
 	return FALSE;
 }
 
+#if GNOME_PLATFORM_VERSION >= 1095000
+#include "gi18n.c"
+#endif
 
 /**
  * gnome_vfs_i18n_get_language_list:
Index: libgnomevfs-corba/Makefile.am
===================================================================
RCS file: /cvs/gnome/gnome-vfs/libgnomevfs-corba/Makefile.am,v
retrieving revision 1.18
diff -u -u -p -r1.18 Makefile.am
--- libgnomevfs-corba/Makefile.am	2000/11/10 00:54:23	1.18
+++ libgnomevfs-corba/Makefile.am	2001/03/18 18:40:57
@@ -1,7 +1,7 @@
 OBJECT_DIRECTORY_CFLAGS = $(OAF_CFLAGS)
 OBJECT_DIRECTORY_LIBS = $(OAF_LIBS)
 
-lib_LTLIBRARIES = libgnomevfs-corba.la
+lib_LTLIBRARIES = libgnomevfs-corba-2.la
 
 INCLUDES =					\
 	-I$(top_srcdir)				\
@@ -37,7 +37,7 @@ noinst_HEADERS =				\
 	gnome-vfs-slave-notify.h		\
 	gnome-vfs-slave-process.h
 
-libgnomevfs_corba_la_SOURCES =			\
+libgnomevfs_corba_2_la_SOURCES =		\
 	$(gnome_vfs_slave_built)		\
 	gnome-vfs-async-ops.c			\
 	gnome-vfs-corba.c			\
@@ -45,15 +45,15 @@ libgnomevfs_corba_la_SOURCES =			\
 	gnome-vfs-slave-notify.c		\
 	gnome-vfs-slave-process.c
 
-libgnomevfs_corba_la_LDFLAGS=$(OBJECT_DIRECTORY_LIBS)
+libgnomevfs_corba_2_la_LDFLAGS=$(OBJECT_DIRECTORY_LIBS)
 
 gnome_vfs_slave_SOURCES =			\
 	$(gnome_vfs_slave_built)		\
 	gnome-vfs-slave.c
 
 gnome_vfs_slave_LDADD =					\
-	$(top_builddir)/libgnomevfs/libgnomevfs.la	\
-	libgnomevfs-corba.la				\
+	$(top_builddir)/libgnomevfs/libgnomevfs-2.la	\
+	libgnomevfs-corba-2.la				\
 	$(OBJECT_DIRECTORY_LIBS)
 
 bin_PROGRAMS =					\
Index: libgnomevfs-pthread/Makefile.am
===================================================================
RCS file: /cvs/gnome/gnome-vfs/libgnomevfs-pthread/Makefile.am,v
retrieving revision 1.15
diff -u -u -p -r1.15 Makefile.am
--- libgnomevfs-pthread/Makefile.am	2001/01/16 21:46:58	1.15
+++ libgnomevfs-pthread/Makefile.am	2001/03/18 18:40:57
@@ -1,4 +1,4 @@
-lib_LTLIBRARIES = libgnomevfs-pthread.la
+lib_LTLIBRARIES = libgnomevfs-pthread-2.la
 
 INCLUDES =					\
 	-I$(top_srcdir)				\
@@ -22,7 +22,7 @@ noinst_HEADERS = 				\
 	gnome-vfs-thread-pool.h			\
 	gnome-vfs-pthread.h
 
-libgnomevfs_pthread_la_SOURCES =		\
+libgnomevfs_pthread_2_la_SOURCES =		\
 	gnome-vfs-pthread.c			\
 	gnome-vfs-thread-pool.c			\
 	gnome-vfs-async-job-map.c		\
Index: modules/file-method.c
===================================================================
RCS file: /cvs/gnome/gnome-vfs/modules/file-method.c,v
retrieving revision 1.80
diff -u -u -p -r1.80 file-method.c
--- modules/file-method.c	2001/03/06 23:33:20	1.80
+++ modules/file-method.c	2001/03/18 18:41:06
@@ -31,8 +31,6 @@
 #define _LARGEFILE64_SOURCE
 
 #include <glib.h>
-#include <libgnome/gnome-defs.h>
-#include <libgnome/gnome-i18n.h>
 #include <dirent.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -53,6 +51,7 @@
 #include "gnome-vfs-method.h"
 #include "gnome-vfs-utils.h"
 #include "gnome-vfs-module-shared.h"
+#include "gnome-vfs-private.h"
 #include "file-method.h"
 
 
Index: modules/gconf-method.c
===================================================================
RCS file: /cvs/gnome/gnome-vfs/modules/gconf-method.c,v
retrieving revision 1.27
diff -u -u -p -r1.27 gconf-method.c
--- modules/gconf-method.c	2001/03/06 23:33:20	1.27
+++ modules/gconf-method.c	2001/03/18 18:41:06
@@ -706,8 +706,7 @@ vfs_module_init (const char *method_name
 
 	/* These just return and do nothing if GTK
 	   is already initialized. */
-	gtk_type_init();
-	gtk_signal_init();
+	gtk_type_init(G_TYPE_DEBUG_NONE);
 
 	client = gconf_client_get_default ();
 
Index: modules/http-method.c
===================================================================
RCS file: /cvs/gnome/gnome-vfs/modules/http-method.c,v
retrieving revision 1.117
diff -u -u -p -r1.117 http-method.c
--- modules/http-method.c	2001/03/06 23:33:20	1.117
+++ modules/http-method.c	2001/03/18 18:41:09
@@ -42,9 +42,9 @@
 
 #include <stdlib.h> /* for atoi */
 
-#include <gnome-xml/parser.h>
-#include <gnome-xml/tree.h>
-#include <gnome-xml/xmlmemory.h>
+#include <libxml/parser.h>
+#include <libxml/tree.h>
+#include <libxml/xmlmemory.h>
 #include <sys/time.h>
 
 
@@ -2830,8 +2830,7 @@ vfs_module_init (const char *method_name
 	}
 
 	/* ensure GTK is inited for gconf-client. */
-	gtk_type_init ();
-	gtk_signal_init ();
+	gtk_type_init (G_TYPE_DEBUG_NONE);
 
 	gl_client = gconf_client_get_default ();
 
Index: modules/test-method.c
===================================================================
RCS file: /cvs/gnome/gnome-vfs/modules/test-method.c,v
retrieving revision 1.10
diff -u -u -p -r1.10 test-method.c
--- modules/test-method.c	2001/03/06 23:33:21	1.10
+++ modules/test-method.c	2001/03/18 18:41:10
@@ -36,11 +36,13 @@
 
 #include <config.h>
 
-#include <gnome-xml/parser.h>
-#include <gnome-xml/tree.h>
-#include <gnome-xml/xmlmemory.h>
+#include <libxml/parser.h>
+#include <libxml/tree.h>
+#include <libxml/xmlmemory.h>
+#if GNOME_PLATFORM_VERSION < 1095000
 #include <libgnome/gnome-defs.h>
 #include <libgnome/gnome-util.h>
+#endif
 #include <libgnomevfs/gnome-vfs.h>
 #include <libgnomevfs/gnome-vfs-private.h>
 #include <stdio.h>
